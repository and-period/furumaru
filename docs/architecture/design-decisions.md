# アーキテクチャ設計決定

## なぜマイクロサービスアーキテクチャを採用したか

### 背景と課題
- 複数の事業ドメイン（EC、ライブ配信、コンテンツ配信）が存在
- それぞれのドメインで異なる開発速度とスケーリング要件
- チームの独立性を保ちながら開発を進める必要性

### 採用理由
1. **独立したデプロイメント**: サービスごとに異なるリリースサイクルを実現
2. **技術選択の柔軟性**: 各サービスで最適な技術スタックを選択可能
3. **障害の局所化**: 一つのサービスの障害が全体に波及しない
4. **スケーラビリティ**: サービスごとに個別にスケール可能

## なぜレイヤードアーキテクチャを採用したか

### 設計意図
各サービス内で責務を明確に分離し、保守性と拡張性を確保するため：

```
/api/internal/{service}/
├── api/              # 外部との通信インターフェース
├── service/          # ビジネスロジックの実装
├── database/         # データ永続化の詳細
└── entity/           # ビジネスドメインの表現
```

### 各層の役割と境界
- **API層**: プロトコル変換、シリアライゼーション
- **サービス層**: ユースケースの実装、トランザクション境界
- **データベース層**: SQLの詳細、ORMの使用
- **エンティティ層**: ビジネスルール、不変条件の保証

## なぜgRPCを内部通信に採用したか

### 検討した選択肢
1. REST API（HTTP/JSON）
2. GraphQL
3. gRPC（HTTP/2 + Protocol Buffers）

### gRPC採用の決定理由
- **型安全性**: Protocol Buffersによる強い型付け
- **パフォーマンス**: バイナリプロトコルによる高速通信
- **ストリーミング**: 双方向ストリーミングのサポート
- **コード生成**: クライアント/サーバーコードの自動生成

## なぜデータベースを分離したか

### 設計思想
各マイクロサービスが独自のデータストアを持つことで：
- **独立性の確保**: 他サービスの変更に影響されない
- **最適化の自由度**: サービスごとに最適なデータストアを選択
- **スキーマ進化**: 独立したスキーマ変更が可能

### トレードオフ
- データの重複が発生する可能性 → イベント駆動で同期
- 分散トランザクションの複雑性 → Sagaパターンで対応
- 集計クエリの困難さ → CQRS的なアプローチで解決

## なぜAWS Cognitoを認証基盤に選んだか

### 要件
- ソーシャルログイン（Google、LINE）のサポート
- セキュアなトークン管理
- スケーラビリティ

### 決定理由
- **マネージドサービス**: 運用負荷の軽減
- **標準準拠**: OAuth 2.0、OpenID Connect対応
- **AWS統合**: 他のAWSサービスとの親和性
- **コスト効率**: 使用量ベースの課金

## なぜゲートウェイパターンを採用したか

### 問題意識
- フロントエンドから複数のマイクロサービスへの直接通信は複雑
- 認証・認可の一元管理の必要性
- クロスカッティングな関心事の処理場所

### ゲートウェイの役割
```
Frontend → Gateway → Internal Services
           ↓
         - 認証/認可
         - リクエスト集約
         - レート制限
         - キャッシング
```

### 期待される効果
- **クライアントの簡素化**: 単一のエンドポイント
- **セキュリティの強化**: 内部サービスの隠蔽
- **横断的関心事の一元化**: ロギング、監視、キャッシュ

## 技術的負債と今後の課題

### 認識している課題
1. **サービス間通信の複雑性**: サービスメッシュの導入検討
2. **分散トレーシング**: 完全なリクエスト追跡の実装
3. **キャッシュ戦略**: Redisの導入タイミング

### 将来の拡張ポイント
- **イベントソーシング**: 監査ログ、履歴管理
- **CQRS**: 読み取り専用モデルの最適化
- **サーキットブレーカー**: 障害時の自動復旧
