/* tslint:disable */
/* eslint-disable */
/**
 * Marche Online
 * マルシェ管理者用API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivateBroadcastMP4Request
 */
export interface ActivateBroadcastMP4Request {
    /**
     * 配信用の動画URL
     * @type {string}
     * @memberof ActivateBroadcastMP4Request
     */
    'inputUrl'?: string;
}
/**
 * アドレス情報
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * アドレス帳ID
     * @type {string}
     * @memberof Address
     */
    'addressId': string;
    /**
     * 姓
     * @type {string}
     * @memberof Address
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof Address
     */
    'firstname': string;
    /**
     * 姓（かな）
     * @type {string}
     * @memberof Address
     */
    'lastnameKana': string;
    /**
     * 名（かな）
     * @type {string}
     * @memberof Address
     */
    'firstnameKana': string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof Address
     */
    'postalCode': string;
    /**
     * 都道府県
     * @type {string}
     * @memberof Address
     */
    'prefecture': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof Address
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * 町名・番地
     * @type {string}
     * @memberof Address
     */
    'addressLine1': string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof Address
     */
    'addressLine2': string;
    /**
     * 電話番号
     * @type {string}
     * @memberof Address
     */
    'phoneNumber': string;
}


/**
 * 管理者情報
 * @export
 * @interface Admin
 */
export interface Admin {
    /**
     * 管理者ID
     * @type {string}
     * @memberof Admin
     */
    'id': string;
    /**
     * 
     * @type {AdminRole}
     * @memberof Admin
     */
    'role': AdminRole;
    /**
     * 姓
     * @type {string}
     * @memberof Admin
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof Admin
     */
    'firstname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof Admin
     */
    'lastnameKana': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof Admin
     */
    'firstnameKana': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Admin
     */
    'email': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Admin
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Admin
     */
    'updatedAt': number;
}


/**
 * 管理者権限
 * @export
 * @enum {string}
 */

export const AdminRole = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 管理者
    */
    ADMINISTRATOR: 1,
    /**
    * コーディネータ
    */
    COORDINATOR: 2,
    /**
    * 生産者
    */
    PRODUCER: 3
} as const;

export type AdminRole = typeof AdminRole[keyof typeof AdminRole];


/**
 * 管理者の状態
 * @export
 * @enum {string}
 */

export const AdminStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 招待中
    */
    INVITED: 1,
    /**
    * 有効
    */
    ACTIVATED: 2,
    /**
    * 無効
    */
    DEACTIVATED: 3
} as const;

export type AdminStatus = typeof AdminStatus[keyof typeof AdminStatus];


/**
 * 管理者情報
 * @export
 * @interface Administrator
 */
export interface Administrator {
    /**
     * システム管理者ID
     * @type {string}
     * @memberof Administrator
     */
    'id': string;
    /**
     * 
     * @type {AdminStatus}
     * @memberof Administrator
     */
    'status': AdminStatus;
    /**
     * 姓
     * @type {string}
     * @memberof Administrator
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof Administrator
     */
    'firstname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof Administrator
     */
    'lastnameKana': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof Administrator
     */
    'firstnameKana': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Administrator
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof Administrator
     */
    'phoneNumber': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Administrator
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Administrator
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface AdministratorResponse
 */
export interface AdministratorResponse {
    /**
     * 
     * @type {Administrator}
     * @memberof AdministratorResponse
     */
    'administrator': Administrator;
}
/**
 * 
 * @export
 * @interface AdministratorsResponse
 */
export interface AdministratorsResponse {
    /**
     * システム管理者一覧
     * @type {Array<Administrator>}
     * @memberof AdministratorsResponse
     */
    'administrators': Array<Administrator>;
    /**
     * 合計数
     * @type {number}
     * @memberof AdministratorsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface AnalyzeScheduleResponse
 */
export interface AnalyzeScheduleResponse {
    /**
     * 視聴者ログ一覧
     * @type {Array<BroadcastViewerLog>}
     * @memberof AnalyzeScheduleResponse
     */
    'viewerLogs': Array<BroadcastViewerLog>;
    /**
     * 合計視聴者数
     * @type {number}
     * @memberof AnalyzeScheduleResponse
     */
    'totalViewers'?: number;
}
/**
 * 
 * @export
 * @interface ApproveScheduleRequest
 */
export interface ApproveScheduleRequest {
    /**
     * 承認フラグ
     * @type {boolean}
     * @memberof ApproveScheduleRequest
     */
    'approved'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 管理者ID
     * @type {string}
     * @memberof AuthResponse
     */
    'adminId': string;
    /**
     * 
     * @type {AdminRole}
     * @memberof AuthResponse
     */
    'role': AdminRole;
    /**
     * アクセストークン
     * @type {string}
     * @memberof AuthResponse
     */
    'accessToken': string;
    /**
     * 更新トークン
     * @type {string}
     * @memberof AuthResponse
     */
    'refreshToken': string;
    /**
     * 有効期限
     * @type {number}
     * @memberof AuthResponse
     */
    'expiresIn': number;
    /**
     * トークン種別
     * @type {string}
     * @memberof AuthResponse
     */
    'tokenType': string;
}


/**
 * 
 * @export
 * @interface AuthUserResponse
 */
export interface AuthUserResponse {
    /**
     * 管理者ID
     * @type {string}
     * @memberof AuthUserResponse
     */
    'id': string;
    /**
     * 
     * @type {AdminRole}
     * @memberof AuthUserResponse
     */
    'role': AdminRole;
    /**
     * 表示名
     * @type {string}
     * @memberof AuthUserResponse
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof AuthUserResponse
     */
    'email': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof AuthUserResponse
     */
    'thumbnailUrl': string;
}


/**
 * 
 * @export
 * @interface AuthYoutubeBroadcastRequest
 */
export interface AuthYoutubeBroadcastRequest {
    /**
     * 連携するYouTubeアカウントのハンドル名
     * @type {string}
     * @memberof AuthYoutubeBroadcastRequest
     */
    'youtubeHandle': string;
}
/**
 * 
 * @export
 * @interface AuthYoutubeBroadcastResponse
 */
export interface AuthYoutubeBroadcastResponse {
    /**
     * YouTubeの認証URL
     * @type {string}
     * @memberof AuthYoutubeBroadcastResponse
     */
    'url': string;
}
/**
 * マルシェライブ配信情報
 * @export
 * @interface Broadcast
 */
export interface Broadcast {
    /**
     * マルシェライブ配信ID
     * @type {string}
     * @memberof Broadcast
     */
    'id': string;
    /**
     * マルシェ開催スケジュールID
     * @type {string}
     * @memberof Broadcast
     */
    'scheduleId': string;
    /**
     * 
     * @type {BroadcastStatus}
     * @memberof Broadcast
     */
    'status': BroadcastStatus;
    /**
     * ライブ配信URL(入力側)
     * @type {string}
     * @memberof Broadcast
     */
    'inputUrl': string;
    /**
     * ライブ配信URL(出力側)
     * @type {string}
     * @memberof Broadcast
     */
    'outputUrl': string;
    /**
     * オンデマンド配信URL
     * @type {string}
     * @memberof Broadcast
     */
    'archiveUrl': string;
    /**
     * YouTubeアカウントID
     * @type {string}
     * @memberof Broadcast
     */
    'youtubeAccount': string;
    /**
     * YouTube視聴画面URL
     * @type {string}
     * @memberof Broadcast
     */
    'youtubeViewerUrl': string;
    /**
     * YouTube管理画面URL
     * @type {string}
     * @memberof Broadcast
     */
    'youtubeAdminUrl': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Broadcast
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Broadcast
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface BroadcastResponse
 */
export interface BroadcastResponse {
    /**
     * 
     * @type {Broadcast}
     * @memberof BroadcastResponse
     */
    'broadcast': Broadcast;
}
/**
 * マルシェライブ配信状況
 * @export
 * @enum {string}
 */

export const BroadcastStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 配信リソース未作成
    */
    DISABLED: 1,
    /**
    * 配信リソース作成/削除中
    */
    WAITING: 2,
    /**
    * 配信停止中
    */
    IDLE: 3,
    /**
    * 配信中
    */
    ACTIVE: 4
} as const;

export type BroadcastStatus = typeof BroadcastStatus[keyof typeof BroadcastStatus];


/**
 * 
 * @export
 * @interface BroadcastViewerLog
 */
export interface BroadcastViewerLog {
    /**
     * マルシェライブ配信ID
     * @type {string}
     * @memberof BroadcastViewerLog
     */
    'broadcastId': string;
    /**
     * 集計開始日時 (unixtime)
     * @type {number}
     * @memberof BroadcastViewerLog
     */
    'startAt': number;
    /**
     * 集計終了日時 (unixtime)
     * @type {number}
     * @memberof BroadcastViewerLog
     */
    'endAt': number;
    /**
     * 合計視聴者数
     * @type {number}
     * @memberof BroadcastViewerLog
     */
    'total': number;
}
/**
 * 配信ログ取得間隔
 * @export
 * @enum {string}
 */

export const BroadcastViewerLogInterval = {
    SECOND: 'second',
    MINUTE: 'minute',
    HOUR: 'hour'
} as const;

export type BroadcastViewerLogInterval = typeof BroadcastViewerLogInterval[keyof typeof BroadcastViewerLogInterval];


/**
 * 
 * @export
 * @interface CallbackAuthYoutubeBroadcastRequest
 */
export interface CallbackAuthYoutubeBroadcastRequest {
    /**
     * Google認証後に取得したstate
     * @type {string}
     * @memberof CallbackAuthYoutubeBroadcastRequest
     */
    'state': string;
    /**
     * Google認証後に取得したcode
     * @type {string}
     * @memberof CallbackAuthYoutubeBroadcastRequest
     */
    'authCode': string;
}
/**
 * 
 * @export
 * @interface CategoriesResponse
 */
export interface CategoriesResponse {
    /**
     * 商品種別一覧
     * @type {Array<Category>}
     * @memberof CategoriesResponse
     */
    'categories': Array<Category>;
    /**
     * 合計数
     * @type {number}
     * @memberof CategoriesResponse
     */
    'total': number;
}
/**
 * 商品種別情報
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 商品種別ID
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 商品種別名
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Category
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Category
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * 
     * @type {Category}
     * @memberof CategoryResponse
     */
    'category': Category;
}
/**
 * 文字コード種別
 * @export
 * @enum {string}
 */

export const CharacterEncodingType = {
    /**
    * UTF-8
    */
    UTF8: 0,
    /**
    * Shift-JIS
    */
    ShiftJIS: 1
} as const;

export type CharacterEncodingType = typeof CharacterEncodingType[keyof typeof CharacterEncodingType];


/**
 * 
 * @export
 * @interface CompleteOrderRequest
 */
export interface CompleteOrderRequest {
    /**
     * 発送連絡時のメッセージ
     * @type {string}
     * @memberof CompleteOrderRequest
     */
    'shippingMessage': string;
}
/**
 * お問い合わせ情報
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * お問い合わせID
     * @type {string}
     * @memberof Contact
     */
    'id': string;
    /**
     * 件名
     * @type {string}
     * @memberof Contact
     */
    'title': string;
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof Contact
     */
    'categoryId': string;
    /**
     * 内容
     * @type {string}
     * @memberof Contact
     */
    'content': string;
    /**
     * 氏名
     * @type {string}
     * @memberof Contact
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Contact
     */
    'email': string;
    /**
     * 電話番号(国際番号 + 電話番号)
     * @type {string}
     * @memberof Contact
     */
    'phoneNumber': string;
    /**
     * 
     * @type {ContactStatus}
     * @memberof Contact
     */
    'status': ContactStatus;
    /**
     * 対応時メモ
     * @type {string}
     * @memberof Contact
     */
    'note': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Contact
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Contact
     */
    'updatedAt': number;
    /**
     * 会話履歴一覧
     * @type {Array<ThreadResponse>}
     * @memberof Contact
     */
    'threads': Array<ThreadResponse>;
}


/**
 * 
 * @export
 * @interface ContactCategoriesResponse
 */
export interface ContactCategoriesResponse {
    /**
     * お問い合わせ種別一覧
     * @type {Array<ContactCategory>}
     * @memberof ContactCategoriesResponse
     */
    'contactCategories': Array<ContactCategory>;
}
/**
 * お問い合わせ種別情報
 * @export
 * @interface ContactCategory
 */
export interface ContactCategory {
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof ContactCategory
     */
    'id': string;
    /**
     * お問い合わせ種別名
     * @type {string}
     * @memberof ContactCategory
     */
    'title': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof ContactCategory
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof ContactCategory
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface ContactCategoryResponse
 */
export interface ContactCategoryResponse {
    /**
     * 
     * @type {ContactCategory}
     * @memberof ContactCategoryResponse
     */
    'contactCategory': ContactCategory;
}
/**
 * 
 * @export
 * @interface ContactResponse
 */
export interface ContactResponse {
    /**
     * 
     * @type {Contact}
     * @memberof ContactResponse
     */
    'contact': Contact;
    /**
     * 
     * @type {ContactCategory}
     * @memberof ContactResponse
     */
    'contactCategory': ContactCategory;
    /**
     * 会話履歴一覧
     * @type {Array<Thread>}
     * @memberof ContactResponse
     */
    'threads': Array<Thread>;
    /**
     * 
     * @type {User}
     * @memberof ContactResponse
     */
    'user'?: User;
    /**
     * 
     * @type {Admin}
     * @memberof ContactResponse
     */
    'responder'?: Admin;
}
/**
 * お問い合わせ対応状況
 * @export
 * @enum {string}
 */

export const ContactStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 未着手
    */
    WAITING: 1,
    /**
    * 対応中
    */
    INPROGRESS: 2,
    /**
    * 完了
    */
    DONE: 3,
    /**
    * 対応不要
    */
    DISCARD: 4
} as const;

export type ContactStatus = typeof ContactStatus[keyof typeof ContactStatus];


/**
 * 送信者タイプ
 * @export
 * @enum {string}
 */

export const ContactUserType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 管理者
    */
    ADMIN: 1,
    /**
    * ユーザー
    */
    USER: 2,
    /**
    * ゲスト
    */
    GUEST: 3
} as const;

export type ContactUserType = typeof ContactUserType[keyof typeof ContactUserType];


/**
 * 
 * @export
 * @interface ContactsResponse
 */
export interface ContactsResponse {
    /**
     * お問い合わせ一覧
     * @type {Array<Contact>}
     * @memberof ContactsResponse
     */
    'contacts': Array<Contact>;
    /**
     * お問い合わせ種別一覧
     * @type {Array<ContactCategory>}
     * @memberof ContactsResponse
     */
    'contactCategories': Array<ContactCategory>;
    /**
     * 会話履歴一覧
     * @type {Array<Thread>}
     * @memberof ContactsResponse
     */
    'threads': Array<Thread>;
    /**
     * ユーザー一覧
     * @type {Array<User>}
     * @memberof ContactsResponse
     */
    'users'?: Array<User>;
    /**
     * 管理者一覧
     * @type {Array<Admin>}
     * @memberof ContactsResponse
     */
    'responders'?: Array<Admin>;
    /**
     * 合計数
     * @type {number}
     * @memberof ContactsResponse
     */
    'total': number;
}
/**
 * コーディネータ情報
 * @export
 * @interface Coordinator
 */
export interface Coordinator {
    /**
     * コーディネータID
     * @type {string}
     * @memberof Coordinator
     */
    'id': string;
    /**
     * 
     * @type {AdminStatus}
     * @memberof Coordinator
     */
    'status': AdminStatus;
    /**
     * 姓
     * @type {string}
     * @memberof Coordinator
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof Coordinator
     */
    'firstname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof Coordinator
     */
    'lastnameKana': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof Coordinator
     */
    'firstnameKana': string;
    /**
     * マルシェ名
     * @type {string}
     * @memberof Coordinator
     */
    'marcheName': string;
    /**
     * コーディネータ名
     * @type {string}
     * @memberof Coordinator
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Coordinator
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof Coordinator
     */
    'phoneNumber': string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof Coordinator
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof Coordinator
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村
     * @type {string}
     * @memberof Coordinator
     */
    'city': string;
    /**
     * 町名・番地
     * @type {string}
     * @memberof Coordinator
     */
    'addressLine1': string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof Coordinator
     */
    'addressLine2': string;
    /**
     * プロフィール
     * @type {string}
     * @memberof Coordinator
     */
    'profile': string;
    /**
     * 取り扱い品目ID一覧
     * @type {Array<string>}
     * @memberof Coordinator
     */
    'productTypeIds': Array<string>;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Coordinator
     */
    'thumbnailUrl': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof Coordinator
     */
    'headerUrl': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof Coordinator
     */
    'promotionVideoUrl': string;
    /**
     * 購入特典動画URL
     * @type {string}
     * @memberof Coordinator
     */
    'bonusVideoUrl': string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof Coordinator
     */
    'instagramId': string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof Coordinator
     */
    'facebookId': string;
    /**
     * 営業曜日
     * @type {Array<Weekday>}
     * @memberof Coordinator
     */
    'businessDays': Array<Weekday>;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Coordinator
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Coordinator
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface CoordinatorResponse
 */
export interface CoordinatorResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof CoordinatorResponse
     */
    'coordinator': Coordinator;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof CoordinatorResponse
     */
    'productTypes': Array<ProductType>;
    /**
     * パスワード
     * @type {string}
     * @memberof CoordinatorResponse
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CoordinatorsResponse
 */
export interface CoordinatorsResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof CoordinatorsResponse
     */
    'coordinators': Array<Coordinator>;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof CoordinatorsResponse
     */
    'productTypes': Array<ProductType>;
    /**
     * 合計数
     * @type {number}
     * @memberof CoordinatorsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface CreateAdministratorRequest
 */
export interface CreateAdministratorRequest {
    /**
     * 姓(16文字まで)
     * @type {string}
     * @memberof CreateAdministratorRequest
     */
    'lastname': string;
    /**
     * 名(16文字まで)
     * @type {string}
     * @memberof CreateAdministratorRequest
     */
    'firstname': string;
    /**
     * 姓(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof CreateAdministratorRequest
     */
    'lastnameKana': string;
    /**
     * 名(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof CreateAdministratorRequest
     */
    'firstnameKana': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof CreateAdministratorRequest
     */
    'email': string;
    /**
     * 電話番号(国際番号 + 電話番号)
     * @type {string}
     * @memberof CreateAdministratorRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface CreateCategoryRequest
 */
export interface CreateCategoryRequest {
    /**
     * カテゴリ名(32文字まで)
     * @type {string}
     * @memberof CreateCategoryRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateContactRequest
 */
export interface CreateContactRequest {
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof CreateContactRequest
     */
    'categoryId': string;
    /**
     * お問い合わせ件名(128文字まで)
     * @type {string}
     * @memberof CreateContactRequest
     */
    'title': string;
    /**
     * お問い合わせ内容(2000文字まで)
     * @type {string}
     * @memberof CreateContactRequest
     */
    'content': string;
    /**
     * 氏名(128文字まで)
     * @type {string}
     * @memberof CreateContactRequest
     */
    'userName': string;
    /**
     * 問い合わせ作成者ID
     * @type {string}
     * @memberof CreateContactRequest
     */
    'userId'?: string;
    /**
     * メールアドレス(256文字まで)
     * @type {string}
     * @memberof CreateContactRequest
     */
    'email': string;
    /**
     * 電話番号(18文字まで)
     * @type {string}
     * @memberof CreateContactRequest
     */
    'phoneNumber': string;
    /**
     * 対応者ID
     * @type {string}
     * @memberof CreateContactRequest
     */
    'responderId': string;
    /**
     * 対応メモ(2000文字まで)
     * @type {string}
     * @memberof CreateContactRequest
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface CreateCoordinatorRequest
 */
export interface CreateCoordinatorRequest {
    /**
     * 姓(16文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'lastname': string;
    /**
     * 名(16文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'firstname': string;
    /**
     * 姓(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'lastnameKana': string;
    /**
     * 名(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'firstnameKana': string;
    /**
     * マルシェ名(64文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'marcheName': string;
    /**
     * コーディネータ名(64文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'phoneNumber': string;
    /**
     * 郵便番号(ハイフンなし)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof CreateCoordinatorRequest
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村(32文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'city': string;
    /**
     * 町名・番地(64文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'addressLine1': string;
    /**
     * ビル名・号室など(64文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'addressLine2': string;
    /**
     * プロフィール(2000文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'profile': string;
    /**
     * 取り扱い品目ID一覧
     * @type {Array<string>}
     * @memberof CreateCoordinatorRequest
     */
    'productTypeIds': Array<string>;
    /**
     * サムネイル画像URL
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'thumbnailUrl': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'headerUrl': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'promotionVideoUrl': string;
    /**
     * 購入者動画URL
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'bonusVideoUrl': string;
    /**
     * Instagramアカウント(30文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'instagramId': string;
    /**
     * Facebookアカウント(50文字まで)
     * @type {string}
     * @memberof CreateCoordinatorRequest
     */
    'facebookId': string;
    /**
     * 営業曜日
     * @type {Array<Weekday>}
     * @memberof CreateCoordinatorRequest
     */
    'businessDays': Array<Weekday>;
}


/**
 * 
 * @export
 * @interface CreateExperienceRequest
 */
export interface CreateExperienceRequest {
    /**
     * タイトル(128文字まで)
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'title': string;
    /**
     * 説明(20000文字まで)
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof CreateExperienceRequest
     */
    'public': boolean;
    /**
     * 完売フラグ
     * @type {boolean}
     * @memberof CreateExperienceRequest
     */
    'soldOut': boolean;
    /**
     * コーディネータID
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'coordinatorId': string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'producerId': string;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'experienceTypeId': string;
    /**
     * メディア一覧(8つまで)
     * @type {Array<ExperienceMediaInner>}
     * @memberof CreateExperienceRequest
     */
    'media': Array<ExperienceMediaInner>;
    /**
     * 大人販売価格(税込:0以上)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'priceAdult': number;
    /**
     * 中学生販売価格(税込:0以上)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'priceJuniorHighSchool': number;
    /**
     * 小学生販売価格(税込:0以上)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'priceElementarySchool': number;
    /**
     * 幼児販売価格(税込:0以上)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'pricePreschooler': number;
    /**
     * シニア販売価格(税込:0以上)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'priceSenior': number;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'recommendedPoint1': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'recommendedPoint2': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'recommendedPoint3': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof CreateExperienceRequest
     */
    'hostPrefectureCode': Prefecture;
    /**
     * 開催場所(市区町村)
     * @type {string}
     * @memberof CreateExperienceRequest
     */
    'hostCity': string;
    /**
     * 販売開始日時 (unixtime)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'startAt': number;
    /**
     * 販売終了日時 (unixtime)
     * @type {number}
     * @memberof CreateExperienceRequest
     */
    'endAt': number;
}


/**
 * 
 * @export
 * @interface CreateExperienceTypeRequest
 */
export interface CreateExperienceTypeRequest {
    /**
     * 体験種別名(32文字まで)
     * @type {string}
     * @memberof CreateExperienceTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateLiveRequest
 */
export interface CreateLiveRequest {
    /**
     * 生産者ID
     * @type {string}
     * @memberof CreateLiveRequest
     */
    'producerId': string;
    /**
     * 商品一覧(8つまで)
     * @type {Array<string>}
     * @memberof CreateLiveRequest
     */
    'productIds': Array<string>;
    /**
     * コメント
     * @type {string}
     * @memberof CreateLiveRequest
     */
    'comment': string;
    /**
     * ライブ開始予定日時 (unixtime)
     * @type {number}
     * @memberof CreateLiveRequest
     */
    'startAt': number;
    /**
     * ライブ終了予定日時 (unixtime)
     * @type {number}
     * @memberof CreateLiveRequest
     */
    'endAt': number;
}
/**
 * 
 * @export
 * @interface CreateNotificationRequest
 */
export interface CreateNotificationRequest {
    /**
     * 
     * @type {NotificationType}
     * @memberof CreateNotificationRequest
     */
    'type': NotificationType;
    /**
     * 通知対象一覧
     * @type {Array<NotificationTarget>}
     * @memberof CreateNotificationRequest
     */
    'targets': Array<NotificationTarget>;
    /**
     * タイトル(128字まで)
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'title': string;
    /**
     * 本文(2000字まで)
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'body': string;
    /**
     * 備考(2000字まで)
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'note': string;
    /**
     * 掲載日時 (unixtime)
     * @type {number}
     * @memberof CreateNotificationRequest
     */
    'publishedAt': number;
    /**
     * プロモーションID
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'promotionId': string;
}


/**
 * 
 * @export
 * @interface CreateProducerRequest
 */
export interface CreateProducerRequest {
    /**
     * コーディネータID
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'coordinatorId': string;
    /**
     * 姓(16文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'lastname': string;
    /**
     * 名(16文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'firstname': string;
    /**
     * 姓(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'lastnameKana': string;
    /**
     * 名(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'firstnameKana': string;
    /**
     * 生産者名(64文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'phoneNumber': string;
    /**
     * 郵便番号(ハイフンなし)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof CreateProducerRequest
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村(32文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'city': string;
    /**
     * 町名・番地(64文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'addressLine1': string;
    /**
     * ビル名・号室など(64文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'addressLine2': string;
    /**
     * プロフィール(2000文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'profile': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'thumbnailUrl': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'headerUrl': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'promotionVideoUrl': string;
    /**
     * 購入者動画URL
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'bonusVideoUrl': string;
    /**
     * Instagramアカウント(30文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'instagramId': string;
    /**
     * Facebookアカウント(50文字まで)
     * @type {string}
     * @memberof CreateProducerRequest
     */
    'facebookId': string;
}


/**
 * 
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * 商品名(128文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name': string;
    /**
     * 商品説明(20000文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof CreateProductRequest
     */
    'public': boolean;
    /**
     * コーディネータID
     * @type {string}
     * @memberof CreateProductRequest
     */
    'coordinatorId': string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof CreateProductRequest
     */
    'producerId': string;
    /**
     * 品目ID
     * @type {string}
     * @memberof CreateProductRequest
     */
    'productTypeId': string;
    /**
     * 商品タグ一覧
     * @type {Array<string>}
     * @memberof CreateProductRequest
     */
    'productTagIds': Array<string>;
    /**
     * メディア一覧(8つまで)
     * @type {Array<ProductMediaInner>}
     * @memberof CreateProductRequest
     */
    'media': Array<ProductMediaInner>;
    /**
     * 販売価格(税込:0以上)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'price': number;
    /**
     * 原価(税込:0以上)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'cost': number;
    /**
     * 在庫数(0以上)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'inventory': number;
    /**
     * 重量(0以上,kg単位:少数第1位まで)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'weight': number;
    /**
     * 数量単位(16文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'itemUnit': string;
    /**
     * 数量単位説明(64文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'itemDescription': string;
    /**
     * 
     * @type {DeliveryType}
     * @memberof CreateProductRequest
     */
    'deliveryType': DeliveryType;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'recommendedPoint1': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'recommendedPoint2': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'recommendedPoint3': string;
    /**
     * 賞味期限(単位:日,0以上)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'expirationDate': number;
    /**
     * 
     * @type {StorageMethodType}
     * @memberof CreateProductRequest
     */
    'storageMethodType': StorageMethodType;
    /**
     * 箱の占有率(サイズ:60)(0以上,100以下)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'box60Rate': number;
    /**
     * 箱の占有率(サイズ:80)(0以上,100以下)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'box80Rate': number;
    /**
     * 箱の占有率(サイズ:100)(0以上,100以下)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'box100Rate': number;
    /**
     * 
     * @type {Prefecture}
     * @memberof CreateProductRequest
     */
    'originPrefectureCode': Prefecture;
    /**
     * 原産地(市区町村)(32文字まで)
     * @type {string}
     * @memberof CreateProductRequest
     */
    'originCity': string;
    /**
     * 販売開始日時 (unixtime)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'startAt': number;
    /**
     * 販売終了日時 (unixtime)
     * @type {number}
     * @memberof CreateProductRequest
     */
    'endAt': number;
}


/**
 * 
 * @export
 * @interface CreateProductTagRequest
 */
export interface CreateProductTagRequest {
    /**
     * 商品タグ名(32文字まで)
     * @type {string}
     * @memberof CreateProductTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateProductTypeRequest
 */
export interface CreateProductTypeRequest {
    /**
     * 品目名(32文字まで)
     * @type {string}
     * @memberof CreateProductTypeRequest
     */
    'name': string;
    /**
     * アイコンURL
     * @type {string}
     * @memberof CreateProductTypeRequest
     */
    'iconUrl': string;
}
/**
 * 
 * @export
 * @interface CreatePromotionRequest
 */
export interface CreatePromotionRequest {
    /**
     * タイトル(200文字まで)
     * @type {string}
     * @memberof CreatePromotionRequest
     */
    'title': string;
    /**
     * 説明(2000文字まで)
     * @type {string}
     * @memberof CreatePromotionRequest
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof CreatePromotionRequest
     */
    'public': boolean;
    /**
     * 
     * @type {DiscountType}
     * @memberof CreatePromotionRequest
     */
    'discountType': DiscountType;
    /**
     * 割引額(単位:円/%,0以上)
     * @type {number}
     * @memberof CreatePromotionRequest
     */
    'discountRate': number;
    /**
     * クーポンコード(8文字,使用可能文字:半角英数字)
     * @type {string}
     * @memberof CreatePromotionRequest
     */
    'code': string;
    /**
     * クーポン利用可能開始日時(unixtime)
     * @type {number}
     * @memberof CreatePromotionRequest
     */
    'startAt': number;
    /**
     * クーポン利用可能終了日時(unixtime)
     * @type {number}
     * @memberof CreatePromotionRequest
     */
    'endAt': number;
}


/**
 * 
 * @export
 * @interface CreateScheduleRequest
 */
export interface CreateScheduleRequest {
    /**
     * コーディネーターID
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    'coordinatorId': string;
    /**
     * タイトル(128文字まで)
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    'title': string;
    /**
     * 説明(20000文字まで)
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    'description': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    'thumbnailUrl': string;
    /**
     * 蓋絵URL
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    'imageUrl': string;
    /**
     * オープニングURL
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    'openingVideoUrl': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof CreateScheduleRequest
     */
    'public': boolean;
    /**
     * マルシェ開始日時
     * @type {number}
     * @memberof CreateScheduleRequest
     */
    'startAt': number;
    /**
     * マルシェ終了日時
     * @type {number}
     * @memberof CreateScheduleRequest
     */
    'endAt': number;
}
/**
 * 
 * @export
 * @interface CreateThreadRequest
 */
export interface CreateThreadRequest {
    /**
     * お問い合わせID
     * @type {string}
     * @memberof CreateThreadRequest
     */
    'contactId': string;
    /**
     * 送信者ID
     * @type {string}
     * @memberof CreateThreadRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {ContactUserType}
     * @memberof CreateThreadRequest
     */
    'userType': ContactUserType;
    /**
     * 会話内容
     * @type {string}
     * @memberof CreateThreadRequest
     */
    'content': string;
}


/**
 * 
 * @export
 * @interface CreateVideoRequest
 */
export interface CreateVideoRequest {
    /**
     * タイトル(128文字まで)
     * @type {string}
     * @memberof CreateVideoRequest
     */
    'title': string;
    /**
     * 説明(20000文字まで)
     * @type {string}
     * @memberof CreateVideoRequest
     */
    'description': string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof CreateVideoRequest
     */
    'coordinatorId': string;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof CreateVideoRequest
     */
    'productIds': Array<string>;
    /**
     * 体験ID一覧
     * @type {Array<string>}
     * @memberof CreateVideoRequest
     */
    'experienceIds': Array<string>;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof CreateVideoRequest
     */
    'thumbnailUrl': string;
    /**
     * 動画URL
     * @type {string}
     * @memberof CreateVideoRequest
     */
    'videoUrl': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof CreateVideoRequest
     */
    'public': boolean;
    /**
     * 限定公開フラグ
     * @type {boolean}
     * @memberof CreateVideoRequest
     */
    'limited': boolean;
    /**
     * 公開日時 (unixtime)
     * @type {number}
     * @memberof CreateVideoRequest
     */
    'publishedAt': number;
}
/**
 * 
 * @export
 * @interface CreateYoutubeBroadcastRequest
 */
export interface CreateYoutubeBroadcastRequest {
    /**
     * YouTubeのタイトル(100文字まで)
     * @type {string}
     * @memberof CreateYoutubeBroadcastRequest
     */
    'title': string;
    /**
     * YouTubeの説明(1000文字まで)
     * @type {string}
     * @memberof CreateYoutubeBroadcastRequest
     */
    'description': string;
    /**
     * YouTubeの公開設定(true:公開,false:限定公開)
     * @type {boolean}
     * @memberof CreateYoutubeBroadcastRequest
     */
    'public': boolean;
}
/**
 * 配送方法
 * @export
 * @enum {string}
 */

export const DeliveryType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 常温便
    */
    NORMAL: 1,
    /**
    * 冷蔵便
    */
    REFRIGERATED: 2,
    /**
    * 冷凍便
    */
    FROZEN: 3
} as const;

export type DeliveryType = typeof DeliveryType[keyof typeof DeliveryType];


/**
 * 割引計算方法
 * @export
 * @enum {string}
 */

export const DiscountType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 固定額(円)
    */
    AMOUNT: 1,
    /**
    * 料率計算(%)
    */
    RATE: 2,
    /**
    * 送料無料
    */
    FREE_SHIPPING: 3
} as const;

export type DiscountType = typeof DiscountType[keyof typeof DiscountType];


/**
 * 
 * @export
 * @interface DraftOrderRequest
 */
export interface DraftOrderRequest {
    /**
     * 発送連絡時のメッセージ
     * @type {string}
     * @memberof DraftOrderRequest
     */
    'shippingMessage': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * ステータスコード
     * @type {number}
     * @memberof ErrorResponse
     */
    'status': number;
    /**
     * エラー概要
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * エラー詳細
     * @type {string}
     * @memberof ErrorResponse
     */
    'details': string;
}
/**
 * 体験情報
 * @export
 * @interface Experience
 */
export interface Experience {
    /**
     * 体験ID
     * @type {string}
     * @memberof Experience
     */
    'id': string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Experience
     */
    'coordinatorId': string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof Experience
     */
    'producerId': string;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof Experience
     */
    'experienceTypeId': string;
    /**
     * タイトル
     * @type {string}
     * @memberof Experience
     */
    'title': string;
    /**
     * 説明
     * @type {string}
     * @memberof Experience
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Experience
     */
    'public': boolean;
    /**
     * 完売フラグ
     * @type {boolean}
     * @memberof Experience
     */
    'soldOut': boolean;
    /**
     * 
     * @type {ExperienceStatus}
     * @memberof Experience
     */
    'status': ExperienceStatus;
    /**
     * 
     * @type {Array<ExperienceMediaInner>}
     * @memberof Experience
     */
    'media': Array<ExperienceMediaInner>;
    /**
     * 大人販売価格（税込）
     * @type {number}
     * @memberof Experience
     */
    'priceAdult': number;
    /**
     * 中学生販売価格（税込）
     * @type {number}
     * @memberof Experience
     */
    'priceJuniorHighSchool': number;
    /**
     * 小学生販売価格（税込）
     * @type {number}
     * @memberof Experience
     */
    'priceElementarySchool': number;
    /**
     * 幼児販売価格（税込）
     * @type {number}
     * @memberof Experience
     */
    'pricePreschooler': number;
    /**
     * シニア販売価格（税込）
     * @type {number}
     * @memberof Experience
     */
    'priceSenior': number;
    /**
     * おすすめポイント1
     * @type {string}
     * @memberof Experience
     */
    'recommendedPoint1'?: string;
    /**
     * おすすめポイント2
     * @type {string}
     * @memberof Experience
     */
    'recommendedPoint2'?: string;
    /**
     * おすすめポイント3
     * @type {string}
     * @memberof Experience
     */
    'recommendedPoint3'?: string;
    /**
     * 
     * @type {Prefecture}
     * @memberof Experience
     */
    'hostPrefectureCode': Prefecture;
    /**
     * 開催地（市区町村）
     * @type {string}
     * @memberof Experience
     */
    'hostCity': string;
    /**
     * 販売開始日時 (unixtime)
     * @type {number}
     * @memberof Experience
     */
    'startAt': number;
    /**
     * 販売終了日時 (unixtime)
     * @type {number}
     * @memberof Experience
     */
    'endAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Experience
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Experience
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface ExperienceMediaInner
 */
export interface ExperienceMediaInner {
    /**
     * メディアURL
     * @type {string}
     * @memberof ExperienceMediaInner
     */
    'url': string;
    /**
     * サムネイルとして使用（1つまで）
     * @type {boolean}
     * @memberof ExperienceMediaInner
     */
    'isThumbnail': boolean;
}
/**
 * 
 * @export
 * @interface ExperienceResponse
 */
export interface ExperienceResponse {
    /**
     * 
     * @type {Experience}
     * @memberof ExperienceResponse
     */
    'experience': Experience;
    /**
     * 
     * @type {Coordinator}
     * @memberof ExperienceResponse
     */
    'coordinator': Coordinator;
    /**
     * 
     * @type {Producer}
     * @memberof ExperienceResponse
     */
    'producer': Producer;
    /**
     * 
     * @type {ExperienceType}
     * @memberof ExperienceResponse
     */
    'experienceType': ExperienceType;
}
/**
 * 商品販売ステータス
 * @export
 * @enum {string}
 */

export const ExperienceStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 非公開
    */
    PRIVATE: 1,
    /**
    * 公開前
    */
    WAITING: 2,
    /**
    * 受付中
    */
    ACCEPTING: 3,
    /**
    * 定員オーバー
    */
    SOLD_OUT: 4,
    /**
    * 販売終了
    */
    FINISHED: 5
} as const;

export type ExperienceStatus = typeof ExperienceStatus[keyof typeof ExperienceStatus];


/**
 * 体験種別情報
 * @export
 * @interface ExperienceType
 */
export interface ExperienceType {
    /**
     * 体験種別ID
     * @type {string}
     * @memberof ExperienceType
     */
    'id': string;
    /**
     * 体験種別名
     * @type {string}
     * @memberof ExperienceType
     */
    'name': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof ExperienceType
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof ExperienceType
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface ExperienceTypeResponse
 */
export interface ExperienceTypeResponse {
    /**
     * 
     * @type {ExperienceType}
     * @memberof ExperienceTypeResponse
     */
    'experienceType': ExperienceType;
}
/**
 * 
 * @export
 * @interface ExperienceTypesResponse
 */
export interface ExperienceTypesResponse {
    /**
     * 体験種別一覧
     * @type {Array<ExperienceType>}
     * @memberof ExperienceTypesResponse
     */
    'experienceTypes': Array<ExperienceType>;
    /**
     * 合計数
     * @type {number}
     * @memberof ExperienceTypesResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ExportOrdersRequest
 */
export interface ExportOrdersRequest {
    /**
     * 
     * @type {ShippingCarrier}
     * @memberof ExportOrdersRequest
     */
    'shippingCarrier': ShippingCarrier;
    /**
     * 
     * @type {CharacterEncodingType}
     * @memberof ExportOrdersRequest
     */
    'characterEncodingType': CharacterEncodingType;
}


/**
 * 
 * @export
 * @interface ForgotAuthPasswordRequest
 */
export interface ForgotAuthPasswordRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof ForgotAuthPasswordRequest
     */
    'email': string;
}
/**
 * 配送状況
 * @export
 * @enum {string}
 */

export const FulfillmentStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 未発送
    */
    UNFULFILLED: 1,
    /**
    * 発送済み
    */
    FULFILLED: 2
} as const;

export type FulfillmentStatus = typeof FulfillmentStatus[keyof typeof FulfillmentStatus];


/**
 * 
 * @export
 * @interface GetUploadUrlRequest
 */
export interface GetUploadUrlRequest {
    /**
     * MIMEタイプ
     * @type {string}
     * @memberof GetUploadUrlRequest
     */
    'fileType': string;
}
/**
 * ゲスト用マルシェライブ配信情報
 * @export
 * @interface GuestBroadcast
 */
export interface GuestBroadcast {
    /**
     * タイトル
     * @type {string}
     * @memberof GuestBroadcast
     */
    'title': string;
    /**
     * 説明
     * @type {string}
     * @memberof GuestBroadcast
     */
    'description': string;
    /**
     * ライブ開始日時 (unixtime)
     * @type {number}
     * @memberof GuestBroadcast
     */
    'startAt': number;
    /**
     * ライブ終了日時 (unixtime)
     * @type {number}
     * @memberof GuestBroadcast
     */
    'endAt': number;
    /**
     * 配信担当者のマルシェ名
     * @type {string}
     * @memberof GuestBroadcast
     */
    'coordinatorMarche': string;
    /**
     * 配信担当者の名前
     * @type {string}
     * @memberof GuestBroadcast
     */
    'coordinatorName': string;
}
/**
 * 
 * @export
 * @interface GuestBroadcastResponse
 */
export interface GuestBroadcastResponse {
    /**
     * 
     * @type {GuestBroadcast}
     * @memberof GuestBroadcastResponse
     */
    'broadcast': GuestBroadcast;
}
/**
 * マルシェタイムテーブル情報
 * @export
 * @interface Live
 */
export interface Live {
    /**
     * ライブID
     * @type {string}
     * @memberof Live
     */
    'id': string;
    /**
     * マルシェ開催スケジュールID
     * @type {string}
     * @memberof Live
     */
    'scheduleId': string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof Live
     */
    'producerId': string;
    /**
     * 商品一覧
     * @type {Array<string>}
     * @memberof Live
     */
    'productIds': Array<string>;
    /**
     * コメント
     * @type {string}
     * @memberof Live
     */
    'comment': string;
    /**
     * ライブ開始予定日時 (unixtime)
     * @type {number}
     * @memberof Live
     */
    'startAt': number;
    /**
     * ライブ終了予定日時 (unixtime)
     * @type {number}
     * @memberof Live
     */
    'endAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Live
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Live
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface LiveComment
 */
export interface LiveComment {
    /**
     * コメントID
     * @type {string}
     * @memberof LiveComment
     */
    'id': string;
    /**
     * ユーザーID
     * @type {string}
     * @memberof LiveComment
     */
    'userId': string;
    /**
     * ユーザー名
     * @type {string}
     * @memberof LiveComment
     */
    'username': string;
    /**
     * アカウントID
     * @type {string}
     * @memberof LiveComment
     */
    'accountId': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof LiveComment
     */
    'thumbnailUrl': string;
    /**
     * コメント
     * @type {string}
     * @memberof LiveComment
     */
    'comment': string;
    /**
     * コメント無効化フラグ
     * @type {boolean}
     * @memberof LiveComment
     */
    'disabled': boolean;
    /**
     * 投稿日時
     * @type {number}
     * @memberof LiveComment
     */
    'publishedAt': number;
}
/**
 * 
 * @export
 * @interface LiveCommentsResponse
 */
export interface LiveCommentsResponse {
    /**
     * コメント一覧
     * @type {Array<LiveComment>}
     * @memberof LiveCommentsResponse
     */
    'comments': Array<LiveComment>;
    /**
     * 次の取得位置
     * @type {string}
     * @memberof LiveCommentsResponse
     */
    'nextToken': string;
}
/**
 * 
 * @export
 * @interface LiveResponse
 */
export interface LiveResponse {
    /**
     * 
     * @type {Live}
     * @memberof LiveResponse
     */
    'live': Live;
    /**
     * 
     * @type {Producer}
     * @memberof LiveResponse
     */
    'producer': Producer;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof LiveResponse
     */
    'products': Array<Product>;
}
/**
 * 
 * @export
 * @interface LivesResponse
 */
export interface LivesResponse {
    /**
     * マルシェタイムテーブル一覧
     * @type {Array<Live>}
     * @memberof LivesResponse
     */
    'lives': Array<Live>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof LivesResponse
     */
    'producers': Array<Producer>;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof LivesResponse
     */
    'products': Array<Product>;
    /**
     * 合計数
     * @type {number}
     * @memberof LivesResponse
     */
    'total': number;
}
/**
 * メッセージ情報
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * メッセージID
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {MessageType}
     * @memberof Message
     */
    'type': MessageType;
    /**
     * メッセージ件名
     * @type {string}
     * @memberof Message
     */
    'title': string;
    /**
     * メッセージ内容
     * @type {string}
     * @memberof Message
     */
    'body': string;
    /**
     * 遷移先リンク
     * @type {string}
     * @memberof Message
     */
    'link': string;
    /**
     * 既読フラグ
     * @type {boolean}
     * @memberof Message
     */
    'read': boolean;
    /**
     * 受信日時 (unixtime)
     * @type {number}
     * @memberof Message
     */
    'receivedAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Message
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Message
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 
     * @type {Message}
     * @memberof MessageResponse
     */
    'message': Message;
}
/**
 * メッセージ種別
 * @export
 * @enum {string}
 */

export const MessageType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * お知らせ
    */
    NOTIFICATION: 1
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];


/**
 * 
 * @export
 * @interface MessagesResponse
 */
export interface MessagesResponse {
    /**
     * メッセージ一覧
     * @type {Array<Message>}
     * @memberof MessagesResponse
     */
    'messages': Array<Message>;
    /**
     * 合計数
     * @type {number}
     * @memberof MessagesResponse
     */
    'total': number;
}
/**
 * お知らせ情報
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * お知らせID
     * @type {string}
     * @memberof Notification
     */
    'id': string;
    /**
     * 
     * @type {NotificationStatus}
     * @memberof Notification
     */
    'status': NotificationStatus;
    /**
     * 
     * @type {NotificationType}
     * @memberof Notification
     */
    'type': NotificationType;
    /**
     * 通知対象一覧
     * @type {Array<NotificationTarget>}
     * @memberof Notification
     */
    'targets': Array<NotificationTarget>;
    /**
     * タイトル
     * @type {string}
     * @memberof Notification
     */
    'title': string;
    /**
     * 本文
     * @type {string}
     * @memberof Notification
     */
    'body': string;
    /**
     * 備考
     * @type {string}
     * @memberof Notification
     */
    'note': string;
    /**
     * 掲載日時 (unixtime)
     * @type {number}
     * @memberof Notification
     */
    'publishedAt': number;
    /**
     * プロモーションID
     * @type {string}
     * @memberof Notification
     */
    'promotionId': string;
    /**
     * 登録者ID
     * @type {string}
     * @memberof Notification
     */
    'createdBy': string;
    /**
     * 更新者ID
     * @type {string}
     * @memberof Notification
     */
    'updatedBy': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Notification
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Notification
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface NotificationResponse
 */
export interface NotificationResponse {
    /**
     * 
     * @type {Notification}
     * @memberof NotificationResponse
     */
    'notification': Notification;
    /**
     * 
     * @type {Admin}
     * @memberof NotificationResponse
     */
    'admin': Admin;
}
/**
 * お知らせ状態
 * @export
 * @enum {string}
 */

export const NotificationStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 通知前
    */
    WAITING: 1,
    /**
    * 通知済み
    */
    NOTIFIED: 2
} as const;

export type NotificationStatus = typeof NotificationStatus[keyof typeof NotificationStatus];


/**
 * 通知対象種別
 * @export
 * @enum {string}
 */

export const NotificationTarget = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 購入者
    */
    USERS: 1,
    /**
    * 生産者
    */
    PRODUCERS: 2,
    /**
    * コーディネータ
    */
    COORDINATORS: 3,
    /**
    * 管理者
    */
    ADMINISTRATORS: 4
} as const;

export type NotificationTarget = typeof NotificationTarget[keyof typeof NotificationTarget];


/**
 * お知らせ種別
 * @export
 * @enum {string}
 */

export const NotificationType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * その他
    */
    OTHER: 1,
    /**
    * システム関連
    */
    SYSTEM: 2,
    /**
    * ライブ関連
    */
    LIVE: 3,
    /**
    * セール関連
    */
    PROMOTION: 4
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * 
 * @export
 * @interface NotificationsResponse
 */
export interface NotificationsResponse {
    /**
     * お知らせ一覧
     * @type {Array<Notification>}
     * @memberof NotificationsResponse
     */
    'notifications': Array<Notification>;
    /**
     * 作成者一覧
     * @type {Array<Admin>}
     * @memberof NotificationsResponse
     */
    'admins': Array<Admin>;
    /**
     * 合計数
     * @type {number}
     * @memberof NotificationsResponse
     */
    'total': number;
}
/**
 * 注文履歴情報
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 注文履歴ID
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 購入者ID
     * @type {string}
     * @memberof Order
     */
    'userId': string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Order
     */
    'coordinatorId': string;
    /**
     * プロモーションID
     * @type {string}
     * @memberof Order
     */
    'promotionId': string;
    /**
     * 注文管理用ID
     * @type {number}
     * @memberof Order
     */
    'managementId': number;
    /**
     * 発送連絡時のメッセージ
     * @type {string}
     * @memberof Order
     */
    'shippingMessage': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    'status': OrderStatus;
    /**
     * 
     * @type {OrderPayment}
     * @memberof Order
     */
    'payment': OrderPayment;
    /**
     * 
     * @type {OrderRefund}
     * @memberof Order
     */
    'refund': OrderRefund;
    /**
     * 注文配送一覧
     * @type {Array<OrderFulfillment>}
     * @memberof Order
     */
    'fulfillments': Array<OrderFulfillment>;
    /**
     * 注文商品一覧
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    'items': Array<OrderItem>;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Order
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Order
     */
    'updatedAt': number;
    /**
     * 完了日時 (unixtime)
     * @type {number}
     * @memberof Order
     */
    'completedAt': number;
}


/**
 * 注文配送情報
 * @export
 * @interface OrderFulfillment
 */
export interface OrderFulfillment {
    /**
     * 注文配送ID
     * @type {string}
     * @memberof OrderFulfillment
     */
    'fulfillmentId': string;
    /**
     * 伝票番号
     * @type {string}
     * @memberof OrderFulfillment
     */
    'trackingNumber': string;
    /**
     * 
     * @type {FulfillmentStatus}
     * @memberof OrderFulfillment
     */
    'status': FulfillmentStatus;
    /**
     * 
     * @type {ShippingCarrier}
     * @memberof OrderFulfillment
     */
    'shippingCarrier': ShippingCarrier;
    /**
     * 
     * @type {ShippingType}
     * @memberof OrderFulfillment
     */
    'shippingType': ShippingType;
    /**
     * 箱の通番
     * @type {number}
     * @memberof OrderFulfillment
     */
    'boxNumber': number;
    /**
     * 
     * @type {ShippingSize}
     * @memberof OrderFulfillment
     */
    'boxSize': ShippingSize;
    /**
     * 箱の占有率
     * @type {number}
     * @memberof OrderFulfillment
     */
    'boxRate': number;
    /**
     * 配送日時（unixtime）
     * @type {number}
     * @memberof OrderFulfillment
     */
    'shippedAt': number;
    /**
     * 配送先 住所ID
     * @type {string}
     * @memberof OrderFulfillment
     */
    'addressId': string;
    /**
     * 配送先 氏名（姓）
     * @type {string}
     * @memberof OrderFulfillment
     */
    'lastname': string;
    /**
     * 配送先 氏名（名）
     * @type {string}
     * @memberof OrderFulfillment
     */
    'firstname': string;
    /**
     * 配送先 郵便番号
     * @type {string}
     * @memberof OrderFulfillment
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof OrderFulfillment
     */
    'prefectureCode': Prefecture;
    /**
     * 配送先 市区町村
     * @type {string}
     * @memberof OrderFulfillment
     */
    'city': string;
    /**
     * 配送先 町名・番地
     * @type {string}
     * @memberof OrderFulfillment
     */
    'addressLine1': string;
    /**
     * 配送先 ビル名・号室など
     * @type {string}
     * @memberof OrderFulfillment
     */
    'addressLine2': string;
    /**
     * 配送先 電話番号
     * @type {string}
     * @memberof OrderFulfillment
     */
    'phoneNumber': string;
}


/**
 * 注文商品情報
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 注文配送ID
     * @type {string}
     * @memberof OrderItem
     */
    'fulfillmentId': string;
    /**
     * 商品ID
     * @type {string}
     * @memberof OrderItem
     */
    'productId': string;
    /**
     * 購入価格（税込）
     * @type {number}
     * @memberof OrderItem
     */
    'price': number;
    /**
     * 購入数量
     * @type {number}
     * @memberof OrderItem
     */
    'quantity': number;
}
/**
 * 注文決済情報
 * @export
 * @interface OrderPayment
 */
export interface OrderPayment {
    /**
     * 取引ID
     * @type {string}
     * @memberof OrderPayment
     */
    'transactionId': string;
    /**
     * 
     * @type {PaymentMethodType}
     * @memberof OrderPayment
     */
    'methodType': PaymentMethodType;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof OrderPayment
     */
    'status': PaymentStatus;
    /**
     * 購入金額（税込）
     * @type {number}
     * @memberof OrderPayment
     */
    'subtotal': number;
    /**
     * 割引金額（税込）
     * @type {number}
     * @memberof OrderPayment
     */
    'discount': number;
    /**
     * 配送手数料（税込）
     * @type {number}
     * @memberof OrderPayment
     */
    'shippingFee': number;
    /**
     * 合計金額（税込）
     * @type {number}
     * @memberof OrderPayment
     */
    'total': number;
    /**
     * 注文日時（unixtime）
     * @type {number}
     * @memberof OrderPayment
     */
    'orderedAt': number;
    /**
     * 支払日時（unixtime）
     * @type {number}
     * @memberof OrderPayment
     */
    'paidAt': number;
    /**
     * 請求先 住所ID
     * @type {string}
     * @memberof OrderPayment
     */
    'addressId': string;
    /**
     * 請求先 氏名（姓）
     * @type {string}
     * @memberof OrderPayment
     */
    'lastname': string;
    /**
     * 請求先 氏名（名）
     * @type {string}
     * @memberof OrderPayment
     */
    'firstname': string;
    /**
     * 請求先 郵便番号
     * @type {string}
     * @memberof OrderPayment
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof OrderPayment
     */
    'prefectureCode': Prefecture;
    /**
     * 請求先 市区町村
     * @type {string}
     * @memberof OrderPayment
     */
    'city': string;
    /**
     * 請求先 町名・番地
     * @type {string}
     * @memberof OrderPayment
     */
    'addressLine1': string;
    /**
     * 請求先 ビル名・号室など
     * @type {string}
     * @memberof OrderPayment
     */
    'addressLine2': string;
    /**
     * 請求先 電話番号
     * @type {string}
     * @memberof OrderPayment
     */
    'phoneNumber': string;
}


/**
 * 注文キャンセル情報
 * @export
 * @interface OrderRefund
 */
export interface OrderRefund {
    /**
     * 返金金額
     * @type {number}
     * @memberof OrderRefund
     */
    'total': number;
    /**
     * 
     * @type {OrderRefundType}
     * @memberof OrderRefund
     */
    'type': OrderRefundType;
    /**
     * 注文キャンセル理由
     * @type {string}
     * @memberof OrderRefund
     */
    'reason': string;
    /**
     * 注文キャンセルフラグ
     * @type {boolean}
     * @memberof OrderRefund
     */
    'canceled': boolean;
    /**
     * 注文キャンセル日時（unixtime）
     * @type {number}
     * @memberof OrderRefund
     */
    'canceledAt': number;
}


/**
 * 注文キャンセル理由
 * @export
 * @enum {string}
 */

export const OrderRefundType = {
    /**
    * 未キャンセル
    */
    NONE: 0,
    /**
    * キャンセル済み
    */
    CANCELED: 1,
    /**
    * 返金済み
    */
    REFUNDED: 2
} as const;

export type OrderRefundType = typeof OrderRefundType[keyof typeof OrderRefundType];


/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {Order}
     * @memberof OrderResponse
     */
    'order': Order;
    /**
     * 
     * @type {User}
     * @memberof OrderResponse
     */
    'user': User;
    /**
     * 
     * @type {Coordinator}
     * @memberof OrderResponse
     */
    'coordinator': Coordinator;
    /**
     * 
     * @type {Promotion}
     * @memberof OrderResponse
     */
    'promotion': Promotion;
    /**
     * 
     * @type {Array<Product>}
     * @memberof OrderResponse
     */
    'products': Array<Product>;
}
/**
 * 注文ステータス
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 支払い待ち
    */
    UNPAID: 1,
    /**
    * 受注待ち
    */
    WAITING: 2,
    /**
    * 発送準備中
    */
    PREPARING: 3,
    /**
    * 発送完了
    */
    SHIPPED: 4,
    /**
    * 完了
    */
    COMPLETED: 5,
    /**
    * キャンセル
    */
    CANCELED: 6,
    /**
    * 返金
    */
    REFUNDED: 7,
    /**
    * 失敗
    */
    FAILED: 8
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * 
 * @export
 * @interface OrdersResponse
 */
export interface OrdersResponse {
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrdersResponse
     */
    'orders': Array<Order>;
    /**
     * 
     * @type {Array<User>}
     * @memberof OrdersResponse
     */
    'users': Array<User>;
    /**
     * 
     * @type {Array<Coordinator>}
     * @memberof OrdersResponse
     */
    'coordinators': Array<Coordinator>;
    /**
     * 
     * @type {Array<Promotion>}
     * @memberof OrdersResponse
     */
    'promotions': Array<Promotion>;
    /**
     * 合計数
     * @type {number}
     * @memberof OrdersResponse
     */
    'total': number;
}
/**
 * 決済手段
 * @export
 * @enum {string}
 */

export const PaymentMethodType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 代引支払い
    */
    CASH: 1,
    /**
    * クレジットカード決済
    */
    CREDIT_CARD: 2,
    /**
    * コンビニ決済
    */
    KONBINI: 3,
    /**
    * 銀行振込決済
    */
    BANK_TRANSFER: 4,
    /**
    * QR決済（PayPay）
    */
    PAYPAY: 5,
    /**
    * QR決済（Line Pay）
    */
    LINE_PAY: 6,
    /**
    * QR決済（メルペイ）
    */
    MERPAY: 7,
    /**
    * QR決済（楽天ペイ）
    */
    RAKUTEN_PAY: 8,
    /**
    * QR決済（au PAY）
    */
    AU_PAY: 9
} as const;

export type PaymentMethodType = typeof PaymentMethodType[keyof typeof PaymentMethodType];


/**
 * 支払い状況
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 未払い
    */
    UNPAID: 1,
    /**
    * オーソリ済み
    */
    AUTHORIZED: 2,
    /**
    * 支払い済み
    */
    PAID: 3,
    /**
    * キャンセル済み
    */
    CANCELED: 4,
    /**
    * 失敗
    */
    FAILED: 5
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 決済システム情報
 * @export
 * @interface PaymentSystem
 */
export interface PaymentSystem {
    /**
     * 
     * @type {PaymentMethodType}
     * @memberof PaymentSystem
     */
    'methodType': PaymentMethodType;
    /**
     * 
     * @type {PaymentSystemStatus}
     * @memberof PaymentSystem
     */
    'status': PaymentSystemStatus;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof PaymentSystem
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof PaymentSystem
     */
    'updatedAt': number;
}


/**
 * 決済システム状態
 * @export
 * @enum {string}
 */

export const PaymentSystemStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 利用可能
    */
    IN_USE: 1,
    /**
    * 停止中
    */
    OUTAGE: 2
} as const;

export type PaymentSystemStatus = typeof PaymentSystemStatus[keyof typeof PaymentSystemStatus];


/**
 * 
 * @export
 * @interface PaymentSystemsResponse
 */
export interface PaymentSystemsResponse {
    /**
     * 決済システム状態一覧
     * @type {Array<PaymentSystem>}
     * @memberof PaymentSystemsResponse
     */
    'systems': Array<PaymentSystem>;
}
/**
 * 
 * @export
 * @interface PostalCodeResponse
 */
export interface PostalCodeResponse {
    /**
     * 郵便番号
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof PostalCodeResponse
     */
    'prefectureCode': Prefecture;
    /**
     * 都道府県名
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'prefecture': string;
    /**
     * 市区町村名
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'city': string;
    /**
     * 町域名
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'town': string;
}


/**
 * 都道府県コード
 * @export
 * @enum {string}
 */

export const Prefecture = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 北海道
    */
    HOKKAIDO: 1,
    /**
    * 青森県
    */
    AOMORI: 2,
    /**
    * 岩手県
    */
    IWATE: 3,
    /**
    * 宮城県
    */
    MIYAGI: 4,
    /**
    * 秋田県
    */
    AKITA: 5,
    /**
    * 山形県
    */
    YAMAGATA: 6,
    /**
    * 福島県
    */
    FUKUSHIMA: 7,
    /**
    * 茨城県
    */
    IBARAKI: 8,
    /**
    * 栃木県
    */
    TOCHIGI: 9,
    /**
    * 群馬県
    */
    GUNMA: 10,
    /**
    * 埼玉県
    */
    SAITAMA: 11,
    /**
    * 千葉県
    */
    CHIBA: 12,
    /**
    * 東京都
    */
    TOKYO: 13,
    /**
    * 神奈川県
    */
    KANAGAWA: 14,
    /**
    * 新潟県
    */
    NIIGATA: 15,
    /**
    * 富山県
    */
    TOYAMA: 16,
    /**
    * 石川県
    */
    ISHIKAWA: 17,
    /**
    * 福井県
    */
    FUKUI: 18,
    /**
    * 山梨県
    */
    YAMANASHI: 19,
    /**
    * 長野県
    */
    NAGANO: 20,
    /**
    * 岐阜県
    */
    GIFU: 21,
    /**
    * 静岡県
    */
    SHIZUOKA: 22,
    /**
    * 愛知県
    */
    AICHI: 23,
    /**
    * 三重県
    */
    MIE: 24,
    /**
    * 滋賀県
    */
    SHIGA: 25,
    /**
    * 京都府
    */
    KYOTO: 26,
    /**
    * 大坂府
    */
    OSAKA: 27,
    /**
    * 兵庫県
    */
    HYOGO: 28,
    /**
    * 奈良県
    */
    NARA: 29,
    /**
    * 和歌山県
    */
    WAKAYAMA: 30,
    /**
    * 鳥取県
    */
    TOTTORI: 31,
    /**
    * 島根県
    */
    SHIMANE: 32,
    /**
    * 岡山県
    */
    OKAYAMA: 33,
    /**
    * 広島県
    */
    HIROSHIMA: 34,
    /**
    * 山口県
    */
    YAMAGUCHI: 35,
    /**
    * 徳島県
    */
    TOKUSHIMA: 36,
    /**
    * 香川県
    */
    KAGAWA: 37,
    /**
    * 愛媛県
    */
    EHIME: 38,
    /**
    * 高知県
    */
    KOCHI: 39,
    /**
    * 福岡県
    */
    FUKUOKA: 40,
    /**
    * 佐賀県
    */
    SAGA: 41,
    /**
    * 長崎県
    */
    NAGASAKI: 42,
    /**
    * 熊本県
    */
    KUMAMOTO: 43,
    /**
    * 大分県
    */
    OITA: 44,
    /**
    * 宮崎県
    */
    MIYAZAKI: 45,
    /**
    * 鹿児島県
    */
    KAGOSHIMA: 46,
    /**
    * 沖縄県
    */
    OKINAWA: 47
} as const;

export type Prefecture = typeof Prefecture[keyof typeof Prefecture];


/**
 * 生産者情報
 * @export
 * @interface Producer
 */
export interface Producer {
    /**
     * 生産者ID
     * @type {string}
     * @memberof Producer
     */
    'id': string;
    /**
     * 
     * @type {AdminStatus}
     * @memberof Producer
     */
    'status': AdminStatus;
    /**
     * 担当コーディネータID
     * @type {string}
     * @memberof Producer
     */
    'coordinatorId': string;
    /**
     * 姓
     * @type {string}
     * @memberof Producer
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof Producer
     */
    'firstname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof Producer
     */
    'lastnameKana': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof Producer
     */
    'firstnameKana': string;
    /**
     * 生産者名
     * @type {string}
     * @memberof Producer
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Producer
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof Producer
     */
    'phoneNumber': string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof Producer
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof Producer
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村
     * @type {string}
     * @memberof Producer
     */
    'city': string;
    /**
     * 町名・番地
     * @type {string}
     * @memberof Producer
     */
    'addressLine1': string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof Producer
     */
    'addressLine2': string;
    /**
     * プロフィール
     * @type {string}
     * @memberof Producer
     */
    'profile': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Producer
     */
    'thumbnailUrl': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof Producer
     */
    'headerUrl': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof Producer
     */
    'promotionVideoUrl': string;
    /**
     * 購入特典動画URL
     * @type {string}
     * @memberof Producer
     */
    'bonusVideoUrl': string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof Producer
     */
    'instagramId': string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof Producer
     */
    'facebookId': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Producer
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Producer
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface ProducerResponse
 */
export interface ProducerResponse {
    /**
     * 
     * @type {Producer}
     * @memberof ProducerResponse
     */
    'producer': Producer;
    /**
     * 
     * @type {Coordinator}
     * @memberof ProducerResponse
     */
    'coordinator': Coordinator;
}
/**
 * 
 * @export
 * @interface ProducersResponse
 */
export interface ProducersResponse {
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof ProducersResponse
     */
    'producers': Array<Producer>;
    /**
     * 担当コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof ProducersResponse
     */
    'coordinators': Array<Coordinator>;
    /**
     * 合計数
     * @type {number}
     * @memberof ProducersResponse
     */
    'total': number;
}
/**
 * 商品情報
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 商品ID
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 商品名
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 商品説明
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Product
     */
    'public': boolean;
    /**
     * 
     * @type {ProductStatus}
     * @memberof Product
     */
    'status': ProductStatus;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Product
     */
    'coordinatorId': string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof Product
     */
    'producerId': string;
    /**
     * 商品種別ID
     * @type {string}
     * @memberof Product
     */
    'categoryId': string;
    /**
     * 品目ID
     * @type {string}
     * @memberof Product
     */
    'productTypeId': string;
    /**
     * 商品タグ一覧
     * @type {Array<string>}
     * @memberof Product
     */
    'productTagIds': Array<string>;
    /**
     * 
     * @type {Array<ProductMediaInner>}
     * @memberof Product
     */
    'media': Array<ProductMediaInner>;
    /**
     * 販売価格（税込）
     * @type {number}
     * @memberof Product
     */
    'price': number;
    /**
     * 原価（税込）
     * @type {number}
     * @memberof Product
     */
    'cost': number;
    /**
     * 在庫数
     * @type {number}
     * @memberof Product
     */
    'inventory': number;
    /**
     * 重量(kg:少数第1位まで)
     * @type {number}
     * @memberof Product
     */
    'weight': number;
    /**
     * 数量単位
     * @type {string}
     * @memberof Product
     */
    'itemUnit': string;
    /**
     * 数量単位説明
     * @type {string}
     * @memberof Product
     */
    'itemDescription': string;
    /**
     * 
     * @type {DeliveryType}
     * @memberof Product
     */
    'deliveryType': DeliveryType;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof Product
     */
    'recommendedPoint1': string;
    /**
     * おすすめポイント2(128文字まで)
     * @type {string}
     * @memberof Product
     */
    'recommendedPoint2': string;
    /**
     * おすすめポイント3(128文字まで)
     * @type {string}
     * @memberof Product
     */
    'recommendedPoint3': string;
    /**
     * 賞味期限(単位:日)
     * @type {number}
     * @memberof Product
     */
    'expirationDate': number;
    /**
     * 
     * @type {StorageMethodType}
     * @memberof Product
     */
    'storageMethodType': StorageMethodType;
    /**
     * 箱の占有率(サイズ:60)
     * @type {number}
     * @memberof Product
     */
    'box60Rate': number;
    /**
     * 箱の占有率(サイズ:80)
     * @type {number}
     * @memberof Product
     */
    'box80Rate': number;
    /**
     * 箱の占有率(サイズ:100)
     * @type {number}
     * @memberof Product
     */
    'box100Rate': number;
    /**
     * 
     * @type {Prefecture}
     * @memberof Product
     */
    'originPrefectureCode': Prefecture;
    /**
     * 原産地(市区町村)
     * @type {string}
     * @memberof Product
     */
    'originCity': string;
    /**
     * 販売開始日時 (unixtime)
     * @type {number}
     * @memberof Product
     */
    'startAt': number;
    /**
     * 販売終了日時 (unixtime)
     * @type {number}
     * @memberof Product
     */
    'endAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Product
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Product
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface ProductMediaInner
 */
export interface ProductMediaInner {
    /**
     * メディアURL
     * @type {string}
     * @memberof ProductMediaInner
     */
    'url': string;
    /**
     * サムネイルとして使用(1つまで)
     * @type {boolean}
     * @memberof ProductMediaInner
     */
    'isThumbnail': boolean;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * 
     * @type {Product}
     * @memberof ProductResponse
     */
    'product': Product;
    /**
     * 
     * @type {Coordinator}
     * @memberof ProductResponse
     */
    'coordinator': Coordinator;
    /**
     * 
     * @type {Producer}
     * @memberof ProductResponse
     */
    'producer': Producer;
    /**
     * 
     * @type {Category}
     * @memberof ProductResponse
     */
    'category': Category;
    /**
     * 
     * @type {ProductType}
     * @memberof ProductResponse
     */
    'productType': ProductType;
    /**
     * 商品タグ一覧
     * @type {Array<ProductTag>}
     * @memberof ProductResponse
     */
    'productTags': Array<ProductTag>;
}
/**
 * 商品販売ステータス
 * @export
 * @enum {string}
 */

export const ProductStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 非公開
    */
    PRIVATE: 1,
    /**
    * 予約受付中
    */
    PRESALE: 2,
    /**
    * 販売中
    */
    FOR_SALE: 3,
    /**
    * 販売期間外
    */
    OUT_OF_SALES: 4,
    /**
    * アーカイブ済み
    */
    ARCHIVED: 5
} as const;

export type ProductStatus = typeof ProductStatus[keyof typeof ProductStatus];


/**
 * 商品タグ情報
 * @export
 * @interface ProductTag
 */
export interface ProductTag {
    /**
     * 商品タグID
     * @type {string}
     * @memberof ProductTag
     */
    'id': string;
    /**
     * 商品タグ名(32文字まで)
     * @type {string}
     * @memberof ProductTag
     */
    'name': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof ProductTag
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof ProductTag
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface ProductTagResponse
 */
export interface ProductTagResponse {
    /**
     * 
     * @type {ProductTag}
     * @memberof ProductTagResponse
     */
    'productTag': ProductTag;
}
/**
 * 
 * @export
 * @interface ProductTagsResponse
 */
export interface ProductTagsResponse {
    /**
     * 品目一覧
     * @type {Array<ProductTag>}
     * @memberof ProductTagsResponse
     */
    'productTags': Array<ProductTag>;
    /**
     * 合計数
     * @type {number}
     * @memberof ProductTagsResponse
     */
    'total': number;
}
/**
 * 品目情報
 * @export
 * @interface ProductType
 */
export interface ProductType {
    /**
     * 品目ID
     * @type {string}
     * @memberof ProductType
     */
    'id': string;
    /**
     * 品目名
     * @type {string}
     * @memberof ProductType
     */
    'name': string;
    /**
     * アイコンURL
     * @type {string}
     * @memberof ProductType
     */
    'iconUrl': string;
    /**
     * 商品種別ID
     * @type {string}
     * @memberof ProductType
     */
    'categoryId': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof ProductType
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof ProductType
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface ProductTypeResponse
 */
export interface ProductTypeResponse {
    /**
     * 
     * @type {ProductType}
     * @memberof ProductTypeResponse
     */
    'productType': ProductType;
    /**
     * 
     * @type {Category}
     * @memberof ProductTypeResponse
     */
    'category': Category;
}
/**
 * 
 * @export
 * @interface ProductTypesResponse
 */
export interface ProductTypesResponse {
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof ProductTypesResponse
     */
    'productTypes': Array<ProductType>;
    /**
     * 商品種別一覧
     * @type {Array<Category>}
     * @memberof ProductTypesResponse
     */
    'categories': Array<Category>;
    /**
     * 合計数
     * @type {number}
     * @memberof ProductTypesResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ProductsResponse
 */
export interface ProductsResponse {
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof ProductsResponse
     */
    'products': Array<Product>;
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof ProductsResponse
     */
    'coordinators': Array<Coordinator>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof ProductsResponse
     */
    'producers': Array<Producer>;
    /**
     * 商品種別一覧
     * @type {Array<Category>}
     * @memberof ProductsResponse
     */
    'categories': Array<Category>;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof ProductsResponse
     */
    'productTypes': Array<ProductType>;
    /**
     * 商品タグ一覧
     * @type {Array<ProductTag>}
     * @memberof ProductsResponse
     */
    'productTags': Array<ProductTag>;
    /**
     * 合計数
     * @type {number}
     * @memberof ProductsResponse
     */
    'total': number;
}
/**
 * プロモーション情報
 * @export
 * @interface Promotion
 */
export interface Promotion {
    /**
     * プロモーションID
     * @type {string}
     * @memberof Promotion
     */
    'id': string;
    /**
     * タイトル
     * @type {string}
     * @memberof Promotion
     */
    'title': string;
    /**
     * 詳細説明
     * @type {string}
     * @memberof Promotion
     */
    'description': string;
    /**
     * 
     * @type {PromotionStatus}
     * @memberof Promotion
     */
    'status': PromotionStatus;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Promotion
     */
    'public': boolean;
    /**
     * 
     * @type {DiscountType}
     * @memberof Promotion
     */
    'discountType': DiscountType;
    /**
     * 割引額(単位:円/%)
     * @type {number}
     * @memberof Promotion
     */
    'discountRate': number;
    /**
     * クーポンコード
     * @type {string}
     * @memberof Promotion
     */
    'code': string;
    /**
     * クーポン利用回数
     * @type {number}
     * @memberof Promotion
     */
    'usedCount': number;
    /**
     * クーポン利用による割引合計額
     * @type {number}
     * @memberof Promotion
     */
    'usedAmount': number;
    /**
     * クーポン利用可能開始日時(unixtime)
     * @type {number}
     * @memberof Promotion
     */
    'startAt': number;
    /**
     * クーポン利用可能終了日時(unixtime)
     * @type {number}
     * @memberof Promotion
     */
    'endAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Promotion
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Promotion
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface PromotionResponse
 */
export interface PromotionResponse {
    /**
     * 
     * @type {Promotion}
     * @memberof PromotionResponse
     */
    'promotion': Promotion;
}
/**
 * プロモーションステータス
 * @export
 * @enum {string}
 */

export const PromotionStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 非公開
    */
    PRIVATE: 1,
    /**
    * 利用可能前
    */
    WAITING: 2,
    /**
    * 利用可能
    */
    ENABLED: 3,
    /**
    * 利用終了
    */
    FINISHED: 4
} as const;

export type PromotionStatus = typeof PromotionStatus[keyof typeof PromotionStatus];


/**
 * 
 * @export
 * @interface PromotionsResponse
 */
export interface PromotionsResponse {
    /**
     * プロモーション一覧
     * @type {Array<Promotion>}
     * @memberof PromotionsResponse
     */
    'promotions': Array<Promotion>;
    /**
     * 合計数
     * @type {number}
     * @memberof PromotionsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface PublishScheduleRequest
 */
export interface PublishScheduleRequest {
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof PublishScheduleRequest
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface RefreshAuthTokenRequest
 */
export interface RefreshAuthTokenRequest {
    /**
     * 更新トークン
     * @type {string}
     * @memberof RefreshAuthTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefundOrderRequest
 */
export interface RefundOrderRequest {
    /**
     * 返金理由詳細
     * @type {string}
     * @memberof RefundOrderRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface RegisterAuthDeviceRequest
 */
export interface RegisterAuthDeviceRequest {
    /**
     * デバイストークン(プッシュ通知用:FCMトークン)
     * @type {string}
     * @memberof RegisterAuthDeviceRequest
     */
    'device': string;
}
/**
 * 
 * @export
 * @interface ResetAuthPasswordRequest
 */
export interface ResetAuthPasswordRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'email': string;
    /**
     * 検証コード
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'verifyCode': string;
    /**
     * パスワード(8~32文字, 英小文字,数字を少なくとも1文字ずつは含む)
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'password': string;
    /**
     * パスワード(確認用)
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'passwordConfirmation': string;
}
/**
 * マルシェ開催スケジュール情報
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * マルシェ開催スケジュールID
     * @type {string}
     * @memberof Schedule
     */
    'id': string;
    /**
     * コーディネーターID
     * @type {string}
     * @memberof Schedule
     */
    'coordinatorId': string;
    /**
     * 
     * @type {ScheduleStatus}
     * @memberof Schedule
     */
    'status': ScheduleStatus;
    /**
     * タイトル
     * @type {string}
     * @memberof Schedule
     */
    'title': string;
    /**
     * 説明
     * @type {string}
     * @memberof Schedule
     */
    'description': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Schedule
     */
    'thumbnailUrl': string;
    /**
     * ふた絵URL
     * @type {string}
     * @memberof Schedule
     */
    'imageUrl': string;
    /**
     * オープニング動画URL
     * @type {string}
     * @memberof Schedule
     */
    'openingVideoUrl': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Schedule
     */
    'public': boolean;
    /**
     * 承認フラグ
     * @type {boolean}
     * @memberof Schedule
     */
    'approved': boolean;
    /**
     * ライブ開始日時 (unixtime)
     * @type {number}
     * @memberof Schedule
     */
    'startAt': number;
    /**
     * ライブ終了日時 (unixtime)
     * @type {number}
     * @memberof Schedule
     */
    'endAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Schedule
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Schedule
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface ScheduleResponse
 */
export interface ScheduleResponse {
    /**
     * 
     * @type {Schedule}
     * @memberof ScheduleResponse
     */
    'schedule': Schedule;
    /**
     * 
     * @type {Coordinator}
     * @memberof ScheduleResponse
     */
    'coordinator': Coordinator;
}
/**
 * マルシェ開催状況
 * @export
 * @enum {string}
 */

export const ScheduleStatus = {
    UNKNOWN: 0,
    PRIVATE: 1,
    IN_PROGRESS: 2,
    WAITING: 3,
    LIVE: 4,
    CLOSED: 5
} as const;

export type ScheduleStatus = typeof ScheduleStatus[keyof typeof ScheduleStatus];


/**
 * 
 * @export
 * @interface SchedulesResponse
 */
export interface SchedulesResponse {
    /**
     * マルシェ開催スケジュール一覧
     * @type {Array<Schedule>}
     * @memberof SchedulesResponse
     */
    'schedules': Array<Schedule>;
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof SchedulesResponse
     */
    'coordinators': Array<Coordinator>;
    /**
     * 合計数
     * @type {number}
     * @memberof SchedulesResponse
     */
    'total': number;
}
/**
 * 配送設定情報
 * @export
 * @interface Shipping
 */
export interface Shipping {
    /**
     * 配送設定ID
     * @type {string}
     * @memberof Shipping
     */
    'id': string;
    /**
     * デフォルト設定
     * @type {boolean}
     * @memberof Shipping
     */
    'isDefault': boolean;
    /**
     * 箱サイズ60の通常配送料一覧
     * @type {Array<ShippingRate>}
     * @memberof Shipping
     */
    'box60Rates': Array<ShippingRate>;
    /**
     * 箱サイズ60の冷凍便追加配送料（税込）
     * @type {number}
     * @memberof Shipping
     */
    'box60Frozen': number;
    /**
     * 箱サイズ80の通常配送料一覧
     * @type {Array<ShippingRate>}
     * @memberof Shipping
     */
    'box80Rates': Array<ShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料（税込）
     * @type {number}
     * @memberof Shipping
     */
    'box80Frozen': number;
    /**
     * 箱サイズ100の通常配送料一覧
     * @type {Array<ShippingRate>}
     * @memberof Shipping
     */
    'box100Rates': Array<ShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料（税込）
     * @type {number}
     * @memberof Shipping
     */
    'box100Frozen': number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof Shipping
     */
    'hasFreeShipping': boolean;
    /**
     * 送料無料になる金額（税込）
     * @type {number}
     * @memberof Shipping
     */
    'freeShippingRates': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Shipping
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Shipping
     */
    'updatedAt': number;
}
/**
 * 配送会社
 * @export
 * @enum {string}
 */

export const ShippingCarrier = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * ヤマト運輸
    */
    YAMATO: 1,
    /**
    * 佐川急便
    */
    SAGAWA: 2
} as const;

export type ShippingCarrier = typeof ShippingCarrier[keyof typeof ShippingCarrier];


/**
 * 配送料情報
 * @export
 * @interface ShippingRate
 */
export interface ShippingRate {
    /**
     * No.
     * @type {number}
     * @memberof ShippingRate
     */
    'number': number;
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof ShippingRate
     */
    'name': string;
    /**
     * 配送料金（税込）
     * @type {number}
     * @memberof ShippingRate
     */
    'price': number;
    /**
     * 対象都道府県コード一覧
     * @type {Array<Prefecture>}
     * @memberof ShippingRate
     */
    'prefectureCodes': Array<Prefecture>;
}
/**
 * 
 * @export
 * @interface ShippingResponse
 */
export interface ShippingResponse {
    /**
     * 
     * @type {Shipping}
     * @memberof ShippingResponse
     */
    'shipping': Shipping;
}
/**
 * 配送時の箱の大きさ
 * @export
 * @enum {string}
 */

export const ShippingSize = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 箱のサイズ:60
    */
    SIZE60: 1,
    /**
    * 箱のサイズ:80
    */
    SIZE80: 2,
    /**
    * 箱のサイズ:100
    */
    SIZE100: 3
} as const;

export type ShippingSize = typeof ShippingSize[keyof typeof ShippingSize];


/**
 * 配送方法
 * @export
 * @enum {string}
 */

export const ShippingType = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 常温・冷蔵便
    */
    NORMAL: 1,
    /**
    * 冷凍便
    */
    FROZEN: 2
} as const;

export type ShippingType = typeof ShippingType[keyof typeof ShippingType];


/**
 * 
 * @export
 * @interface SignInRequest
 */
export interface SignInRequest {
    /**
     * ユーザー名(メールアドレス)
     * @type {string}
     * @memberof SignInRequest
     */
    'username': string;
    /**
     * パスワード
     * @type {string}
     * @memberof SignInRequest
     */
    'password': string;
}
/**
 * 保管方法
 * @export
 * @enum {string}
 */

export const StorageMethodType = {
    UNKNOWN: 0,
    NORMAL: 1,
    COOL_DARK_PLACE: 2,
    REFRIGERATED: 3,
    FROZEN: 4
} as const;

export type StorageMethodType = typeof StorageMethodType[keyof typeof StorageMethodType];


/**
 * お問い合わせ会話履歴情報
 * @export
 * @interface Thread
 */
export interface Thread {
    /**
     * お問い合わせ会話履歴ID
     * @type {string}
     * @memberof Thread
     */
    'id': string;
    /**
     * お問い合わせID
     * @type {string}
     * @memberof Thread
     */
    'contactId': string;
    /**
     * 送信者ID
     * @type {string}
     * @memberof Thread
     */
    'userId'?: string;
    /**
     * 
     * @type {ContactUserType}
     * @memberof Thread
     */
    'userType': ContactUserType;
    /**
     * 会話内容
     * @type {string}
     * @memberof Thread
     */
    'content': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Thread
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Thread
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface ThreadResponse
 */
export interface ThreadResponse {
    /**
     * 
     * @type {Thread}
     * @memberof ThreadResponse
     */
    'thread': Thread;
    /**
     * 
     * @type {User}
     * @memberof ThreadResponse
     */
    'user'?: User;
    /**
     * 
     * @type {Admin}
     * @memberof ThreadResponse
     */
    'admin'?: Admin;
}
/**
 * 
 * @export
 * @interface ThreadsResponse
 */
export interface ThreadsResponse {
    /**
     * お問い合わせ会話履歴一覧
     * @type {Array<Thread>}
     * @memberof ThreadsResponse
     */
    'threads': Array<Thread>;
    /**
     * お問い合わせ会話ユーザー一覧
     * @type {Array<User>}
     * @memberof ThreadsResponse
     */
    'users'?: Array<User>;
    /**
     * お問い合わせ会話管理者一覧
     * @type {Array<Admin>}
     * @memberof ThreadsResponse
     */
    'admins'?: Array<Admin>;
    /**
     * お問い合わせ会話履歴総数
     * @type {number}
     * @memberof ThreadsResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface UpdateAdministratorEmailRequest
 */
export interface UpdateAdministratorEmailRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof UpdateAdministratorEmailRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UpdateAdministratorRequest
 */
export interface UpdateAdministratorRequest {
    /**
     * 姓(16文字まで)
     * @type {string}
     * @memberof UpdateAdministratorRequest
     */
    'lastname': string;
    /**
     * 名(16文字まで)
     * @type {string}
     * @memberof UpdateAdministratorRequest
     */
    'firstname': string;
    /**
     * 姓(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof UpdateAdministratorRequest
     */
    'lastnameKana': string;
    /**
     * 名(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof UpdateAdministratorRequest
     */
    'firstnameKana': string;
    /**
     * 電話番号(国際番号 + 電話番号)
     * @type {string}
     * @memberof UpdateAdministratorRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface UpdateAuthEmailRequest
 */
export interface UpdateAuthEmailRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof UpdateAuthEmailRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UpdateAuthPasswordRequest
 */
export interface UpdateAuthPasswordRequest {
    /**
     * 現在のパスワード
     * @type {string}
     * @memberof UpdateAuthPasswordRequest
     */
    'oldPassword': string;
    /**
     * 新しいパスワード(8~32文字, 英小文字,数字を少なくとも1文字ずつは含む)
     * @type {string}
     * @memberof UpdateAuthPasswordRequest
     */
    'newPassword': string;
    /**
     * パスワード(確認用)
     * @type {string}
     * @memberof UpdateAuthPasswordRequest
     */
    'passwordConfirmation': string;
}
/**
 * 
 * @export
 * @interface UpdateBroadcastArchiveRequest
 */
export interface UpdateBroadcastArchiveRequest {
    /**
     * オンデマンド配信用の動画URL
     * @type {string}
     * @memberof UpdateBroadcastArchiveRequest
     */
    'archiveUrl': string;
}
/**
 * 
 * @export
 * @interface UpdateCategoryRequest
 */
export interface UpdateCategoryRequest {
    /**
     * カテゴリ名(32文字まで)
     * @type {string}
     * @memberof UpdateCategoryRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateContactRequest
 */
export interface UpdateContactRequest {
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'categoryId': string;
    /**
     * お問い合わせ件名(128文字まで)
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'title': string;
    /**
     * お問い合わせ内容(2000文字まで)
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'content': string;
    /**
     * 氏名(128文字まで)
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'userName': string;
    /**
     * 問い合わせ作成者ID
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'userId'?: string;
    /**
     * メールアドレス(256文字まで)
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'email': string;
    /**
     * 電話番号(18文字まで)
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {ContactStatus}
     * @memberof UpdateContactRequest
     */
    'status': ContactStatus;
    /**
     * 対応者ID
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'responderId': string;
    /**
     * 対応メモ(2000文字まで)
     * @type {string}
     * @memberof UpdateContactRequest
     */
    'note': string;
}


/**
 * 
 * @export
 * @interface UpdateCoordinatorEmailRequest
 */
export interface UpdateCoordinatorEmailRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof UpdateCoordinatorEmailRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UpdateCoordinatorRequest
 */
export interface UpdateCoordinatorRequest {
    /**
     * 姓(16文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'lastname': string;
    /**
     * 名(16文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'firstname': string;
    /**
     * 姓(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'lastnameKana': string;
    /**
     * 名(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'firstnameKana': string;
    /**
     * マルシェ名(64文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'marcheName': string;
    /**
     * コーディネータ(64文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'username': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'phoneNumber': string;
    /**
     * 郵便番号(ハイフンなし)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof UpdateCoordinatorRequest
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村(32文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'city': string;
    /**
     * 町名・番地(64文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'addressLine1': string;
    /**
     * ビル名・号室など(64文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'addressLine2': string;
    /**
     * プロフィール(2000文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'profile': string;
    /**
     * 取り扱い品目ID一覧
     * @type {Array<string>}
     * @memberof UpdateCoordinatorRequest
     */
    'productTypeIds': Array<string>;
    /**
     * サムネイル画像URL
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'thumbnailUrl': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'headerUrl': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'promotionVideoUrl': string;
    /**
     * 購入者動画URL
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'bonusVideoUrl': string;
    /**
     * Instagramアカウント(30文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'instagramId': string;
    /**
     * Facebookアカウント(50文字まで)
     * @type {string}
     * @memberof UpdateCoordinatorRequest
     */
    'facebookId': string;
    /**
     * 営業曜日
     * @type {Array<Weekday>}
     * @memberof UpdateCoordinatorRequest
     */
    'businessDays': Array<Weekday>;
}


/**
 * 
 * @export
 * @interface UpdateDefaultShippingRate
 */
export interface UpdateDefaultShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof UpdateDefaultShippingRate
     */
    'name': string;
    /**
     * 配送料金(税込:100万未満)
     * @type {number}
     * @memberof UpdateDefaultShippingRate
     */
    'price': number;
    /**
     * 対象都道府県コード一覧
     * @type {Array<Prefecture>}
     * @memberof UpdateDefaultShippingRate
     */
    'prefectureCodes': Array<Prefecture>;
}
/**
 * 
 * @export
 * @interface UpdateDefaultShippingRequest
 */
export interface UpdateDefaultShippingRequest {
    /**
     * 箱サイズ60の通常配送料一覧(すべての都道府県の設定が必須)
     * @type {Array<UpdateDefaultShippingRate>}
     * @memberof UpdateDefaultShippingRequest
     */
    'box60Rates': Array<UpdateDefaultShippingRate>;
    /**
     * 箱サイズ60の冷凍便追加配送料(税込:100万未満)
     * @type {number}
     * @memberof UpdateDefaultShippingRequest
     */
    'box60Frozen': number;
    /**
     * 箱サイズ80の通常配送料一覧(すべての都道府県の設定が必須)
     * @type {Array<UpdateDefaultShippingRate>}
     * @memberof UpdateDefaultShippingRequest
     */
    'box80Rates': Array<UpdateDefaultShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料(税込:100万未満)
     * @type {number}
     * @memberof UpdateDefaultShippingRequest
     */
    'box80Frozen': number;
    /**
     * 箱サイズ100の通常配送料一覧(すべての都道府県の設定が必須)
     * @type {Array<UpdateDefaultShippingRate>}
     * @memberof UpdateDefaultShippingRequest
     */
    'box100Rates': Array<UpdateDefaultShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料(税込:100万未満)
     * @type {number}
     * @memberof UpdateDefaultShippingRequest
     */
    'box100Frozen': number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof UpdateDefaultShippingRequest
     */
    'hasFreeShipping': boolean;
    /**
     * 送料無料になる金額(税込:100万未満)
     * @type {number}
     * @memberof UpdateDefaultShippingRequest
     */
    'freeShippingRates': number;
}
/**
 * 
 * @export
 * @interface UpdateExperienceRequest
 */
export interface UpdateExperienceRequest {
    /**
     * タイトル(128文字まで)
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'title': string;
    /**
     * 説明(20000文字まで)
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof UpdateExperienceRequest
     */
    'public': boolean;
    /**
     * 完売フラグ
     * @type {boolean}
     * @memberof UpdateExperienceRequest
     */
    'soldOut': boolean;
    /**
     * コーディネータID
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'coordinatorId': string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'producerId': string;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'experienceTypeId': string;
    /**
     * メディア一覧(8つまで)
     * @type {Array<ExperienceMediaInner>}
     * @memberof UpdateExperienceRequest
     */
    'media': Array<ExperienceMediaInner>;
    /**
     * 大人販売価格(税込:0以上)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'priceAdult': number;
    /**
     * 中学生販売価格(税込:0以上)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'priceJuniorHighSchool': number;
    /**
     * 小学生販売価格(税込:0以上)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'priceElementarySchool': number;
    /**
     * 幼児販売価格(税込:0以上)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'pricePreschooler': number;
    /**
     * シニア販売価格(税込:0以上)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'priceSenior': number;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'recommendedPoint1': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'recommendedPoint2': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'recommendedPoint3': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof UpdateExperienceRequest
     */
    'hostPrefectureCode': Prefecture;
    /**
     * 開催場所(市区町村)
     * @type {string}
     * @memberof UpdateExperienceRequest
     */
    'hostCity': string;
    /**
     * 販売開始日時 (unixtime)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'startAt': number;
    /**
     * 販売終了日時 (unixtime)
     * @type {number}
     * @memberof UpdateExperienceRequest
     */
    'endAt': number;
}


/**
 * 
 * @export
 * @interface UpdateExperienceTypeRequest
 */
export interface UpdateExperienceTypeRequest {
    /**
     * 体験種別名(32文字まで)
     * @type {string}
     * @memberof UpdateExperienceTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateLiveCommentRequest
 */
export interface UpdateLiveCommentRequest {
    /**
     * コメントの無効化
     * @type {boolean}
     * @memberof UpdateLiveCommentRequest
     */
    'disabled': boolean;
}
/**
 * 
 * @export
 * @interface UpdateLiveRequest
 */
export interface UpdateLiveRequest {
    /**
     * 商品一覧(8つまで)
     * @type {Array<string>}
     * @memberof UpdateLiveRequest
     */
    'productIds': Array<string>;
    /**
     * コメント
     * @type {string}
     * @memberof UpdateLiveRequest
     */
    'comment': string;
    /**
     * ライブ開始予定日時 (unixtime)
     * @type {number}
     * @memberof UpdateLiveRequest
     */
    'startAt': number;
    /**
     * ライブ終了予定日時 (unixtime)
     * @type {number}
     * @memberof UpdateLiveRequest
     */
    'endAt': number;
}
/**
 * 
 * @export
 * @interface UpdateNotificationRequest
 */
export interface UpdateNotificationRequest {
    /**
     * 通知対象一覧
     * @type {Array<NotificationTarget>}
     * @memberof UpdateNotificationRequest
     */
    'targets': Array<NotificationTarget>;
    /**
     * タイトル(128字まで)
     * @type {string}
     * @memberof UpdateNotificationRequest
     */
    'title': string;
    /**
     * 本文(2000字まで)
     * @type {string}
     * @memberof UpdateNotificationRequest
     */
    'body': string;
    /**
     * 備考(2000字まで)
     * @type {string}
     * @memberof UpdateNotificationRequest
     */
    'note': string;
    /**
     * 掲載日時 (unixtime)
     * @type {number}
     * @memberof UpdateNotificationRequest
     */
    'publishedAt': number;
}
/**
 * 
 * @export
 * @interface UpdateOrderFulfillmentRequest
 */
export interface UpdateOrderFulfillmentRequest {
    /**
     * 
     * @type {ShippingCarrier}
     * @memberof UpdateOrderFulfillmentRequest
     */
    'shippingCarrier': ShippingCarrier;
    /**
     * 伝票番号
     * @type {string}
     * @memberof UpdateOrderFulfillmentRequest
     */
    'trackingNumber': string;
}


/**
 * 
 * @export
 * @interface UpdatePaymentSystemRequest
 */
export interface UpdatePaymentSystemRequest {
    /**
     * 
     * @type {PaymentSystemStatus}
     * @memberof UpdatePaymentSystemRequest
     */
    'status': PaymentSystemStatus;
}


/**
 * 
 * @export
 * @interface UpdateProducerRequest
 */
export interface UpdateProducerRequest {
    /**
     * 姓(16文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'lastname': string;
    /**
     * 名(16文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'firstname': string;
    /**
     * 姓(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'lastnameKana': string;
    /**
     * 名(かな)(ひらがな,32文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'firstnameKana': string;
    /**
     * 生産者名(64文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'username': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'phoneNumber': string;
    /**
     * 郵便番号(ハイフンなし)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'postalCode': string;
    /**
     * 
     * @type {Prefecture}
     * @memberof UpdateProducerRequest
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村(32文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'city': string;
    /**
     * 町名・番地(64文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'addressLine1': string;
    /**
     * ビル名・号室など(64文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'addressLine2': string;
    /**
     * プロフィール(2000文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'profile': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'thumbnailUrl': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'headerUrl': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'promotionVideoUrl': string;
    /**
     * 購入者動画URL
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'bonusVideoUrl': string;
    /**
     * Instagramアカウント(30文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'instagramId': string;
    /**
     * Facebookアカウント(50文字まで)
     * @type {string}
     * @memberof UpdateProducerRequest
     */
    'facebookId': string;
}


/**
 * 
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * 商品名(128文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name': string;
    /**
     * 商品説明(20000文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof UpdateProductRequest
     */
    'public': boolean;
    /**
     * 品目ID
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'productTypeId': string;
    /**
     * 商品タグ一覧
     * @type {Array<string>}
     * @memberof UpdateProductRequest
     */
    'productTagIds': Array<string>;
    /**
     * メディア一覧(8つまで)
     * @type {Array<ProductMediaInner>}
     * @memberof UpdateProductRequest
     */
    'media': Array<ProductMediaInner>;
    /**
     * 販売価格(税込:0以上)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'price': number;
    /**
     * 原価(税込:0以上)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'cost': number;
    /**
     * 在庫数(0以上)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'inventory': number;
    /**
     * 重量(0以上,kg単位:少数第1位まで)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'weight': number;
    /**
     * 数量単位(16文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'itemUnit': string;
    /**
     * 数量単位説明(64文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'itemDescription': string;
    /**
     * 
     * @type {DeliveryType}
     * @memberof UpdateProductRequest
     */
    'deliveryType': DeliveryType;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'recommendedPoint1': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'recommendedPoint2': string;
    /**
     * おすすめポイント1(128文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'recommendedPoint3': string;
    /**
     * 賞味期限(単位:日,0以上)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'expirationDate': number;
    /**
     * 
     * @type {StorageMethodType}
     * @memberof UpdateProductRequest
     */
    'storageMethodType': StorageMethodType;
    /**
     * 箱の占有率(サイズ:60)(0以上,100以下)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'box60Rate': number;
    /**
     * 箱の占有率(サイズ:80)(0以上,100以下)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'box80Rate': number;
    /**
     * 箱の占有率(サイズ:100)(0以上,100以下)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'box100Rate': number;
    /**
     * 
     * @type {Prefecture}
     * @memberof UpdateProductRequest
     */
    'originPrefectureCode': Prefecture;
    /**
     * 原産地(市区町村)(32文字まで)
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'originCity': string;
    /**
     * 販売開始日時 (unixtime)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'startAt': number;
    /**
     * 販売終了日時 (unixtime)
     * @type {number}
     * @memberof UpdateProductRequest
     */
    'endAt': number;
}


/**
 * 
 * @export
 * @interface UpdateProductTagRequest
 */
export interface UpdateProductTagRequest {
    /**
     * 商品タグ名(32文字まで)
     * @type {string}
     * @memberof UpdateProductTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateProductTypeRequest
 */
export interface UpdateProductTypeRequest {
    /**
     * 品目名(32文字まで)
     * @type {string}
     * @memberof UpdateProductTypeRequest
     */
    'name': string;
    /**
     * アイコンURL
     * @type {string}
     * @memberof UpdateProductTypeRequest
     */
    'iconUrl': string;
}
/**
 * 
 * @export
 * @interface UpdatePromotionRequest
 */
export interface UpdatePromotionRequest {
    /**
     * タイトル(64文字まで)
     * @type {string}
     * @memberof UpdatePromotionRequest
     */
    'title': string;
    /**
     * 説明(2000文字まで)
     * @type {string}
     * @memberof UpdatePromotionRequest
     */
    'description': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof UpdatePromotionRequest
     */
    'public': boolean;
    /**
     * 
     * @type {DiscountType}
     * @memberof UpdatePromotionRequest
     */
    'discountType': DiscountType;
    /**
     * 割引額(単位:円/%,0以上)
     * @type {number}
     * @memberof UpdatePromotionRequest
     */
    'discountRate': number;
    /**
     * クーポンコード(8文字,使用可能文字:半角英数字,公開日時より前の場合のみ変更可能)
     * @type {string}
     * @memberof UpdatePromotionRequest
     */
    'code': string;
    /**
     * クーポン利用可能開始日時(unixtime)
     * @type {number}
     * @memberof UpdatePromotionRequest
     */
    'startAt': number;
    /**
     * クーポン利用可能終了日時(unixtime)
     * @type {number}
     * @memberof UpdatePromotionRequest
     */
    'endAt': number;
}


/**
 * 
 * @export
 * @interface UpdateScheduleRequest
 */
export interface UpdateScheduleRequest {
    /**
     * タイトル(128文字まで)
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    'title': string;
    /**
     * 説明(20000文字まで)
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    'description': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    'thumbnailUrl': string;
    /**
     * 蓋絵URL
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    'imageUrl': string;
    /**
     * オープニングURL
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    'openingVideoUrl': string;
    /**
     * マルシェ開始日時
     * @type {number}
     * @memberof UpdateScheduleRequest
     */
    'startAt': number;
    /**
     * マルシェ終了日時
     * @type {number}
     * @memberof UpdateScheduleRequest
     */
    'endAt': number;
}
/**
 * 
 * @export
 * @interface UpdateThreadRequest
 */
export interface UpdateThreadRequest {
    /**
     * 送信者ID
     * @type {string}
     * @memberof UpdateThreadRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {ContactUserType}
     * @memberof UpdateThreadRequest
     */
    'userType': ContactUserType;
    /**
     * 会話内容
     * @type {string}
     * @memberof UpdateThreadRequest
     */
    'content': string;
}


/**
 * 
 * @export
 * @interface UpdateVideoRequest
 */
export interface UpdateVideoRequest {
    /**
     * タイトル(128文字まで)
     * @type {string}
     * @memberof UpdateVideoRequest
     */
    'title': string;
    /**
     * 説明(20000文字まで)
     * @type {string}
     * @memberof UpdateVideoRequest
     */
    'description': string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof UpdateVideoRequest
     */
    'coordinatorId': string;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof UpdateVideoRequest
     */
    'productIds': Array<string>;
    /**
     * 体験ID一覧
     * @type {Array<string>}
     * @memberof UpdateVideoRequest
     */
    'experienceIds': Array<string>;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof UpdateVideoRequest
     */
    'thumbnailUrl': string;
    /**
     * 動画URL
     * @type {string}
     * @memberof UpdateVideoRequest
     */
    'videoUrl': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof UpdateVideoRequest
     */
    'public': boolean;
    /**
     * 限定公開フラグ
     * @type {boolean}
     * @memberof UpdateVideoRequest
     */
    'limited': boolean;
    /**
     * 公開日時 (unixtime)
     * @type {number}
     * @memberof UpdateVideoRequest
     */
    'publishedAt': number;
}
/**
 * 
 * @export
 * @interface UploadStateResponse
 */
export interface UploadStateResponse {
    /**
     * 参照先ファイルURL
     * @type {string}
     * @memberof UploadStateResponse
     */
    'url': string;
    /**
     * 
     * @type {UploadStatus}
     * @memberof UploadStateResponse
     */
    'status': UploadStatus;
}


/**
 * ファイルアップロードの状態
 * @export
 * @enum {string}
 */

export const UploadStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * アップロード中
    */
    WAITING: 1,
    /**
    * 成功
    */
    SUCEEDED: 2,
    /**
    * 失敗
    */
    FAILED: 3
} as const;

export type UploadStatus = typeof UploadStatus[keyof typeof UploadStatus];


/**
 * 
 * @export
 * @interface UploadUrlResponse
 */
export interface UploadUrlResponse {
    /**
     * アップロード後の状態参照用キー
     * @type {string}
     * @memberof UploadUrlResponse
     */
    'key': string;
    /**
     * 署名付きアップロードURL
     * @type {string}
     * @memberof UploadUrlResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UpsertShippingRate
 */
export interface UpsertShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof UpsertShippingRate
     */
    'name': string;
    /**
     * 配送料金(税込:100万未満)
     * @type {number}
     * @memberof UpsertShippingRate
     */
    'price': number;
    /**
     * 対象都道府県コード一覧
     * @type {Array<Prefecture>}
     * @memberof UpsertShippingRate
     */
    'prefectureCodes': Array<Prefecture>;
}
/**
 * 
 * @export
 * @interface UpsertShippingRequest
 */
export interface UpsertShippingRequest {
    /**
     * 箱サイズ60の通常配送料一覧(すべての都道府県の設定が必須)
     * @type {Array<UpsertShippingRate>}
     * @memberof UpsertShippingRequest
     */
    'box60Rates': Array<UpsertShippingRate>;
    /**
     * 箱サイズ60の冷凍便追加配送料(税込:100万未満)
     * @type {number}
     * @memberof UpsertShippingRequest
     */
    'box60Frozen': number;
    /**
     * 箱サイズ80の通常配送料一覧(すべての都道府県の設定が必須)
     * @type {Array<UpsertShippingRate>}
     * @memberof UpsertShippingRequest
     */
    'box80Rates': Array<UpsertShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料(税込:100万未満)
     * @type {number}
     * @memberof UpsertShippingRequest
     */
    'box80Frozen': number;
    /**
     * 箱サイズ100の通常配送料一覧(すべての都道府県の設定が必須)
     * @type {Array<UpsertShippingRate>}
     * @memberof UpsertShippingRequest
     */
    'box100Rates': Array<UpsertShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料(税込:100万未満)
     * @type {number}
     * @memberof UpsertShippingRequest
     */
    'box100Frozen': number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof UpsertShippingRequest
     */
    'hasFreeShipping': boolean;
    /**
     * 送料無料になる金額(税込:100万未満)
     * @type {number}
     * @memberof UpsertShippingRequest
     */
    'freeShippingRates': number;
}
/**
 * 購入者情報
 * @export
 * @interface User
 */
export interface User {
    /**
     * 購入者ID
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {UserStatus}
     * @memberof User
     */
    'status': UserStatus;
    /**
     * 会員登録フラグ
     * @type {boolean}
     * @memberof User
     */
    'registered': boolean;
    /**
     * ユーザー名 (表示名)
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * ユーザー名 (検索用)
     * @type {string}
     * @memberof User
     */
    'accountId': string;
    /**
     * 姓
     * @type {string}
     * @memberof User
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof User
     */
    'firstname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof User
     */
    'lastnameKana': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof User
     */
    'firstnameKana': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 電話番号 (国際番号 + 電話番号)
     * @type {string}
     * @memberof User
     */
    'phoneNumber': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof User
     */
    'thumbnailUrl': string;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof User
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof User
     */
    'updatedAt': number;
}


/**
 * 購入者の注文情報
 * @export
 * @interface UserOrder
 */
export interface UserOrder {
    /**
     * 注文履歴ID
     * @type {string}
     * @memberof UserOrder
     */
    'orderId': string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof UserOrder
     */
    'status': PaymentStatus;
    /**
     * 購入商品合計金額
     * @type {number}
     * @memberof UserOrder
     */
    'subtotal': number;
    /**
     * 支払い合計金額
     * @type {number}
     * @memberof UserOrder
     */
    'total': number;
    /**
     * 注文日時
     * @type {number}
     * @memberof UserOrder
     */
    'orderedAt': number;
    /**
     * 支払日時
     * @type {number}
     * @memberof UserOrder
     */
    'paidAt': number;
}


/**
 * 
 * @export
 * @interface UserOrdersResponse
 */
export interface UserOrdersResponse {
    /**
     * 注文履歴一覧
     * @type {Array<UserOrder>}
     * @memberof UserOrdersResponse
     */
    'orders': Array<UserOrder>;
    /**
     * 注文合計回数
     * @type {number}
     * @memberof UserOrdersResponse
     */
    'orderTotalCount': number;
    /**
     * 支払い合計回数
     * @type {number}
     * @memberof UserOrdersResponse
     */
    'paymentTotalCount': number;
    /**
     * 購入商品合計金額
     * @type {number}
     * @memberof UserOrdersResponse
     */
    'productTotalAmount': number;
    /**
     * 支払い合計金額
     * @type {number}
     * @memberof UserOrdersResponse
     */
    'paymentTotalAmount': number;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    'user': User;
    /**
     * 
     * @type {Address}
     * @memberof UserResponse
     */
    'address': Address;
}
/**
 * 購入者の状態
 * @export
 * @enum {string}
 */

export const UserStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 未登録
    */
    GUEST: 1,
    /**
    * 仮登録
    */
    PROVISIONAL: 2,
    /**
    * 認証済み
    */
    VERIFIED: 3,
    /**
    * 退会済み
    */
    WITH_DRAWAL: 4
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


/**
 * 購入者一覧用情報
 * @export
 * @interface UserToList
 */
export interface UserToList {
    /**
     * 購入者ID
     * @type {string}
     * @memberof UserToList
     */
    'id': string;
    /**
     * 姓
     * @type {string}
     * @memberof UserToList
     */
    'lastname': string;
    /**
     * 名
     * @type {string}
     * @memberof UserToList
     */
    'firstname': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof UserToList
     */
    'email': string;
    /**
     * 
     * @type {UserStatus}
     * @memberof UserToList
     */
    'status': UserStatus;
    /**
     * 会員登録フラグ
     * @type {boolean}
     * @memberof UserToList
     */
    'registered': boolean;
    /**
     * 
     * @type {Prefecture}
     * @memberof UserToList
     */
    'prefectureCode': Prefecture;
    /**
     * 市区町村
     * @type {string}
     * @memberof UserToList
     */
    'city': string;
    /**
     * 支払い回数
     * @type {number}
     * @memberof UserToList
     */
    'paymentTotalCount': number;
}


/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 購入者一覧
     * @type {Array<UserToList>}
     * @memberof UsersResponse
     */
    'users': Array<UserToList>;
    /**
     * 合計数
     * @type {number}
     * @memberof UsersResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface VerifyAuthEmailRequest
 */
export interface VerifyAuthEmailRequest {
    /**
     * 認証コード
     * @type {string}
     * @memberof VerifyAuthEmailRequest
     */
    'verifyCode': string;
}
/**
 * オンデマンド配信情報
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * オンデマンド配信ID
     * @type {string}
     * @memberof Video
     */
    'id': string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Video
     */
    'coordinatorId': string;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof Video
     */
    'productIds': Array<string>;
    /**
     * 体験ID一覧
     * @type {Array<string>}
     * @memberof Video
     */
    'experienceIds': Array<string>;
    /**
     * タイトル
     * @type {string}
     * @memberof Video
     */
    'title': string;
    /**
     * 説明
     * @type {string}
     * @memberof Video
     */
    'description': string;
    /**
     * 
     * @type {VideoStatus}
     * @memberof Video
     */
    'status': VideoStatus;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Video
     */
    'thumbnailUrl': string;
    /**
     * 動画URL
     * @type {string}
     * @memberof Video
     */
    'videoUrl': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Video
     */
    'public': boolean;
    /**
     * 限定公開フラグ
     * @type {boolean}
     * @memberof Video
     */
    'limited': boolean;
    /**
     * 公開日時 (unixtime)
     * @type {number}
     * @memberof Video
     */
    'publishedAt': number;
    /**
     * 登録日時 (unixtime)
     * @type {number}
     * @memberof Video
     */
    'createdAt': number;
    /**
     * 更新日時 (unixtime)
     * @type {number}
     * @memberof Video
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface VideoResponse
 */
export interface VideoResponse {
    /**
     * 
     * @type {Video}
     * @memberof VideoResponse
     */
    'video': Video;
    /**
     * 
     * @type {Coordinator}
     * @memberof VideoResponse
     */
    'coordinator': Coordinator;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof VideoResponse
     */
    'products': Array<Product>;
    /**
     * 体験一覧
     * @type {Array<Experience>}
     * @memberof VideoResponse
     */
    'experiences': Array<Experience>;
}
/**
 * オンデマンド配信ステータス
 * @export
 * @enum {string}
 */

export const VideoStatus = {
    /**
    * 不明
    */
    UNKNOWN: 0,
    /**
    * 非公開
    */
    PRIVATE: 1,
    /**
    * 公開前
    */
    WAITING: 2,
    /**
    * 限定公開
    */
    LIMITED: 3,
    /**
    * 公開済み
    */
    PUBLISHED: 4
} as const;

export type VideoStatus = typeof VideoStatus[keyof typeof VideoStatus];


/**
 * 
 * @export
 * @interface VideosResponse
 */
export interface VideosResponse {
    /**
     * 動画一覧
     * @type {Array<Video>}
     * @memberof VideosResponse
     */
    'videos': Array<Video>;
    /**
     * コーディネーター一覧
     * @type {Array<Coordinator>}
     * @memberof VideosResponse
     */
    'coordinators': Array<Coordinator>;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof VideosResponse
     */
    'products': Array<Product>;
    /**
     * 体験一覧
     * @type {Array<Experience>}
     * @memberof VideosResponse
     */
    'experiences': Array<Experience>;
    /**
     * 合計数
     * @type {number}
     * @memberof VideosResponse
     */
    'total': number;
}
/**
 * 曜日
 * @export
 * @enum {string}
 */

export const Weekday = {
    /**
    * 日曜日
    */
    SUNDAY: 0,
    /**
    * 月曜日
    */
    MONDAY: 1,
    /**
    * 火曜日
    */
    TUESDAY: 2,
    /**
    * 水曜日
    */
    WEDNESDAY: 3,
    /**
    * 木曜日
    */
    THURSDAY: 4,
    /**
    * 金曜日
    */
    FRIDAY: 5,
    /**
    * 土曜日
    */
    SATURDAY: 6
} as const;

export type Weekday = typeof Weekday[keyof typeof Weekday];



/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 郵便番号情報検索
         * @param {string} postalCode 郵便番号(ハイフンなし)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchPostalCode: async (postalCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postalCode' is not null or undefined
            assertParamExists('v1SearchPostalCode', 'postalCode', postalCode)
            const localVarPath = `/v1/postal-codes/{postalCode}`
                .replace(`{${"postalCode"}}`, encodeURIComponent(String(postalCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 郵便番号情報検索
         * @param {string} postalCode 郵便番号(ハイフンなし)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchPostalCode(postalCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostalCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchPostalCode(postalCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressApi.v1SearchPostalCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @summary 郵便番号情報検索
         * @param {string} postalCode 郵便番号(ハイフンなし)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchPostalCode(postalCode: string, options?: RawAxiosRequestConfig): AxiosPromise<PostalCodeResponse> {
            return localVarFp.v1SearchPostalCode(postalCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary 郵便番号情報検索
     * @param {string} postalCode 郵便番号(ハイフンなし)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public v1SearchPostalCode(postalCode: string, options?: RawAxiosRequestConfig) {
        return AddressApiFp(this.configuration).v1SearchPostalCode(postalCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdministratorApi - axios parameter creator
 * @export
 */
export const AdministratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary システム管理者登録
         * @param {CreateAdministratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateAdministrator: async (body: CreateAdministratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateAdministrator', 'body', body)
            const localVarPath = `/v1/administrators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary システム管理者退会
         * @param {string} adminId システム管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteAdministrator: async (adminId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1DeleteAdministrator', 'adminId', adminId)
            const localVarPath = `/v1/administrators/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary システム管理者取得
         * @param {string} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAdministrator: async (adminId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1GetAdministrator', 'adminId', adminId)
            const localVarPath = `/v1/administrators/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary システム管理者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListAdministrators: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/administrators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary システム管理者更新
         * @param {string} adminId システム管理者ID
         * @param {UpdateAdministratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAdministrator: async (adminId: string, body: UpdateAdministratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1UpdateAdministrator', 'adminId', adminId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateAdministrator', 'body', body)
            const localVarPath = `/v1/administrators/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary システム管理者メールアドレス更新
         * @param {string} adminId システム管理者ID
         * @param {UpdateAdministratorEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAdministratorEmail: async (adminId: string, body: UpdateAdministratorEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1UpdateAdministratorEmail', 'adminId', adminId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateAdministratorEmail', 'body', body)
            const localVarPath = `/v1/administrators/{adminId}/email`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary システム管理者パスワード更新(ランダム生成)
         * @param {string} adminId システム管理者ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAdministratorPassword: async (adminId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1UpdateAdministratorPassword', 'adminId', adminId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateAdministratorPassword', 'body', body)
            const localVarPath = `/v1/administrators/{adminId}/password`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdministratorApi - functional programming interface
 * @export
 */
export const AdministratorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdministratorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary システム管理者登録
         * @param {CreateAdministratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateAdministrator(body: CreateAdministratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdministratorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateAdministrator(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1CreateAdministrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary システム管理者退会
         * @param {string} adminId システム管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteAdministrator(adminId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteAdministrator(adminId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1DeleteAdministrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary システム管理者取得
         * @param {string} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetAdministrator(adminId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdministratorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetAdministrator(adminId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1GetAdministrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary システム管理者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListAdministrators(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdministratorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListAdministrators(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1ListAdministrators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary システム管理者更新
         * @param {string} adminId システム管理者ID
         * @param {UpdateAdministratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateAdministrator(adminId: string, body: UpdateAdministratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateAdministrator(adminId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1UpdateAdministrator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary システム管理者メールアドレス更新
         * @param {string} adminId システム管理者ID
         * @param {UpdateAdministratorEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateAdministratorEmail(adminId: string, body: UpdateAdministratorEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateAdministratorEmail(adminId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1UpdateAdministratorEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary システム管理者パスワード更新(ランダム生成)
         * @param {string} adminId システム管理者ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateAdministratorPassword(adminId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateAdministratorPassword(adminId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1UpdateAdministratorPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdministratorApi - factory interface
 * @export
 */
export const AdministratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdministratorApiFp(configuration)
    return {
        /**
         * 
         * @summary システム管理者登録
         * @param {CreateAdministratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateAdministrator(body: CreateAdministratorRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdministratorResponse> {
            return localVarFp.v1CreateAdministrator(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary システム管理者退会
         * @param {string} adminId システム管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteAdministrator(adminId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteAdministrator(adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary システム管理者取得
         * @param {string} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAdministrator(adminId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdministratorResponse> {
            return localVarFp.v1GetAdministrator(adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary システム管理者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListAdministrators(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<AdministratorsResponse> {
            return localVarFp.v1ListAdministrators(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary システム管理者更新
         * @param {string} adminId システム管理者ID
         * @param {UpdateAdministratorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAdministrator(adminId: string, body: UpdateAdministratorRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateAdministrator(adminId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary システム管理者メールアドレス更新
         * @param {string} adminId システム管理者ID
         * @param {UpdateAdministratorEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAdministratorEmail(adminId: string, body: UpdateAdministratorEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateAdministratorEmail(adminId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary システム管理者パスワード更新(ランダム生成)
         * @param {string} adminId システム管理者ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAdministratorPassword(adminId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateAdministratorPassword(adminId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdministratorApi - object-oriented interface
 * @export
 * @class AdministratorApi
 * @extends {BaseAPI}
 */
export class AdministratorApi extends BaseAPI {
    /**
     * 
     * @summary システム管理者登録
     * @param {CreateAdministratorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1CreateAdministrator(body: CreateAdministratorRequest, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1CreateAdministrator(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary システム管理者退会
     * @param {string} adminId システム管理者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1DeleteAdministrator(adminId: string, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1DeleteAdministrator(adminId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary システム管理者取得
     * @param {string} adminId 管理者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1GetAdministrator(adminId: string, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1GetAdministrator(adminId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary システム管理者一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1ListAdministrators(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1ListAdministrators(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary システム管理者更新
     * @param {string} adminId システム管理者ID
     * @param {UpdateAdministratorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1UpdateAdministrator(adminId: string, body: UpdateAdministratorRequest, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1UpdateAdministrator(adminId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary システム管理者メールアドレス更新
     * @param {string} adminId システム管理者ID
     * @param {UpdateAdministratorEmailRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1UpdateAdministratorEmail(adminId: string, body: UpdateAdministratorEmailRequest, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1UpdateAdministratorEmail(adminId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary システム管理者パスワード更新(ランダム生成)
     * @param {string} adminId システム管理者ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1UpdateAdministratorPassword(adminId: string, body: object, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1UpdateAdministratorPassword(adminId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary パスワードリセット
         * @param {ForgotAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ForgotAuthPassword: async (body: ForgotAuthPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1ForgotAuthPassword', 'body', body)
            const localVarPath = `/v1/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary トークン検証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自身のコーディネータ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuthCoordinator: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/coordinator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自身の配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuthShipping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/coordinator/shippings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 管理者情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuthUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary トークン更新
         * @param {RefreshAuthTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefreshAuthToken: async (body: RefreshAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1RefreshAuthToken', 'body', body)
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary デバイストークン登録
         * @param {RegisterAuthDeviceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RegisterAuthDevice: async (body: RegisterAuthDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1RegisterAuthDevice', 'body', body)
            const localVarPath = `/v1/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パスワードリセット - コード検証
         * @param {ResetAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ResetAuthPassword: async (body: ResetAuthPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1ResetAuthPassword', 'body', body)
            const localVarPath = `/v1/auth/forgot-password/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary サインイン
         * @param {SignInRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignIn: async (body: SignInRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1SignIn', 'body', body)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary サインアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignOut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自身のコーディネータ情報更新
         * @param {UpdateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAuthCoordinator: async (body: UpdateCoordinatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateAuthCoordinator', 'body', body)
            const localVarPath = `/v1/auth/coordinator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary メールアドレス更新
         * @param {UpdateAuthEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAuthEmail: async (body: UpdateAuthEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateAuthEmail', 'body', body)
            const localVarPath = `/v1/auth/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パスワード更新
         * @param {UpdateAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAuthPassword: async (body: UpdateAuthPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateAuthPassword', 'body', body)
            const localVarPath = `/v1/auth/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自身の配送設定更新
         * @param {UpsertShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpsertAuthShipping: async (body: UpsertShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpsertAuthShipping', 'body', body)
            const localVarPath = `/v1/auth/coordinator/shippings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary メールアドレス更新 - コード検証
         * @param {VerifyAuthEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VerifyAuthEmail: async (body: VerifyAuthEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1VerifyAuthEmail', 'body', body)
            const localVarPath = `/v1/auth/email/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary パスワードリセット
         * @param {ForgotAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ForgotAuthPassword(body: ForgotAuthPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ForgotAuthPassword(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1ForgotAuthPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary トークン検証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetAuth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetAuth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1GetAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 自身のコーディネータ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetAuthCoordinator(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoordinatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetAuthCoordinator(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1GetAuthCoordinator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 自身の配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetAuthShipping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetAuthShipping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1GetAuthShipping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 管理者情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetAuthUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetAuthUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1GetAuthUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary トークン更新
         * @param {RefreshAuthTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefreshAuthToken(body: RefreshAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefreshAuthToken(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1RefreshAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary デバイストークン登録
         * @param {RegisterAuthDeviceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RegisterAuthDevice(body: RegisterAuthDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RegisterAuthDevice(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1RegisterAuthDevice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary パスワードリセット - コード検証
         * @param {ResetAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ResetAuthPassword(body: ResetAuthPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ResetAuthPassword(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1ResetAuthPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary サインイン
         * @param {SignInRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignIn(body: SignInRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignIn(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1SignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary サインアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SignOut(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SignOut(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1SignOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 自身のコーディネータ情報更新
         * @param {UpdateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateAuthCoordinator(body: UpdateCoordinatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateAuthCoordinator(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1UpdateAuthCoordinator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary メールアドレス更新
         * @param {UpdateAuthEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateAuthEmail(body: UpdateAuthEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateAuthEmail(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1UpdateAuthEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary パスワード更新
         * @param {UpdateAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateAuthPassword(body: UpdateAuthPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateAuthPassword(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1UpdateAuthPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 自身の配送設定更新
         * @param {UpsertShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpsertAuthShipping(body: UpsertShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpsertAuthShipping(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1UpsertAuthShipping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary メールアドレス更新 - コード検証
         * @param {VerifyAuthEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VerifyAuthEmail(body: VerifyAuthEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VerifyAuthEmail(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1VerifyAuthEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary パスワードリセット
         * @param {ForgotAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ForgotAuthPassword(body: ForgotAuthPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1ForgotAuthPassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary トークン検証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuth(options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1GetAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自身のコーディネータ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuthCoordinator(options?: RawAxiosRequestConfig): AxiosPromise<CoordinatorResponse> {
            return localVarFp.v1GetAuthCoordinator(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自身の配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuthShipping(options?: RawAxiosRequestConfig): AxiosPromise<ShippingResponse> {
            return localVarFp.v1GetAuthShipping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 管理者情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetAuthUser(options?: RawAxiosRequestConfig): AxiosPromise<AuthUserResponse> {
            return localVarFp.v1GetAuthUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary トークン更新
         * @param {RefreshAuthTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefreshAuthToken(body: RefreshAuthTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1RefreshAuthToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary デバイストークン登録
         * @param {RegisterAuthDeviceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RegisterAuthDevice(body: RegisterAuthDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1RegisterAuthDevice(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パスワードリセット - コード検証
         * @param {ResetAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ResetAuthPassword(body: ResetAuthPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1ResetAuthPassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary サインイン
         * @param {SignInRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignIn(body: SignInRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1SignIn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary サインアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SignOut(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1SignOut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自身のコーディネータ情報更新
         * @param {UpdateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAuthCoordinator(body: UpdateCoordinatorRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateAuthCoordinator(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary メールアドレス更新
         * @param {UpdateAuthEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAuthEmail(body: UpdateAuthEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateAuthEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パスワード更新
         * @param {UpdateAuthPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateAuthPassword(body: UpdateAuthPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateAuthPassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自身の配送設定更新
         * @param {UpsertShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpsertAuthShipping(body: UpsertShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpsertAuthShipping(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary メールアドレス更新 - コード検証
         * @param {VerifyAuthEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VerifyAuthEmail(body: VerifyAuthEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1VerifyAuthEmail(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary パスワードリセット
     * @param {ForgotAuthPasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1ForgotAuthPassword(body: ForgotAuthPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1ForgotAuthPassword(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary トークン検証
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1GetAuth(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1GetAuth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自身のコーディネータ情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1GetAuthCoordinator(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1GetAuthCoordinator(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自身の配送設定取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1GetAuthShipping(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1GetAuthShipping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 管理者情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1GetAuthUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1GetAuthUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary トークン更新
     * @param {RefreshAuthTokenRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1RefreshAuthToken(body: RefreshAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1RefreshAuthToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary デバイストークン登録
     * @param {RegisterAuthDeviceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1RegisterAuthDevice(body: RegisterAuthDeviceRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1RegisterAuthDevice(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パスワードリセット - コード検証
     * @param {ResetAuthPasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1ResetAuthPassword(body: ResetAuthPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1ResetAuthPassword(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary サインイン
     * @param {SignInRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1SignIn(body: SignInRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1SignIn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary サインアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1SignOut(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1SignOut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自身のコーディネータ情報更新
     * @param {UpdateCoordinatorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1UpdateAuthCoordinator(body: UpdateCoordinatorRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1UpdateAuthCoordinator(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary メールアドレス更新
     * @param {UpdateAuthEmailRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1UpdateAuthEmail(body: UpdateAuthEmailRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1UpdateAuthEmail(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パスワード更新
     * @param {UpdateAuthPasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1UpdateAuthPassword(body: UpdateAuthPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1UpdateAuthPassword(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自身の配送設定更新
     * @param {UpsertShippingRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1UpsertAuthShipping(body: UpsertShippingRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1UpsertAuthShipping(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary メールアドレス更新 - コード検証
     * @param {VerifyAuthEmailRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1VerifyAuthEmail(body: VerifyAuthEmailRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1VerifyAuthEmail(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BroadcastApi - axios parameter creator
 * @export
 */
export const BroadcastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ライブ配信中の入力をMP4へ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {ActivateBroadcastMP4Request} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ActivateBroadcastMP4: async (scheduleId: string, body: ActivateBroadcastMP4Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1ActivateBroadcastMP4', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1ActivateBroadcastMP4', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/mp4`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信中の入力をRTMPへ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ActivateBroadcastRTMP: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1ActivateBroadcastRTMP', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/rtmp`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信のふた絵を有効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ActivateBroadcastStaticImage: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1ActivateBroadcastStaticImage', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/static-image`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携を認証
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {AuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthYoutubeBroadcast: async (scheduleId: string, body: AuthYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1AuthYoutubeBroadcast', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1AuthYoutubeBroadcast', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/youtube/auth`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {CallbackAuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CallbackAuthYoutubeBroadcast: async (body: CallbackAuthYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CallbackAuthYoutubeBroadcast', 'body', body)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube/auth/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携
         * @param {CreateYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateYoutubeBroadcast: async (body: CreateYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateYoutubeBroadcast', 'body', body)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信のふた絵を無効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeactivateBroadcastStaticImage: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1DeactivateBroadcastStaticImage', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/static-image`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetBroadcast: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1GetBroadcast', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信アーカイブ動画アップロード用URL取得
         * @param {string} scheduleId 開催スケジュールID
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetBroadcastArchiveUploadUrl: async (scheduleId: string, body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1GetBroadcastArchiveUploadUrl', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetBroadcastArchiveUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/schedules/{scheduleId}/broadcasts/archive`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信入力動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetBroadcastLiveUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetBroadcastLiveUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/schedules/-/broadcasts/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestGetBroadcast: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/guests/schedules/-/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信一時停止
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PauseBroadcast: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1PauseBroadcast', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信一時停止解除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UnpauseBroadcast: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1UnpauseBroadcast', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信用の映像をアップロード
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {UpdateBroadcastArchiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateBroadcastArchive: async (scheduleId: string, body: UpdateBroadcastArchiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1UpdateBroadcastArchive', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateBroadcastArchive', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/archive-video`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BroadcastApi - functional programming interface
 * @export
 */
export const BroadcastApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BroadcastApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ライブ配信中の入力をMP4へ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {ActivateBroadcastMP4Request} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ActivateBroadcastMP4(scheduleId: string, body: ActivateBroadcastMP4Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ActivateBroadcastMP4(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1ActivateBroadcastMP4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信中の入力をRTMPへ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ActivateBroadcastRTMP(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ActivateBroadcastRTMP(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1ActivateBroadcastRTMP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信のふた絵を有効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ActivateBroadcastStaticImage(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ActivateBroadcastStaticImage(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1ActivateBroadcastStaticImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携を認証
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {AuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthYoutubeBroadcast(scheduleId: string, body: AuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthYoutubeBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthYoutubeBroadcast(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1AuthYoutubeBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {CallbackAuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CallbackAuthYoutubeBroadcast(body: CallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CallbackAuthYoutubeBroadcast(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1CallbackAuthYoutubeBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携
         * @param {CreateYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateYoutubeBroadcast(body: CreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateYoutubeBroadcast(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1CreateYoutubeBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信のふた絵を無効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeactivateBroadcastStaticImage(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeactivateBroadcastStaticImage(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1DeactivateBroadcastStaticImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetBroadcast(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetBroadcast(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GetBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信アーカイブ動画アップロード用URL取得
         * @param {string} scheduleId 開催スケジュールID
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetBroadcastArchiveUploadUrl(scheduleId: string, body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetBroadcastArchiveUploadUrl(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GetBroadcastArchiveUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信入力動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetBroadcastLiveUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetBroadcastLiveUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GetBroadcastLiveUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestGetBroadcast(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestGetBroadcast(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GuestGetBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信一時停止
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PauseBroadcast(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PauseBroadcast(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1PauseBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信一時停止解除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UnpauseBroadcast(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UnpauseBroadcast(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1UnpauseBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信用の映像をアップロード
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {UpdateBroadcastArchiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateBroadcastArchive(scheduleId: string, body: UpdateBroadcastArchiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateBroadcastArchive(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1UpdateBroadcastArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BroadcastApi - factory interface
 * @export
 */
export const BroadcastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BroadcastApiFp(configuration)
    return {
        /**
         * 
         * @summary ライブ配信中の入力をMP4へ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {ActivateBroadcastMP4Request} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ActivateBroadcastMP4(scheduleId: string, body: ActivateBroadcastMP4Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1ActivateBroadcastMP4(scheduleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信中の入力をRTMPへ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ActivateBroadcastRTMP(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1ActivateBroadcastRTMP(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信のふた絵を有効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ActivateBroadcastStaticImage(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1ActivateBroadcastStaticImage(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携を認証
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {AuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthYoutubeBroadcast(scheduleId: string, body: AuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthYoutubeBroadcastResponse> {
            return localVarFp.v1AuthYoutubeBroadcast(scheduleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {CallbackAuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CallbackAuthYoutubeBroadcast(body: CallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuestBroadcastResponse> {
            return localVarFp.v1CallbackAuthYoutubeBroadcast(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携
         * @param {CreateYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateYoutubeBroadcast(body: CreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CreateYoutubeBroadcast(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信のふた絵を無効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeactivateBroadcastStaticImage(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeactivateBroadcastStaticImage(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetBroadcast(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<BroadcastResponse> {
            return localVarFp.v1GetBroadcast(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信アーカイブ動画アップロード用URL取得
         * @param {string} scheduleId 開催スケジュールID
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetBroadcastArchiveUploadUrl(scheduleId: string, body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetBroadcastArchiveUploadUrl(scheduleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信入力動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetBroadcastLiveUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetBroadcastLiveUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestGetBroadcast(options?: RawAxiosRequestConfig): AxiosPromise<GuestBroadcastResponse> {
            return localVarFp.v1GuestGetBroadcast(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信一時停止
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PauseBroadcast(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1PauseBroadcast(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信一時停止解除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UnpauseBroadcast(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UnpauseBroadcast(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信用の映像をアップロード
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {UpdateBroadcastArchiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateBroadcastArchive(scheduleId: string, body: UpdateBroadcastArchiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateBroadcastArchive(scheduleId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BroadcastApi - object-oriented interface
 * @export
 * @class BroadcastApi
 * @extends {BaseAPI}
 */
export class BroadcastApi extends BaseAPI {
    /**
     * 
     * @summary ライブ配信中の入力をMP4へ切り替え
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {ActivateBroadcastMP4Request} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1ActivateBroadcastMP4(scheduleId: string, body: ActivateBroadcastMP4Request, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1ActivateBroadcastMP4(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信中の入力をRTMPへ切り替え
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1ActivateBroadcastRTMP(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1ActivateBroadcastRTMP(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信のふた絵を有効化
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1ActivateBroadcastStaticImage(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1ActivateBroadcastStaticImage(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信のYoutube連携を認証
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {AuthYoutubeBroadcastRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1AuthYoutubeBroadcast(scheduleId: string, body: AuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1AuthYoutubeBroadcast(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信のYoutube認証後処理
     * @param {CallbackAuthYoutubeBroadcastRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1CallbackAuthYoutubeBroadcast(body: CallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1CallbackAuthYoutubeBroadcast(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信のYoutube連携
     * @param {CreateYoutubeBroadcastRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1CreateYoutubeBroadcast(body: CreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1CreateYoutubeBroadcast(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信のふた絵を無効化
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1DeactivateBroadcastStaticImage(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1DeactivateBroadcastStaticImage(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信取得
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GetBroadcast(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GetBroadcast(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信アーカイブ動画アップロード用URL取得
     * @param {string} scheduleId 開催スケジュールID
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GetBroadcastArchiveUploadUrl(scheduleId: string, body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GetBroadcastArchiveUploadUrl(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信入力動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GetBroadcastLiveUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GetBroadcastLiveUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ゲスト用ライブ配信情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GuestGetBroadcast(options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GuestGetBroadcast(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信一時停止
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1PauseBroadcast(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1PauseBroadcast(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信一時停止解除
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1UnpauseBroadcast(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1UnpauseBroadcast(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信用の映像をアップロード
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {UpdateBroadcastArchiveRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1UpdateBroadcastArchive(scheduleId: string, body: UpdateBroadcastArchiveRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1UpdateBroadcastArchive(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 商品種別登録
         * @param {CreateCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateCategory: async (body: CreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateCategory', 'body', body)
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品種別削除
         * @param {string} categoryId 商品種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1DeleteCategory', 'categoryId', categoryId)
            const localVarPath = `/v1/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListCategories: async (limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品種別更新
         * @param {string} categoryId 商品種別ID
         * @param {UpdateCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCategory: async (categoryId: string, body: UpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1UpdateCategory', 'categoryId', categoryId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateCategory', 'body', body)
            const localVarPath = `/v1/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 商品種別登録
         * @param {CreateCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateCategory(body: CreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateCategory(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1CreateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品種別削除
         * @param {string} categoryId 商品種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1DeleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListCategories(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListCategories(limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1ListCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品種別更新
         * @param {string} categoryId 商品種別ID
         * @param {UpdateCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateCategory(categoryId: string, body: UpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateCategory(categoryId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1UpdateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary 商品種別登録
         * @param {CreateCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateCategory(body: CreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.v1CreateCategory(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品種別削除
         * @param {string} categoryId 商品種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListCategories(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<CategoriesResponse> {
            return localVarFp.v1ListCategories(limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品種別更新
         * @param {string} categoryId 商品種別ID
         * @param {UpdateCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCategory(categoryId: string, body: UpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateCategory(categoryId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary 商品種別登録
     * @param {CreateCategoryRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1CreateCategory(body: CreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1CreateCategory(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品種別削除
     * @param {string} categoryId 商品種別ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1DeleteCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1DeleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品種別一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1ListCategories(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1ListCategories(limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品種別更新
     * @param {string} categoryId 商品種別ID
     * @param {UpdateCategoryRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1UpdateCategory(categoryId: string, body: UpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1UpdateCategory(categoryId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary お問い合わせ登録
         * @param {CreateContactRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateContact: async (body: CreateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateContact', 'body', body)
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ削除
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteContact: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1DeleteContact', 'contactId', contactId)
            const localVarPath = `/v1/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ取得
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetContact: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1GetContact', 'contactId', contactId)
            const localVarPath = `/v1/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListContacts: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ更新
         * @param {string} contactId お問い合わせID
         * @param {UpdateContactRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateContact: async (contactId: string, body: UpdateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1UpdateContact', 'contactId', contactId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateContact', 'body', body)
            const localVarPath = `/v1/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary お問い合わせ登録
         * @param {CreateContactRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateContact(body: CreateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateContact(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1CreateContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ削除
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteContact(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteContact(contactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1DeleteContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ取得
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetContact(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetContact(contactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1GetContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListContacts(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListContacts(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1ListContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ更新
         * @param {string} contactId お問い合わせID
         * @param {UpdateContactRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateContact(contactId: string, body: UpdateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateContact(contactId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1UpdateContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * 
         * @summary お問い合わせ登録
         * @param {CreateContactRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateContact(body: CreateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactResponse> {
            return localVarFp.v1CreateContact(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ削除
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteContact(contactId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteContact(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ取得
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetContact(contactId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactResponse> {
            return localVarFp.v1GetContact(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListContacts(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ContactsResponse> {
            return localVarFp.v1ListContacts(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ更新
         * @param {string} contactId お問い合わせID
         * @param {UpdateContactRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateContact(contactId: string, body: UpdateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateContact(contactId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary お問い合わせ登録
     * @param {CreateContactRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1CreateContact(body: CreateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1CreateContact(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ削除
     * @param {string} contactId お問い合わせID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1DeleteContact(contactId: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1DeleteContact(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ取得
     * @param {string} contactId お問い合わせID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1GetContact(contactId: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1GetContact(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1ListContacts(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1ListContacts(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ更新
     * @param {string} contactId お問い合わせID
     * @param {UpdateContactRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1UpdateContact(contactId: string, body: UpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1UpdateContact(contactId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactCategoryApi - axios parameter creator
 * @export
 */
export const ContactCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary お問い合わせ種別取得
         * @param {string} contactCategoryId お問い合わせ種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetContactCategory: async (contactCategoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactCategoryId' is not null or undefined
            assertParamExists('v1GetContactCategory', 'contactCategoryId', contactCategoryId)
            const localVarPath = `/v1/contact-categories/{contactCategoryId}`
                .replace(`{${"contactCategoryId"}}`, encodeURIComponent(String(contactCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListContactCategories: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contact-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactCategoryApi - functional programming interface
 * @export
 */
export const ContactCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary お問い合わせ種別取得
         * @param {string} contactCategoryId お問い合わせ種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetContactCategory(contactCategoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetContactCategory(contactCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactCategoryApi.v1GetContactCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListContactCategories(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListContactCategories(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactCategoryApi.v1ListContactCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactCategoryApi - factory interface
 * @export
 */
export const ContactCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactCategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary お問い合わせ種別取得
         * @param {string} contactCategoryId お問い合わせ種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetContactCategory(contactCategoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactCategoryResponse> {
            return localVarFp.v1GetContactCategory(contactCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListContactCategories(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ContactCategoriesResponse> {
            return localVarFp.v1ListContactCategories(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactCategoryApi - object-oriented interface
 * @export
 * @class ContactCategoryApi
 * @extends {BaseAPI}
 */
export class ContactCategoryApi extends BaseAPI {
    /**
     * 
     * @summary お問い合わせ種別取得
     * @param {string} contactCategoryId お問い合わせ種別ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactCategoryApi
     */
    public v1GetContactCategory(contactCategoryId: string, options?: RawAxiosRequestConfig) {
        return ContactCategoryApiFp(this.configuration).v1GetContactCategory(contactCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ種別一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactCategoryApi
     */
    public v1ListContactCategories(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ContactCategoryApiFp(this.configuration).v1ListContactCategories(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoordinatorApi - axios parameter creator
 * @export
 */
export const CoordinatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary コーディネータ登録
         * @param {CreateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateCoordinator: async (body: CreateCoordinatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateCoordinator', 'body', body)
            const localVarPath = `/v1/coordinators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータ退会
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteCoordinator: async (coordinatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1DeleteCoordinator', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータ取得
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinator: async (coordinatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1GetCoordinator', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータ購入特典動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorBonusVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetCoordinatorBonusVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/coordinators/bonus-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータヘッダー画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorHeaderUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetCoordinatorHeaderUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/coordinators/header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータ紹介動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorPromotionVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetCoordinatorPromotionVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/coordinators/promotion-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータサムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorThumbnailUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetCoordinatorThumbnailUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/coordinators/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListCoordinators: async (limit?: number, offset?: number, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/coordinators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 関連付けられた生産者一覧
         * @param {string} coordinatorId コーディネータID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListRelatedProducers: async (coordinatorId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1ListRelatedProducers', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/producers`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータ更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpdateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCoordinator: async (coordinatorId: string, body: UpdateCoordinatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1UpdateCoordinator', 'coordinatorId', coordinatorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateCoordinator', 'body', body)
            const localVarPath = `/v1/coordinators/{coordinatorId}`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータメールアドレス更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpdateCoordinatorEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCoordinatorEmail: async (coordinatorId: string, body: UpdateCoordinatorEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1UpdateCoordinatorEmail', 'coordinatorId', coordinatorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateCoordinatorEmail', 'body', body)
            const localVarPath = `/v1/coordinators/{coordinatorId}/email`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary コーディネータパスワード更新(ランダム生成)
         * @param {string} coordinatorId コーディネータID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCoordinatorPassword: async (coordinatorId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1UpdateCoordinatorPassword', 'coordinatorId', coordinatorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateCoordinatorPassword', 'body', body)
            const localVarPath = `/v1/coordinators/{coordinatorId}/password`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoordinatorApi - functional programming interface
 * @export
 */
export const CoordinatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoordinatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary コーディネータ登録
         * @param {CreateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateCoordinator(body: CreateCoordinatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoordinatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateCoordinator(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1CreateCoordinator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータ退会
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteCoordinator(coordinatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteCoordinator(coordinatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1DeleteCoordinator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータ取得
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetCoordinator(coordinatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoordinatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetCoordinator(coordinatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1GetCoordinator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータ購入特典動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetCoordinatorBonusVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetCoordinatorBonusVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1GetCoordinatorBonusVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータヘッダー画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetCoordinatorHeaderUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetCoordinatorHeaderUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1GetCoordinatorHeaderUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータ紹介動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetCoordinatorPromotionVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetCoordinatorPromotionVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1GetCoordinatorPromotionVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータサムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetCoordinatorThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetCoordinatorThumbnailUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1GetCoordinatorThumbnailUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListCoordinators(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoordinatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListCoordinators(limit, offset, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1ListCoordinators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 関連付けられた生産者一覧
         * @param {string} coordinatorId コーディネータID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListRelatedProducers(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListRelatedProducers(coordinatorId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1ListRelatedProducers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータ更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpdateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateCoordinator(coordinatorId: string, body: UpdateCoordinatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateCoordinator(coordinatorId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1UpdateCoordinator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータメールアドレス更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpdateCoordinatorEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateCoordinatorEmail(coordinatorId: string, body: UpdateCoordinatorEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateCoordinatorEmail(coordinatorId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1UpdateCoordinatorEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary コーディネータパスワード更新(ランダム生成)
         * @param {string} coordinatorId コーディネータID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateCoordinatorPassword(coordinatorId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateCoordinatorPassword(coordinatorId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1UpdateCoordinatorPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoordinatorApi - factory interface
 * @export
 */
export const CoordinatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoordinatorApiFp(configuration)
    return {
        /**
         * 
         * @summary コーディネータ登録
         * @param {CreateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateCoordinator(body: CreateCoordinatorRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoordinatorResponse> {
            return localVarFp.v1CreateCoordinator(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータ退会
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteCoordinator(coordinatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteCoordinator(coordinatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータ取得
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinator(coordinatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<CoordinatorResponse> {
            return localVarFp.v1GetCoordinator(coordinatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータ購入特典動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorBonusVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetCoordinatorBonusVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータヘッダー画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorHeaderUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetCoordinatorHeaderUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータ紹介動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorPromotionVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetCoordinatorPromotionVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータサムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetCoordinatorThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetCoordinatorThumbnailUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListCoordinators(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<CoordinatorsResponse> {
            return localVarFp.v1ListCoordinators(limit, offset, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 関連付けられた生産者一覧
         * @param {string} coordinatorId コーディネータID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListRelatedProducers(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProducersResponse> {
            return localVarFp.v1ListRelatedProducers(coordinatorId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータ更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpdateCoordinatorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCoordinator(coordinatorId: string, body: UpdateCoordinatorRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateCoordinator(coordinatorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータメールアドレス更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpdateCoordinatorEmailRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCoordinatorEmail(coordinatorId: string, body: UpdateCoordinatorEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateCoordinatorEmail(coordinatorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary コーディネータパスワード更新(ランダム生成)
         * @param {string} coordinatorId コーディネータID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateCoordinatorPassword(coordinatorId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateCoordinatorPassword(coordinatorId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoordinatorApi - object-oriented interface
 * @export
 * @class CoordinatorApi
 * @extends {BaseAPI}
 */
export class CoordinatorApi extends BaseAPI {
    /**
     * 
     * @summary コーディネータ登録
     * @param {CreateCoordinatorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1CreateCoordinator(body: CreateCoordinatorRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1CreateCoordinator(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータ退会
     * @param {string} coordinatorId コーディネータID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1DeleteCoordinator(coordinatorId: string, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1DeleteCoordinator(coordinatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータ取得
     * @param {string} coordinatorId コーディネータID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1GetCoordinator(coordinatorId: string, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1GetCoordinator(coordinatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータ購入特典動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1GetCoordinatorBonusVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1GetCoordinatorBonusVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータヘッダー画像アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1GetCoordinatorHeaderUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1GetCoordinatorHeaderUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータ紹介動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1GetCoordinatorPromotionVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1GetCoordinatorPromotionVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータサムネイルアップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1GetCoordinatorThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1GetCoordinatorThumbnailUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1ListCoordinators(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1ListCoordinators(limit, offset, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 関連付けられた生産者一覧
     * @param {string} coordinatorId コーディネータID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1ListRelatedProducers(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1ListRelatedProducers(coordinatorId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータ更新
     * @param {string} coordinatorId コーディネータID
     * @param {UpdateCoordinatorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1UpdateCoordinator(coordinatorId: string, body: UpdateCoordinatorRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1UpdateCoordinator(coordinatorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータメールアドレス更新
     * @param {string} coordinatorId コーディネータID
     * @param {UpdateCoordinatorEmailRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1UpdateCoordinatorEmail(coordinatorId: string, body: UpdateCoordinatorEmailRequest, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1UpdateCoordinatorEmail(coordinatorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary コーディネータパスワード更新(ランダム生成)
     * @param {string} coordinatorId コーディネータID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1UpdateCoordinatorPassword(coordinatorId: string, body: object, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1UpdateCoordinatorPassword(coordinatorId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperienceApi - axios parameter creator
 * @export
 */
export const ExperienceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 体験登録
         * @param {CreateExperienceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateExperience: async (body: CreateExperienceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateExperience', 'body', body)
            const localVarPath = `/v1/experiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験削除
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteExperience: async (experienceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceId' is not null or undefined
            assertParamExists('v1DeleteExperience', 'experienceId', experienceId)
            const localVarPath = `/v1/experiences/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験取得
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetExperience: async (experienceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceId' is not null or undefined
            assertParamExists('v1GetExperience', 'experienceId', experienceId)
            const localVarPath = `/v1/experiences/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetExperienceImageUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetExperienceImageUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/experiences/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetExperienceVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetExperienceVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/experiences/video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] 体験名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListExperiences: async (limit?: number, offset?: number, producerId?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/experiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (producerId !== undefined) {
                localVarQueryParameter['producerId'] = producerId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験更新
         * @param {string} experienceId 体験ID
         * @param {UpdateExperienceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateExperience: async (experienceId: string, body: UpdateExperienceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceId' is not null or undefined
            assertParamExists('v1UpdateExperience', 'experienceId', experienceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateExperience', 'body', body)
            const localVarPath = `/v1/experiences/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperienceApi - functional programming interface
 * @export
 */
export const ExperienceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperienceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 体験登録
         * @param {CreateExperienceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateExperience(body: CreateExperienceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateExperience(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1CreateExperience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験削除
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteExperience(experienceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteExperience(experienceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1DeleteExperience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験取得
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetExperience(experienceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetExperience(experienceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1GetExperience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetExperienceImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetExperienceImageUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1GetExperienceImageUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetExperienceVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetExperienceVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1GetExperienceVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] 体験名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListExperiences(limit?: number, offset?: number, producerId?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListExperiences(limit, offset, producerId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1ListExperiences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験更新
         * @param {string} experienceId 体験ID
         * @param {UpdateExperienceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateExperience(experienceId: string, body: UpdateExperienceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateExperience(experienceId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1UpdateExperience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExperienceApi - factory interface
 * @export
 */
export const ExperienceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperienceApiFp(configuration)
    return {
        /**
         * 
         * @summary 体験登録
         * @param {CreateExperienceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateExperience(body: CreateExperienceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExperienceResponse> {
            return localVarFp.v1CreateExperience(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験削除
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteExperience(experienceId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteExperience(experienceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験取得
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetExperience(experienceId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExperienceResponse> {
            return localVarFp.v1GetExperience(experienceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetExperienceImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetExperienceImageUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetExperienceVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetExperienceVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] 体験名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListExperiences(limit?: number, offset?: number, producerId?: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ListExperiences(limit, offset, producerId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験更新
         * @param {string} experienceId 体験ID
         * @param {UpdateExperienceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateExperience(experienceId: string, body: UpdateExperienceRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateExperience(experienceId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperienceApi - object-oriented interface
 * @export
 * @class ExperienceApi
 * @extends {BaseAPI}
 */
export class ExperienceApi extends BaseAPI {
    /**
     * 
     * @summary 体験登録
     * @param {CreateExperienceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1CreateExperience(body: CreateExperienceRequest, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1CreateExperience(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験削除
     * @param {string} experienceId 体験ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1DeleteExperience(experienceId: string, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1DeleteExperience(experienceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験取得
     * @param {string} experienceId 体験ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1GetExperience(experienceId: string, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1GetExperience(experienceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験画像アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1GetExperienceImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1GetExperienceImageUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1GetExperienceVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1GetExperienceVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [producerId] 生産者ID
     * @param {string} [name] 体験名(あいまい検索)(64文字以内)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1ListExperiences(limit?: number, offset?: number, producerId?: string, name?: string, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1ListExperiences(limit, offset, producerId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験更新
     * @param {string} experienceId 体験ID
     * @param {UpdateExperienceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1UpdateExperience(experienceId: string, body: UpdateExperienceRequest, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1UpdateExperience(experienceId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperienceTypeApi - axios parameter creator
 * @export
 */
export const ExperienceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 体験種別登録
         * @param {CreateExperienceTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateExperienceType: async (body: CreateExperienceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateExperienceType', 'body', body)
            const localVarPath = `/v1/experience-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験種別削除
         * @param {string} experienceTypeId 体験種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteExperienceType: async (experienceTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTypeId' is not null or undefined
            assertParamExists('v1DeleteExperienceType', 'experienceTypeId', experienceTypeId)
            const localVarPath = `/v1/experience-types/{experienceTypeId}`
                .replace(`{${"experienceTypeId"}}`, encodeURIComponent(String(experienceTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListExperienceTypes: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/experience-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 体験種別更新
         * @param {string} experienceTypeId 体験種別ID
         * @param {UpdateExperienceTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateExperienceType: async (experienceTypeId: string, body: UpdateExperienceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTypeId' is not null or undefined
            assertParamExists('v1UpdateExperienceType', 'experienceTypeId', experienceTypeId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateExperienceType', 'body', body)
            const localVarPath = `/v1/experience-types/{experienceTypeId}`
                .replace(`{${"experienceTypeId"}}`, encodeURIComponent(String(experienceTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperienceTypeApi - functional programming interface
 * @export
 */
export const ExperienceTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperienceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 体験種別登録
         * @param {CreateExperienceTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateExperienceType(body: CreateExperienceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateExperienceType(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1CreateExperienceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験種別削除
         * @param {string} experienceTypeId 体験種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteExperienceType(experienceTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteExperienceType(experienceTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1DeleteExperienceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListExperienceTypes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListExperienceTypes(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1ListExperienceTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 体験種別更新
         * @param {string} experienceTypeId 体験種別ID
         * @param {UpdateExperienceTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateExperienceType(experienceTypeId: string, body: UpdateExperienceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateExperienceType(experienceTypeId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1UpdateExperienceType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExperienceTypeApi - factory interface
 * @export
 */
export const ExperienceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperienceTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary 体験種別登録
         * @param {CreateExperienceTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateExperienceType(body: CreateExperienceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExperienceTypeResponse> {
            return localVarFp.v1CreateExperienceType(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験種別削除
         * @param {string} experienceTypeId 体験種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteExperienceType(experienceTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteExperienceType(experienceTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListExperienceTypes(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ExperienceTypesResponse> {
            return localVarFp.v1ListExperienceTypes(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 体験種別更新
         * @param {string} experienceTypeId 体験種別ID
         * @param {UpdateExperienceTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateExperienceType(experienceTypeId: string, body: UpdateExperienceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateExperienceType(experienceTypeId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperienceTypeApi - object-oriented interface
 * @export
 * @class ExperienceTypeApi
 * @extends {BaseAPI}
 */
export class ExperienceTypeApi extends BaseAPI {
    /**
     * 
     * @summary 体験種別登録
     * @param {CreateExperienceTypeRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1CreateExperienceType(body: CreateExperienceTypeRequest, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1CreateExperienceType(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験種別削除
     * @param {string} experienceTypeId 体験種別ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1DeleteExperienceType(experienceTypeId: string, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1DeleteExperienceType(experienceTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験種別一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1ListExperienceTypes(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1ListExperienceTypes(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 体験種別更新
     * @param {string} experienceTypeId 体験種別ID
     * @param {UpdateExperienceTypeRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1UpdateExperienceType(experienceTypeId: string, body: UpdateExperienceTypeRequest, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1UpdateExperienceType(experienceTypeId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GuestApi - axios parameter creator
 * @export
 */
export const GuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {CallbackAuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CallbackAuthYoutubeBroadcast: async (body: CallbackAuthYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CallbackAuthYoutubeBroadcast', 'body', body)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube/auth/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携
         * @param {CreateYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateYoutubeBroadcast: async (body: CreateYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateYoutubeBroadcast', 'body', body)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestGetBroadcast: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/guests/schedules/-/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestApi - functional programming interface
 * @export
 */
export const GuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {CallbackAuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CallbackAuthYoutubeBroadcast(body: CallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CallbackAuthYoutubeBroadcast(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.v1CallbackAuthYoutubeBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携
         * @param {CreateYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateYoutubeBroadcast(body: CreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateYoutubeBroadcast(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.v1CreateYoutubeBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestGetBroadcast(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestGetBroadcast(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.v1GuestGetBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuestApi - factory interface
 * @export
 */
export const GuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestApiFp(configuration)
    return {
        /**
         * 
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {CallbackAuthYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CallbackAuthYoutubeBroadcast(body: CallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuestBroadcastResponse> {
            return localVarFp.v1CallbackAuthYoutubeBroadcast(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェライブ配信のYoutube連携
         * @param {CreateYoutubeBroadcastRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateYoutubeBroadcast(body: CreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CreateYoutubeBroadcast(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestGetBroadcast(options?: RawAxiosRequestConfig): AxiosPromise<GuestBroadcastResponse> {
            return localVarFp.v1GuestGetBroadcast(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestApi - object-oriented interface
 * @export
 * @class GuestApi
 * @extends {BaseAPI}
 */
export class GuestApi extends BaseAPI {
    /**
     * 
     * @summary マルシェライブ配信のYoutube認証後処理
     * @param {CallbackAuthYoutubeBroadcastRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public v1CallbackAuthYoutubeBroadcast(body: CallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).v1CallbackAuthYoutubeBroadcast(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェライブ配信のYoutube連携
     * @param {CreateYoutubeBroadcastRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public v1CreateYoutubeBroadcast(body: CreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).v1CreateYoutubeBroadcast(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ゲスト用ライブ配信情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public v1GuestGetBroadcast(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).v1GuestGetBroadcast(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LiveApi - axios parameter creator
 * @export
 */
export const LiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary マルシェタイムテーブル登録
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {CreateLiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateLive: async (scheduleId: string, body: CreateLiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1CreateLive', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateLive', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/lives`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェタイムテーブル削除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} liveId マルシェタイムテーブルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteLive: async (scheduleId: string, liveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1DeleteLive', 'scheduleId', scheduleId)
            // verify required parameter 'liveId' is not null or undefined
            assertParamExists('v1DeleteLive', 'liveId', liveId)
            const localVarPath = `/v1/schedules/{scheduleId}/lives/{liveId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"liveId"}}`, encodeURIComponent(String(liveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェタイムテーブル一覧取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListLives: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1ListLives', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/lives`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェタイムテーブル更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} liveId マルシェタイムテーブルID
         * @param {UpdateLiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateLive: async (scheduleId: string, liveId: string, body: UpdateLiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1UpdateLive', 'scheduleId', scheduleId)
            // verify required parameter 'liveId' is not null or undefined
            assertParamExists('v1UpdateLive', 'liveId', liveId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateLive', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/lives/{liveId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"liveId"}}`, encodeURIComponent(String(liveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveApi - functional programming interface
 * @export
 */
export const LiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary マルシェタイムテーブル登録
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {CreateLiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateLive(scheduleId: string, body: CreateLiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateLive(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1CreateLive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェタイムテーブル削除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} liveId マルシェタイムテーブルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteLive(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteLive(scheduleId, liveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1DeleteLive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェタイムテーブル一覧取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListLives(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListLives(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1ListLives']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェタイムテーブル更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} liveId マルシェタイムテーブルID
         * @param {UpdateLiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateLive(scheduleId: string, liveId: string, body: UpdateLiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateLive(scheduleId, liveId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1UpdateLive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveApi - factory interface
 * @export
 */
export const LiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveApiFp(configuration)
    return {
        /**
         * 
         * @summary マルシェタイムテーブル登録
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {CreateLiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateLive(scheduleId: string, body: CreateLiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<LiveResponse> {
            return localVarFp.v1CreateLive(scheduleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェタイムテーブル削除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} liveId マルシェタイムテーブルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteLive(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteLive(scheduleId, liveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェタイムテーブル一覧取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListLives(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<LivesResponse> {
            return localVarFp.v1ListLives(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェタイムテーブル更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} liveId マルシェタイムテーブルID
         * @param {UpdateLiveRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateLive(scheduleId: string, liveId: string, body: UpdateLiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateLive(scheduleId, liveId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveApi - object-oriented interface
 * @export
 * @class LiveApi
 * @extends {BaseAPI}
 */
export class LiveApi extends BaseAPI {
    /**
     * 
     * @summary マルシェタイムテーブル登録
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {CreateLiveRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1CreateLive(scheduleId: string, body: CreateLiveRequest, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1CreateLive(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェタイムテーブル削除
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {string} liveId マルシェタイムテーブルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1DeleteLive(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1DeleteLive(scheduleId, liveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェタイムテーブル一覧取得
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1ListLives(scheduleId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1ListLives(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェタイムテーブル更新
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {string} liveId マルシェタイムテーブルID
     * @param {UpdateLiveRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1UpdateLive(scheduleId: string, liveId: string, body: UpdateLiveRequest, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1UpdateLive(scheduleId, liveId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary メッセージ取得
         * @param {string} messageId メッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetMessage: async (messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('v1GetMessage', 'messageId', messageId)
            const localVarPath = `/v1/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary メッセージ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:type,read,receivedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListMessages: async (limit?: number, offset?: number, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary メッセージ取得
         * @param {string} messageId メッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetMessage(messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetMessage(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.v1GetMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary メッセージ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:type,read,receivedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListMessages(limit?: number, offset?: number, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListMessages(limit, offset, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.v1ListMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * 
         * @summary メッセージ取得
         * @param {string} messageId メッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetMessage(messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.v1GetMessage(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary メッセージ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:type,read,receivedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListMessages(limit?: number, offset?: number, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<MessagesResponse> {
            return localVarFp.v1ListMessages(limit, offset, orders, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * 
     * @summary メッセージ取得
     * @param {string} messageId メッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public v1GetMessage(messageId: string, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).v1GetMessage(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary メッセージ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:type,read,receivedAt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public v1ListMessages(limit?: number, offset?: number, orders?: string, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).v1ListMessages(limit, offset, orders, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary お知らせ登録
         * @param {CreateNotificationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateNotification: async (body: CreateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateNotification', 'body', body)
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お知らせ削除
         * @param {string} notificationId お知らせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteNotification: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('v1DeleteNotification', 'notificationId', notificationId)
            const localVarPath = `/v1/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お知らせ取得
         * @param {string} notificationId お知らせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetNotification: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('v1GetNotification', 'notificationId', notificationId)
            const localVarPath = `/v1/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お知らせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {number} [since] 取得開始日時(unixtime)
         * @param {number} [until] 取得終了日時(unixtime)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド: title,public,publishedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListNotifications: async (limit?: number, offset?: number, since?: number, until?: number, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お知らせ更新
         * @param {string} notificationId お知らせID
         * @param {UpdateNotificationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateNotification: async (notificationId: string, body: UpdateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('v1UpdateNotification', 'notificationId', notificationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateNotification', 'body', body)
            const localVarPath = `/v1/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary お知らせ登録
         * @param {CreateNotificationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateNotification(body: CreateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateNotification(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1CreateNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お知らせ削除
         * @param {string} notificationId お知らせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteNotification(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteNotification(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1DeleteNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お知らせ取得
         * @param {string} notificationId お知らせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetNotification(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetNotification(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1GetNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お知らせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {number} [since] 取得開始日時(unixtime)
         * @param {number} [until] 取得終了日時(unixtime)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド: title,public,publishedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListNotifications(limit?: number, offset?: number, since?: number, until?: number, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListNotifications(limit, offset, since, until, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1ListNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お知らせ更新
         * @param {string} notificationId お知らせID
         * @param {UpdateNotificationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateNotification(notificationId: string, body: UpdateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateNotification(notificationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1UpdateNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @summary お知らせ登録
         * @param {CreateNotificationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateNotification(body: CreateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationResponse> {
            return localVarFp.v1CreateNotification(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お知らせ削除
         * @param {string} notificationId お知らせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteNotification(notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お知らせ取得
         * @param {string} notificationId お知らせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetNotification(notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationResponse> {
            return localVarFp.v1GetNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お知らせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {number} [since] 取得開始日時(unixtime)
         * @param {number} [until] 取得終了日時(unixtime)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド: title,public,publishedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListNotifications(limit?: number, offset?: number, since?: number, until?: number, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsResponse> {
            return localVarFp.v1ListNotifications(limit, offset, since, until, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お知らせ更新
         * @param {string} notificationId お知らせID
         * @param {UpdateNotificationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateNotification(notificationId: string, body: UpdateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateNotification(notificationId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @summary お知らせ登録
     * @param {CreateNotificationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1CreateNotification(body: CreateNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1CreateNotification(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お知らせ削除
     * @param {string} notificationId お知らせID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1DeleteNotification(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1DeleteNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お知らせ取得
     * @param {string} notificationId お知らせID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1GetNotification(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1GetNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お知らせ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {number} [since] 取得開始日時(unixtime)
     * @param {number} [until] 取得終了日時(unixtime)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド: title,public,publishedAt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1ListNotifications(limit?: number, offset?: number, since?: number, until?: number, orders?: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1ListNotifications(limit, offset, since, until, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お知らせ更新
     * @param {string} notificationId お知らせID
     * @param {UpdateNotificationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1UpdateNotification(notificationId: string, body: UpdateNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1UpdateNotification(notificationId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 注文キャンセル
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CancelOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1CancelOrder', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}/cancel`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文確定
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CaptureOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1CaptureOrder', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}/capture`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文対応完了
         * @param {string} orderId 注文ID
         * @param {CompleteOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CompleteOrder: async (orderId: string, body: CompleteOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1CompleteOrder', 'orderId', orderId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CompleteOrder', 'body', body)
            const localVarPath = `/v1/orders/{orderId}/complete`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文下書き保存
         * @param {string} orderId 注文ID
         * @param {DraftOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DraftOrder: async (orderId: string, body: DraftOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1DraftOrder', 'orderId', orderId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1DraftOrder', 'body', body)
            const localVarPath = `/v1/orders/{orderId}/draft`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文履歴のCSV出力
         * @param {ExportOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExportOrders: async (body: ExportOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1ExportOrders', 'body', body)
            const localVarPath = `/v1/orders/-/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文取得
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1GetOrder', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:paymentStatus,fulfillmentStatus,orderedAt,paidAt,deliveredAt,canceledAt,createdAt,updatedAt, 
         * @param {number} [status] 注文ステータス ・複数指定時は&#x60;,&#x60;区切り ・デフォルト:2(受注待ち),3(発送準備中),4(発送完了),5(完了) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListOrders: async (limit?: number, offset?: number, orders?: string, status?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文の返金依頼
         * @param {string} orderId 注文ID
         * @param {RefundOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundOrder: async (orderId: string, body: RefundOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1RefundOrder', 'orderId', orderId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1RefundOrder', 'body', body)
            const localVarPath = `/v1/orders/{orderId}/refund`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 注文配送状況更新
         * @param {string} orderId 注文ID
         * @param {string} fulfillmentId 注文配送ID
         * @param {UpdateOrderFulfillmentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateOrderFulfillment: async (orderId: string, fulfillmentId: string, body: UpdateOrderFulfillmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1UpdateOrderFulfillment', 'orderId', orderId)
            // verify required parameter 'fulfillmentId' is not null or undefined
            assertParamExists('v1UpdateOrderFulfillment', 'fulfillmentId', fulfillmentId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateOrderFulfillment', 'body', body)
            const localVarPath = `/v1/orders/{orderId}/fulfillments/{fulfillmentId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"fulfillmentId"}}`, encodeURIComponent(String(fulfillmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 注文キャンセル
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CancelOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CancelOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1CancelOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文確定
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CaptureOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CaptureOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1CaptureOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文対応完了
         * @param {string} orderId 注文ID
         * @param {CompleteOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CompleteOrder(orderId: string, body: CompleteOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CompleteOrder(orderId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1CompleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文下書き保存
         * @param {string} orderId 注文ID
         * @param {DraftOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DraftOrder(orderId: string, body: DraftOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DraftOrder(orderId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1DraftOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文履歴のCSV出力
         * @param {ExportOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExportOrders(body: ExportOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExportOrders(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1ExportOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文取得
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1GetOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:paymentStatus,fulfillmentStatus,orderedAt,paidAt,deliveredAt,canceledAt,createdAt,updatedAt, 
         * @param {number} [status] 注文ステータス ・複数指定時は&#x60;,&#x60;区切り ・デフォルト:2(受注待ち),3(発送準備中),4(発送完了),5(完了) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListOrders(limit?: number, offset?: number, orders?: string, status?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListOrders(limit, offset, orders, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1ListOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文の返金依頼
         * @param {string} orderId 注文ID
         * @param {RefundOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundOrder(orderId: string, body: RefundOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundOrder(orderId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1RefundOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 注文配送状況更新
         * @param {string} orderId 注文ID
         * @param {string} fulfillmentId 注文配送ID
         * @param {UpdateOrderFulfillmentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateOrderFulfillment(orderId: string, fulfillmentId: string, body: UpdateOrderFulfillmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateOrderFulfillment(orderId, fulfillmentId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1UpdateOrderFulfillment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @summary 注文キャンセル
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CancelOrder(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1CancelOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文確定
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CaptureOrder(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1CaptureOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文対応完了
         * @param {string} orderId 注文ID
         * @param {CompleteOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CompleteOrder(orderId: string, body: CompleteOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1CompleteOrder(orderId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文下書き保存
         * @param {string} orderId 注文ID
         * @param {DraftOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DraftOrder(orderId: string, body: DraftOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DraftOrder(orderId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文履歴のCSV出力
         * @param {ExportOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExportOrders(body: ExportOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.v1ExportOrders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文取得
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetOrder(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.v1GetOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:paymentStatus,fulfillmentStatus,orderedAt,paidAt,deliveredAt,canceledAt,createdAt,updatedAt, 
         * @param {number} [status] 注文ステータス ・複数指定時は&#x60;,&#x60;区切り ・デフォルト:2(受注待ち),3(発送準備中),4(発送完了),5(完了) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListOrders(limit?: number, offset?: number, orders?: string, status?: number, options?: RawAxiosRequestConfig): AxiosPromise<OrdersResponse> {
            return localVarFp.v1ListOrders(limit, offset, orders, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文の返金依頼
         * @param {string} orderId 注文ID
         * @param {RefundOrderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundOrder(orderId: string, body: RefundOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1RefundOrder(orderId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 注文配送状況更新
         * @param {string} orderId 注文ID
         * @param {string} fulfillmentId 注文配送ID
         * @param {UpdateOrderFulfillmentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateOrderFulfillment(orderId: string, fulfillmentId: string, body: UpdateOrderFulfillmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateOrderFulfillment(orderId, fulfillmentId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @summary 注文キャンセル
     * @param {string} orderId 注文ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1CancelOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1CancelOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文確定
     * @param {string} orderId 注文ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1CaptureOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1CaptureOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文対応完了
     * @param {string} orderId 注文ID
     * @param {CompleteOrderRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1CompleteOrder(orderId: string, body: CompleteOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1CompleteOrder(orderId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文下書き保存
     * @param {string} orderId 注文ID
     * @param {DraftOrderRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1DraftOrder(orderId: string, body: DraftOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1DraftOrder(orderId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文履歴のCSV出力
     * @param {ExportOrdersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1ExportOrders(body: ExportOrdersRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1ExportOrders(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文取得
     * @param {string} orderId 注文ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1GetOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1GetOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:paymentStatus,fulfillmentStatus,orderedAt,paidAt,deliveredAt,canceledAt,createdAt,updatedAt, 
     * @param {number} [status] 注文ステータス ・複数指定時は&#x60;,&#x60;区切り ・デフォルト:2(受注待ち),3(発送準備中),4(発送完了),5(完了) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1ListOrders(limit?: number, offset?: number, orders?: string, status?: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1ListOrders(limit, offset, orders, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文の返金依頼
     * @param {string} orderId 注文ID
     * @param {RefundOrderRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1RefundOrder(orderId: string, body: RefundOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1RefundOrder(orderId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 注文配送状況更新
     * @param {string} orderId 注文ID
     * @param {string} fulfillmentId 注文配送ID
     * @param {UpdateOrderFulfillmentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1UpdateOrderFulfillment(orderId: string, fulfillmentId: string, body: UpdateOrderFulfillmentRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1UpdateOrderFulfillment(orderId, fulfillmentId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OtherApi - axios parameter creator
 * @export
 */
export const OtherApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ファイルアップロード状態取得
         * @param {string} key 参照用のキー
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUploadState: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('v1GetUploadState', 'key', key)
            const localVarPath = `/v1/upload/state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 郵便番号情報検索
         * @param {string} postalCode 郵便番号(ハイフンなし)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchPostalCode: async (postalCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postalCode' is not null or undefined
            assertParamExists('v1SearchPostalCode', 'postalCode', postalCode)
            const localVarPath = `/v1/postal-codes/{postalCode}`
                .replace(`{${"postalCode"}}`, encodeURIComponent(String(postalCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OtherApi - functional programming interface
 * @export
 */
export const OtherApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OtherApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ファイルアップロード状態取得
         * @param {string} key 参照用のキー
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetUploadState(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetUploadState(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OtherApi.v1GetUploadState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 郵便番号情報検索
         * @param {string} postalCode 郵便番号(ハイフンなし)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchPostalCode(postalCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostalCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchPostalCode(postalCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OtherApi.v1SearchPostalCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OtherApi - factory interface
 * @export
 */
export const OtherApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OtherApiFp(configuration)
    return {
        /**
         * 
         * @summary ファイルアップロード状態取得
         * @param {string} key 参照用のキー
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUploadState(key: string, options?: RawAxiosRequestConfig): AxiosPromise<UploadStateResponse> {
            return localVarFp.v1GetUploadState(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 郵便番号情報検索
         * @param {string} postalCode 郵便番号(ハイフンなし)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchPostalCode(postalCode: string, options?: RawAxiosRequestConfig): AxiosPromise<PostalCodeResponse> {
            return localVarFp.v1SearchPostalCode(postalCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OtherApi - object-oriented interface
 * @export
 * @class OtherApi
 * @extends {BaseAPI}
 */
export class OtherApi extends BaseAPI {
    /**
     * 
     * @summary ファイルアップロード状態取得
     * @param {string} key 参照用のキー
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public v1GetUploadState(key: string, options?: RawAxiosRequestConfig) {
        return OtherApiFp(this.configuration).v1GetUploadState(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 郵便番号情報検索
     * @param {string} postalCode 郵便番号(ハイフンなし)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OtherApi
     */
    public v1SearchPostalCode(postalCode: string, options?: RawAxiosRequestConfig) {
        return OtherApiFp(this.configuration).v1SearchPostalCode(postalCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentSystemApi - axios parameter creator
 * @export
 */
export const PaymentSystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 決済システム状態一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListPaymentSystems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment-systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 決済システム状態更新
         * @param {number} methodType 決済種別
         * @param {UpdatePaymentSystemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdatePaymentSystem: async (methodType: number, body: UpdatePaymentSystemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'methodType' is not null or undefined
            assertParamExists('v1UpdatePaymentSystem', 'methodType', methodType)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdatePaymentSystem', 'body', body)
            const localVarPath = `/v1/payment-systems/{methodType}`
                .replace(`{${"methodType"}}`, encodeURIComponent(String(methodType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSystemApi - functional programming interface
 * @export
 */
export const PaymentSystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 決済システム状態一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListPaymentSystems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSystemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListPaymentSystems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSystemApi.v1ListPaymentSystems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 決済システム状態更新
         * @param {number} methodType 決済種別
         * @param {UpdatePaymentSystemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdatePaymentSystem(methodType: number, body: UpdatePaymentSystemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSystemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdatePaymentSystem(methodType, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSystemApi.v1UpdatePaymentSystem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentSystemApi - factory interface
 * @export
 */
export const PaymentSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSystemApiFp(configuration)
    return {
        /**
         * 
         * @summary 決済システム状態一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListPaymentSystems(options?: RawAxiosRequestConfig): AxiosPromise<PaymentSystemsResponse> {
            return localVarFp.v1ListPaymentSystems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 決済システム状態更新
         * @param {number} methodType 決済種別
         * @param {UpdatePaymentSystemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdatePaymentSystem(methodType: number, body: UpdatePaymentSystemRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentSystemsResponse> {
            return localVarFp.v1UpdatePaymentSystem(methodType, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentSystemApi - object-oriented interface
 * @export
 * @class PaymentSystemApi
 * @extends {BaseAPI}
 */
export class PaymentSystemApi extends BaseAPI {
    /**
     * 
     * @summary 決済システム状態一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public v1ListPaymentSystems(options?: RawAxiosRequestConfig) {
        return PaymentSystemApiFp(this.configuration).v1ListPaymentSystems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 決済システム状態更新
     * @param {number} methodType 決済種別
     * @param {UpdatePaymentSystemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public v1UpdatePaymentSystem(methodType: number, body: UpdatePaymentSystemRequest, options?: RawAxiosRequestConfig) {
        return PaymentSystemApiFp(this.configuration).v1UpdatePaymentSystem(methodType, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProducerApi - axios parameter creator
 * @export
 */
export const ProducerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 生産者登録
         * @param {CreateProducerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProducer: async (body: CreateProducerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateProducer', 'body', body)
            const localVarPath = `/v1/producers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者退会
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProducer: async (producerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'producerId' is not null or undefined
            assertParamExists('v1DeleteProducer', 'producerId', producerId)
            const localVarPath = `/v1/producers/{producerId}`
                .replace(`{${"producerId"}}`, encodeURIComponent(String(producerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者取得
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducer: async (producerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'producerId' is not null or undefined
            assertParamExists('v1GetProducer', 'producerId', producerId)
            const localVarPath = `/v1/producers/{producerId}`
                .replace(`{${"producerId"}}`, encodeURIComponent(String(producerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者購入特典動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerBonusVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProducerBonusVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/producers/bonus-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者ヘッダー画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerHeaderUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProducerHeaderUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/producers/header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者紹介動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerPromotionVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProducerPromotionVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/producers/promotion-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者サムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerThumbnailUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProducerThumbnailUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/producers/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] 農家名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProducers: async (limit?: number, offset?: number, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/producers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 生産者更新
         * @param {string} producerId 生産者ID
         * @param {UpdateProducerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProducer: async (producerId: string, body: UpdateProducerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'producerId' is not null or undefined
            assertParamExists('v1UpdateProducer', 'producerId', producerId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateProducer', 'body', body)
            const localVarPath = `/v1/producers/{producerId}`
                .replace(`{${"producerId"}}`, encodeURIComponent(String(producerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProducerApi - functional programming interface
 * @export
 */
export const ProducerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProducerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 生産者登録
         * @param {CreateProducerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateProducer(body: CreateProducerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateProducer(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1CreateProducer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者退会
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteProducer(producerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteProducer(producerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1DeleteProducer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者取得
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProducer(producerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProducer(producerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1GetProducer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者購入特典動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProducerBonusVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProducerBonusVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1GetProducerBonusVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者ヘッダー画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProducerHeaderUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProducerHeaderUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1GetProducerHeaderUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者紹介動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProducerPromotionVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProducerPromotionVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1GetProducerPromotionVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者サムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProducerThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProducerThumbnailUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1GetProducerThumbnailUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] 農家名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListProducers(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListProducers(limit, offset, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1ListProducers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 生産者更新
         * @param {string} producerId 生産者ID
         * @param {UpdateProducerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateProducer(producerId: string, body: UpdateProducerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateProducer(producerId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1UpdateProducer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProducerApi - factory interface
 * @export
 */
export const ProducerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProducerApiFp(configuration)
    return {
        /**
         * 
         * @summary 生産者登録
         * @param {CreateProducerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProducer(body: CreateProducerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProducerResponse> {
            return localVarFp.v1CreateProducer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者退会
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProducer(producerId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteProducer(producerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者取得
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducer(producerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProducerResponse> {
            return localVarFp.v1GetProducer(producerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者購入特典動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerBonusVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProducerBonusVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者ヘッダー画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerHeaderUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProducerHeaderUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者紹介動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerPromotionVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProducerPromotionVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者サムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProducerThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProducerThumbnailUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] 農家名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProducers(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProducersResponse> {
            return localVarFp.v1ListProducers(limit, offset, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 生産者更新
         * @param {string} producerId 生産者ID
         * @param {UpdateProducerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProducer(producerId: string, body: UpdateProducerRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateProducer(producerId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProducerApi - object-oriented interface
 * @export
 * @class ProducerApi
 * @extends {BaseAPI}
 */
export class ProducerApi extends BaseAPI {
    /**
     * 
     * @summary 生産者登録
     * @param {CreateProducerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1CreateProducer(body: CreateProducerRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1CreateProducer(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者退会
     * @param {string} producerId 生産者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1DeleteProducer(producerId: string, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1DeleteProducer(producerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者取得
     * @param {string} producerId 生産者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1GetProducer(producerId: string, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1GetProducer(producerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者購入特典動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1GetProducerBonusVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1GetProducerBonusVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者ヘッダー画像アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1GetProducerHeaderUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1GetProducerHeaderUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者紹介動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1GetProducerPromotionVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1GetProducerPromotionVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者サムネイルアップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1GetProducerThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1GetProducerThumbnailUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [username] 農家名(あいまい検索)(64文字以内)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1ListProducers(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1ListProducers(limit, offset, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 生産者更新
     * @param {string} producerId 生産者ID
     * @param {UpdateProducerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1UpdateProducer(producerId: string, body: UpdateProducerRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1UpdateProducer(producerId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 商品登録
         * @param {CreateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProduct: async (body: CreateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateProduct', 'body', body)
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品削除
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('v1DeleteProduct', 'productId', productId)
            const localVarPath = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品取得
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('v1GetProduct', 'productId', productId)
            const localVarPath = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProductImageUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProductImageUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/products/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProductVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProductVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/products/video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] 商品名(あいまい検索)(64文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name,public,inventory,originPrefecture,originCity,createdAt,updatedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProducts: async (limit?: number, offset?: number, producerId?: string, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (producerId !== undefined) {
                localVarQueryParameter['producerId'] = producerId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品更新
         * @param {string} productId 商品ID
         * @param {UpdateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProduct: async (productId: string, body: UpdateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('v1UpdateProduct', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateProduct', 'body', body)
            const localVarPath = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 商品登録
         * @param {CreateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateProduct(body: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateProduct(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1CreateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品削除
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1DeleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品取得
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1GetProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProductImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProductImageUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1GetProductImageUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProductVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProductVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1GetProductVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] 商品名(あいまい検索)(64文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name,public,inventory,originPrefecture,originCity,createdAt,updatedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListProducts(limit?: number, offset?: number, producerId?: string, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListProducts(limit, offset, producerId, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1ListProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品更新
         * @param {string} productId 商品ID
         * @param {UpdateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateProduct(productId: string, body: UpdateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateProduct(productId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1UpdateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary 商品登録
         * @param {CreateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProduct(body: CreateProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.v1CreateProduct(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品削除
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProduct(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品取得
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProduct(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.v1GetProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品画像アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProductImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProductImageUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProductVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProductVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] 商品名(あいまい検索)(64文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name,public,inventory,originPrefecture,originCity,createdAt,updatedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProducts(limit?: number, offset?: number, producerId?: string, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.v1ListProducts(limit, offset, producerId, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品更新
         * @param {string} productId 商品ID
         * @param {UpdateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProduct(productId: string, body: UpdateProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateProduct(productId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary 商品登録
     * @param {CreateProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1CreateProduct(body: CreateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1CreateProduct(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品削除
     * @param {string} productId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1DeleteProduct(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1DeleteProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品取得
     * @param {string} productId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1GetProduct(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1GetProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品画像アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1GetProductImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1GetProductImageUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1GetProductVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1GetProductVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [producerId] 生産者ID
     * @param {string} [name] 商品名(あいまい検索)(64文字以内)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name,public,inventory,originPrefecture,originCity,createdAt,updatedAt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ListProducts(limit?: number, offset?: number, producerId?: string, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ListProducts(limit, offset, producerId, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品更新
     * @param {string} productId 商品ID
     * @param {UpdateProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1UpdateProduct(productId: string, body: UpdateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1UpdateProduct(productId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductTagApi - axios parameter creator
 * @export
 */
export const ProductTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 商品タグ登録
         * @param {CreateProductTagRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProductTag: async (body: CreateProductTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateProductTag', 'body', body)
            const localVarPath = `/v1/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品タグ削除
         * @param {string} productTagId 商品タグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProductTag: async (productTagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTagId' is not null or undefined
            assertParamExists('v1DeleteProductTag', 'productTagId', productTagId)
            const localVarPath = `/v1/product-tags/{productTagId}`
                .replace(`{${"productTagId"}}`, encodeURIComponent(String(productTagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品タグ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品タグ名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProductTags: async (limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 商品タグ更新
         * @param {string} productTagId 商品タグID
         * @param {UpdateProductTagRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProductTag: async (productTagId: string, body: UpdateProductTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTagId' is not null or undefined
            assertParamExists('v1UpdateProductTag', 'productTagId', productTagId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateProductTag', 'body', body)
            const localVarPath = `/v1/product-tags/{productTagId}`
                .replace(`{${"productTagId"}}`, encodeURIComponent(String(productTagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductTagApi - functional programming interface
 * @export
 */
export const ProductTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductTagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 商品タグ登録
         * @param {CreateProductTagRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateProductTag(body: CreateProductTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateProductTag(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1CreateProductTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品タグ削除
         * @param {string} productTagId 商品タグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteProductTag(productTagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteProductTag(productTagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1DeleteProductTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品タグ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品タグ名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListProductTags(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListProductTags(limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1ListProductTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 商品タグ更新
         * @param {string} productTagId 商品タグID
         * @param {UpdateProductTagRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateProductTag(productTagId: string, body: UpdateProductTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateProductTag(productTagId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1UpdateProductTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductTagApi - factory interface
 * @export
 */
export const ProductTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductTagApiFp(configuration)
    return {
        /**
         * 
         * @summary 商品タグ登録
         * @param {CreateProductTagRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProductTag(body: CreateProductTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductTagResponse> {
            return localVarFp.v1CreateProductTag(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品タグ削除
         * @param {string} productTagId 商品タグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProductTag(productTagId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteProductTag(productTagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品タグ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品タグ名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProductTags(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductTagsResponse> {
            return localVarFp.v1ListProductTags(limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 商品タグ更新
         * @param {string} productTagId 商品タグID
         * @param {UpdateProductTagRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProductTag(productTagId: string, body: UpdateProductTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateProductTag(productTagId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductTagApi - object-oriented interface
 * @export
 * @class ProductTagApi
 * @extends {BaseAPI}
 */
export class ProductTagApi extends BaseAPI {
    /**
     * 
     * @summary 商品タグ登録
     * @param {CreateProductTagRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1CreateProductTag(body: CreateProductTagRequest, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1CreateProductTag(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品タグ削除
     * @param {string} productTagId 商品タグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1DeleteProductTag(productTagId: string, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1DeleteProductTag(productTagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品タグ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 商品タグ名(あいまい検索)(32文字以内)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1ListProductTags(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1ListProductTags(limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 商品タグ更新
     * @param {string} productTagId 商品タグID
     * @param {UpdateProductTagRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1UpdateProductTag(productTagId: string, body: UpdateProductTagRequest, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1UpdateProductTag(productTagId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductTypeApi - axios parameter creator
 * @export
 */
export const ProductTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 品目登録
         * @param {string} categoryId 商品種別ID
         * @param {CreateProductTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProductType: async (categoryId: string, body: CreateProductTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CreateProductType', 'categoryId', categoryId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateProductType', 'body', body)
            const localVarPath = `/v1/categories/{categoryId}/product-types`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 品目削除
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProductType: async (categoryId: string, productTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1DeleteProductType', 'categoryId', categoryId)
            // verify required parameter 'productTypeId' is not null or undefined
            assertParamExists('v1DeleteProductType', 'productTypeId', productTypeId)
            const localVarPath = `/v1/categories/{categoryId}/product-types/{productTypeId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"productTypeId"}}`, encodeURIComponent(String(productTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 品目アイコンアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProductTypeIconUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetProductTypeIconUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/product-types/icon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 品目一覧取得(商品種別指定なし)
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListAllProductTypes: async (limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/categories/-/product-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 品目一覧取得
         * @param {string} categoryId 商品種別ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProductTypes: async (categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1ListProductTypes', 'categoryId', categoryId)
            const localVarPath = `/v1/categories/{categoryId}/product-types`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 品目更新
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {UpdateProductTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProductType: async (categoryId: string, productTypeId: string, body: UpdateProductTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1UpdateProductType', 'categoryId', categoryId)
            // verify required parameter 'productTypeId' is not null or undefined
            assertParamExists('v1UpdateProductType', 'productTypeId', productTypeId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateProductType', 'body', body)
            const localVarPath = `/v1/categories/{categoryId}/product-types/{productTypeId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"productTypeId"}}`, encodeURIComponent(String(productTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductTypeApi - functional programming interface
 * @export
 */
export const ProductTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 品目登録
         * @param {string} categoryId 商品種別ID
         * @param {CreateProductTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateProductType(categoryId: string, body: CreateProductTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateProductType(categoryId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1CreateProductType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 品目削除
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteProductType(categoryId: string, productTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteProductType(categoryId, productTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1DeleteProductType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 品目アイコンアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetProductTypeIconUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetProductTypeIconUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1GetProductTypeIconUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 品目一覧取得(商品種別指定なし)
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListAllProductTypes(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListAllProductTypes(limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1ListAllProductTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 品目一覧取得
         * @param {string} categoryId 商品種別ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListProductTypes(categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListProductTypes(categoryId, limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1ListProductTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 品目更新
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {UpdateProductTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateProductType(categoryId: string, productTypeId: string, body: UpdateProductTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateProductType(categoryId, productTypeId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1UpdateProductType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductTypeApi - factory interface
 * @export
 */
export const ProductTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary 品目登録
         * @param {string} categoryId 商品種別ID
         * @param {CreateProductTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateProductType(categoryId: string, body: CreateProductTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductTypeResponse> {
            return localVarFp.v1CreateProductType(categoryId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 品目削除
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteProductType(categoryId: string, productTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteProductType(categoryId, productTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 品目アイコンアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetProductTypeIconUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetProductTypeIconUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 品目一覧取得(商品種別指定なし)
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListAllProductTypes(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductTypesResponse> {
            return localVarFp.v1ListAllProductTypes(limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 品目一覧取得
         * @param {string} categoryId 商品種別ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListProductTypes(categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductTypesResponse> {
            return localVarFp.v1ListProductTypes(categoryId, limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 品目更新
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {UpdateProductTypeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateProductType(categoryId: string, productTypeId: string, body: UpdateProductTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateProductType(categoryId, productTypeId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductTypeApi - object-oriented interface
 * @export
 * @class ProductTypeApi
 * @extends {BaseAPI}
 */
export class ProductTypeApi extends BaseAPI {
    /**
     * 
     * @summary 品目登録
     * @param {string} categoryId 商品種別ID
     * @param {CreateProductTypeRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1CreateProductType(categoryId: string, body: CreateProductTypeRequest, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1CreateProductType(categoryId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 品目削除
     * @param {string} categoryId 商品種別ID
     * @param {string} productTypeId 品目ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1DeleteProductType(categoryId: string, productTypeId: string, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1DeleteProductType(categoryId, productTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 品目アイコンアップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1GetProductTypeIconUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1GetProductTypeIconUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 品目一覧取得(商品種別指定なし)
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 品目名(あいまい検索)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1ListAllProductTypes(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1ListAllProductTypes(limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 品目一覧取得
     * @param {string} categoryId 商品種別ID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 品目名(あいまい検索)(32文字以内)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1ListProductTypes(categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1ListProductTypes(categoryId, limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 品目更新
     * @param {string} categoryId 商品種別ID
     * @param {string} productTypeId 品目ID
     * @param {UpdateProductTypeRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1UpdateProductType(categoryId: string, productTypeId: string, body: UpdateProductTypeRequest, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1UpdateProductType(categoryId, productTypeId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromotionApi - axios parameter creator
 * @export
 */
export const PromotionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary プロモーション登録
         * @param {CreatePromotionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreatePromotion: async (body: CreatePromotionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreatePromotion', 'body', body)
            const localVarPath = `/v1/promotions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロモーション削除
         * @param {string} promotionId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeletePromotion: async (promotionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('v1DeletePromotion', 'promotionId', promotionId)
            const localVarPath = `/v1/promotions/{promotionId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロモーション取得
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetPromotion: async (promotionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('v1GetPromotion', 'promotionId', promotionId)
            const localVarPath = `/v1/promotions/{promotionId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロモーション一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [title] タイトル(あいまい検索)(64文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:title,public,publishedAt,startAt,endAt,createdAt,updatedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListPromotions: async (limit?: number, offset?: number, title?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/promotions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロモーション更新
         * @param {string} promotionId 商品ID
         * @param {UpdatePromotionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdatePromotion: async (promotionId: string, body: UpdatePromotionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('v1UpdatePromotion', 'promotionId', promotionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdatePromotion', 'body', body)
            const localVarPath = `/v1/promotions/{promotionId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromotionApi - functional programming interface
 * @export
 */
export const PromotionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromotionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary プロモーション登録
         * @param {CreatePromotionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreatePromotion(body: CreatePromotionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreatePromotion(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1CreatePromotion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary プロモーション削除
         * @param {string} promotionId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeletePromotion(promotionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeletePromotion(promotionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1DeletePromotion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary プロモーション取得
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetPromotion(promotionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetPromotion(promotionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1GetPromotion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary プロモーション一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [title] タイトル(あいまい検索)(64文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:title,public,publishedAt,startAt,endAt,createdAt,updatedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListPromotions(limit?: number, offset?: number, title?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListPromotions(limit, offset, title, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1ListPromotions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary プロモーション更新
         * @param {string} promotionId 商品ID
         * @param {UpdatePromotionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdatePromotion(promotionId: string, body: UpdatePromotionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdatePromotion(promotionId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1UpdatePromotion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromotionApi - factory interface
 * @export
 */
export const PromotionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromotionApiFp(configuration)
    return {
        /**
         * 
         * @summary プロモーション登録
         * @param {CreatePromotionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreatePromotion(body: CreatePromotionRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromotionResponse> {
            return localVarFp.v1CreatePromotion(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロモーション削除
         * @param {string} promotionId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeletePromotion(promotionId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeletePromotion(promotionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロモーション取得
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetPromotion(promotionId: string, options?: RawAxiosRequestConfig): AxiosPromise<PromotionResponse> {
            return localVarFp.v1GetPromotion(promotionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロモーション一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [title] タイトル(あいまい検索)(64文字以内)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:title,public,publishedAt,startAt,endAt,createdAt,updatedAt 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListPromotions(limit?: number, offset?: number, title?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<PromotionsResponse> {
            return localVarFp.v1ListPromotions(limit, offset, title, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロモーション更新
         * @param {string} promotionId 商品ID
         * @param {UpdatePromotionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdatePromotion(promotionId: string, body: UpdatePromotionRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdatePromotion(promotionId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromotionApi - object-oriented interface
 * @export
 * @class PromotionApi
 * @extends {BaseAPI}
 */
export class PromotionApi extends BaseAPI {
    /**
     * 
     * @summary プロモーション登録
     * @param {CreatePromotionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1CreatePromotion(body: CreatePromotionRequest, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1CreatePromotion(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロモーション削除
     * @param {string} promotionId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1DeletePromotion(promotionId: string, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1DeletePromotion(promotionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロモーション取得
     * @param {string} promotionId プロモーションID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1GetPromotion(promotionId: string, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1GetPromotion(promotionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロモーション一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [title] タイトル(あいまい検索)(64文字以内)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:title,public,publishedAt,startAt,endAt,createdAt,updatedAt 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1ListPromotions(limit?: number, offset?: number, title?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1ListPromotions(limit, offset, title, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロモーション更新
     * @param {string} promotionId 商品ID
     * @param {UpdatePromotionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1UpdatePromotion(promotionId: string, body: UpdatePromotionRequest, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1UpdatePromotion(promotionId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary マルシェ分析情報取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はライブ配信開始時間)
         * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はライブ配信終了時間)
         * @param {BroadcastViewerLogInterval} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyzeSchedule: async (scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: BroadcastViewerLogInterval, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1AnalyzeSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/analytics`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startAt !== undefined) {
                localVarQueryParameter['startAt'] = startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['endAt'] = endAt;
            }

            if (viewerLogInterval !== undefined) {
                localVarQueryParameter['viewerLogInterval'] = viewerLogInterval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール承認
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {ApproveScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ApproveSchedule: async (scheduleId: string, body: ApproveScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1ApproveSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1ApproveSchedule', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/approval`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール登録
         * @param {CreateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateSchedule: async (body: CreateScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateSchedule', 'body', body)
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール削除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1DeleteSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetSchedule: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1GetSchedule', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 開催スケジュール蓋絵アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetScheduleImageUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetScheduleImageUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/schedules/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 開催スケジュールオープニング動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetScheduleOpeningVideoUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetScheduleOpeningVideoUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/schedules/opening-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 開催スケジュールサムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetScheduleThumbnailUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetScheduleThumbnailUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/schedules/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信コメント取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {string} [next] 取得開始位置
         * @param {number} [start] 取得範囲(開始時間:unixtime)
         * @param {number} [end] 取得範囲(終了時間:unixtime)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:publishedAt（デフォルト:-publishedAt） 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListLiveComments: async (scheduleId: string, limit?: number, next?: string, start?: number, end?: number, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1ListLiveComments', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/comments`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListSchedules: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール公開
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {PublishScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PublishSchedule: async (scheduleId: string, body: PublishScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1PublishSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1PublishSchedule', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/publish`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ライブ配信コメント更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} commentId コメントID
         * @param {UpdateLiveCommentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateLiveComment: async (scheduleId: string, commentId: string, body: UpdateLiveCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1UpdateLiveComment', 'scheduleId', scheduleId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('v1UpdateLiveComment', 'commentId', commentId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateLiveComment', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}/comments/{commentId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マルシェ開催スケジュール更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {UpdateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateSchedule: async (scheduleId: string, body: UpdateScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1UpdateSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateSchedule', 'body', body)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary マルシェ分析情報取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はライブ配信開始時間)
         * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はライブ配信終了時間)
         * @param {BroadcastViewerLogInterval} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyzeSchedule(scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: BroadcastViewerLogInterval, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyzeScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyzeSchedule(scheduleId, startAt, endAt, viewerLogInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1AnalyzeSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール承認
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {ApproveScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ApproveSchedule(scheduleId: string, body: ApproveScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ApproveSchedule(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1ApproveSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール登録
         * @param {CreateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateSchedule(body: CreateScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateSchedule(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1CreateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール削除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1DeleteSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetSchedule(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetSchedule(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1GetSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 開催スケジュール蓋絵アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetScheduleImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetScheduleImageUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1GetScheduleImageUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 開催スケジュールオープニング動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetScheduleOpeningVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetScheduleOpeningVideoUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1GetScheduleOpeningVideoUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 開催スケジュールサムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetScheduleThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetScheduleThumbnailUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1GetScheduleThumbnailUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信コメント取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {string} [next] 取得開始位置
         * @param {number} [start] 取得範囲(開始時間:unixtime)
         * @param {number} [end] 取得範囲(終了時間:unixtime)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:publishedAt（デフォルト:-publishedAt） 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListLiveComments(scheduleId: string, limit?: number, next?: string, start?: number, end?: number, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveCommentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListLiveComments(scheduleId, limit, next, start, end, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1ListLiveComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListSchedules(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchedulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListSchedules(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1ListSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール公開
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {PublishScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PublishSchedule(scheduleId: string, body: PublishScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PublishSchedule(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1PublishSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ライブ配信コメント更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} commentId コメントID
         * @param {UpdateLiveCommentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateLiveComment(scheduleId: string, commentId: string, body: UpdateLiveCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateLiveComment(scheduleId, commentId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1UpdateLiveComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary マルシェ開催スケジュール更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {UpdateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateSchedule(scheduleId: string, body: UpdateScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateSchedule(scheduleId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1UpdateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @summary マルシェ分析情報取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はライブ配信開始時間)
         * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はライブ配信終了時間)
         * @param {BroadcastViewerLogInterval} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyzeSchedule(scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: BroadcastViewerLogInterval, options?: RawAxiosRequestConfig): AxiosPromise<AnalyzeScheduleResponse> {
            return localVarFp.v1AnalyzeSchedule(scheduleId, startAt, endAt, viewerLogInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール承認
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {ApproveScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ApproveSchedule(scheduleId: string, body: ApproveScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1ApproveSchedule(scheduleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール登録
         * @param {CreateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateSchedule(body: CreateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.v1CreateSchedule(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール削除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetSchedule(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.v1GetSchedule(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 開催スケジュール蓋絵アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetScheduleImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetScheduleImageUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 開催スケジュールオープニング動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetScheduleOpeningVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetScheduleOpeningVideoUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 開催スケジュールサムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetScheduleThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetScheduleThumbnailUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信コメント取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {string} [next] 取得開始位置
         * @param {number} [start] 取得範囲(開始時間:unixtime)
         * @param {number} [end] 取得範囲(終了時間:unixtime)
         * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:publishedAt（デフォルト:-publishedAt） 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListLiveComments(scheduleId: string, limit?: number, next?: string, start?: number, end?: number, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<LiveCommentsResponse> {
            return localVarFp.v1ListLiveComments(scheduleId, limit, next, start, end, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListSchedules(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<SchedulesResponse> {
            return localVarFp.v1ListSchedules(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール公開
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {PublishScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PublishSchedule(scheduleId: string, body: PublishScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1PublishSchedule(scheduleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ライブ配信コメント更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {string} commentId コメントID
         * @param {UpdateLiveCommentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateLiveComment(scheduleId: string, commentId: string, body: UpdateLiveCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateLiveComment(scheduleId, commentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マルシェ開催スケジュール更新
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {UpdateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateSchedule(scheduleId: string, body: UpdateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateSchedule(scheduleId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @summary マルシェ分析情報取得
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はライブ配信開始時間)
     * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はライブ配信終了時間)
     * @param {BroadcastViewerLogInterval} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1AnalyzeSchedule(scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: BroadcastViewerLogInterval, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1AnalyzeSchedule(scheduleId, startAt, endAt, viewerLogInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール承認
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {ApproveScheduleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1ApproveSchedule(scheduleId: string, body: ApproveScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1ApproveSchedule(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール登録
     * @param {CreateScheduleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1CreateSchedule(body: CreateScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1CreateSchedule(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール削除
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1DeleteSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1DeleteSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール取得
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1GetSchedule(scheduleId: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1GetSchedule(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 開催スケジュール蓋絵アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1GetScheduleImageUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1GetScheduleImageUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 開催スケジュールオープニング動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1GetScheduleOpeningVideoUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1GetScheduleOpeningVideoUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 開催スケジュールサムネイルアップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1GetScheduleThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1GetScheduleThumbnailUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信コメント取得
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {string} [next] 取得開始位置
     * @param {number} [start] 取得範囲(開始時間:unixtime)
     * @param {number} [end] 取得範囲(終了時間:unixtime)
     * @param {string} [orders] ソート ・複数指定時は&#x60;,&#x60;区切り ・降順の場合はprefixに&#x60;-&#x60;をつける ・指定可能フィールド:publishedAt（デフォルト:-publishedAt） 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1ListLiveComments(scheduleId: string, limit?: number, next?: string, start?: number, end?: number, orders?: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1ListLiveComments(scheduleId, limit, next, start, end, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1ListSchedules(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1ListSchedules(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール公開
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {PublishScheduleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1PublishSchedule(scheduleId: string, body: PublishScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1PublishSchedule(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ライブ配信コメント更新
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {string} commentId コメントID
     * @param {UpdateLiveCommentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1UpdateLiveComment(scheduleId: string, commentId: string, body: UpdateLiveCommentRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1UpdateLiveComment(scheduleId, commentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マルシェ開催スケジュール更新
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {UpdateScheduleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1UpdateSchedule(scheduleId: string, body: UpdateScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1UpdateSchedule(scheduleId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShippingApi - axios parameter creator
 * @export
 */
export const ShippingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary デフォルト配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetDefaultShipping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shippings/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 配送設定取得
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetShipping: async (coordinatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1GetShipping', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary デフォルト配送設定更新
         * @param {UpdateDefaultShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateDefaultShipping: async (body: UpdateDefaultShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateDefaultShipping', 'body', body)
            const localVarPath = `/v1/shippings/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpsertShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpsertShipping: async (coordinatorId: string, body: UpsertShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1UpsertShipping', 'coordinatorId', coordinatorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpsertShipping', 'body', body)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShippingApi - functional programming interface
 * @export
 */
export const ShippingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShippingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary デフォルト配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetDefaultShipping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetDefaultShipping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1GetDefaultShipping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 配送設定取得
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetShipping(coordinatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetShipping(coordinatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1GetShipping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary デフォルト配送設定更新
         * @param {UpdateDefaultShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateDefaultShipping(body: UpdateDefaultShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateDefaultShipping(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1UpdateDefaultShipping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpsertShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpsertShipping(coordinatorId: string, body: UpsertShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpsertShipping(coordinatorId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1UpsertShipping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShippingApi - factory interface
 * @export
 */
export const ShippingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShippingApiFp(configuration)
    return {
        /**
         * 
         * @summary デフォルト配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetDefaultShipping(options?: RawAxiosRequestConfig): AxiosPromise<ShippingResponse> {
            return localVarFp.v1GetDefaultShipping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 配送設定取得
         * @param {string} coordinatorId コーディネータID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetShipping(coordinatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<ShippingResponse> {
            return localVarFp.v1GetShipping(coordinatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary デフォルト配送設定更新
         * @param {UpdateDefaultShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateDefaultShipping(body: UpdateDefaultShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateDefaultShipping(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネータID
         * @param {UpsertShippingRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpsertShipping(coordinatorId: string, body: UpsertShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpsertShipping(coordinatorId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShippingApi - object-oriented interface
 * @export
 * @class ShippingApi
 * @extends {BaseAPI}
 */
export class ShippingApi extends BaseAPI {
    /**
     * 
     * @summary デフォルト配送設定取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1GetDefaultShipping(options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1GetDefaultShipping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 配送設定取得
     * @param {string} coordinatorId コーディネータID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1GetShipping(coordinatorId: string, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1GetShipping(coordinatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary デフォルト配送設定更新
     * @param {UpdateDefaultShippingRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1UpdateDefaultShipping(body: UpdateDefaultShippingRequest, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1UpdateDefaultShipping(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 配送設定更新
     * @param {string} coordinatorId コーディネータID
     * @param {UpsertShippingRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1UpsertShipping(coordinatorId: string, body: UpsertShippingRequest, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1UpsertShipping(coordinatorId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThreadApi - axios parameter creator
 * @export
 */
export const ThreadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary お問い合わせ会話登録
         * @param {CreateThreadRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateThread: async (body: CreateThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateThread', 'body', body)
            const localVarPath = `/v1/contacts/{contactId}/threads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ会話履歴削除
         * @param {string} threadId お問い合わせ会話ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteThread: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('v1DeleteThread', 'threadId', threadId)
            const localVarPath = `/v1/contacts/{contactId}/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ会話履歴取得
         * @param {string} threadId お問い合わせ会話ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetThread: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('v1GetThread', 'threadId', threadId)
            const localVarPath = `/v1/contacts/{contactId}/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ会話履歴一覧取得
         * @param {string} contactId お問い合わせID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListThreadsByContactId: async (contactId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ListThreadsByContactId', 'contactId', contactId)
            const localVarPath = `/v1/contacts/{contactId}/threads`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary お問い合わせ会話履歴更新
         * @param {string} threadId お問い合わせ会話ID
         * @param {UpdateThreadRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateThread: async (threadId: string, body: UpdateThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('v1UpdateThread', 'threadId', threadId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateThread', 'body', body)
            const localVarPath = `/v1/contacts/{contactId}/threads/{threadId}`
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadApi - functional programming interface
 * @export
 */
export const ThreadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThreadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary お問い合わせ会話登録
         * @param {CreateThreadRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateThread(body: CreateThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateThread(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1CreateThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ会話履歴削除
         * @param {string} threadId お問い合わせ会話ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteThread(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteThread(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1DeleteThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ会話履歴取得
         * @param {string} threadId お問い合わせ会話ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetThread(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetThread(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1GetThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ会話履歴一覧取得
         * @param {string} contactId お問い合わせID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListThreadsByContactId(contactId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListThreadsByContactId(contactId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1ListThreadsByContactId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary お問い合わせ会話履歴更新
         * @param {string} threadId お問い合わせ会話ID
         * @param {UpdateThreadRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateThread(threadId: string, body: UpdateThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateThread(threadId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1UpdateThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThreadApi - factory interface
 * @export
 */
export const ThreadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThreadApiFp(configuration)
    return {
        /**
         * 
         * @summary お問い合わせ会話登録
         * @param {CreateThreadRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateThread(body: CreateThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThreadResponse> {
            return localVarFp.v1CreateThread(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ会話履歴削除
         * @param {string} threadId お問い合わせ会話ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteThread(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteThread(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ会話履歴取得
         * @param {string} threadId お問い合わせ会話ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetThread(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadResponse> {
            return localVarFp.v1GetThread(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ会話履歴一覧取得
         * @param {string} contactId お問い合わせID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListThreadsByContactId(contactId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ThreadsResponse> {
            return localVarFp.v1ListThreadsByContactId(contactId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary お問い合わせ会話履歴更新
         * @param {string} threadId お問い合わせ会話ID
         * @param {UpdateThreadRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateThread(threadId: string, body: UpdateThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateThread(threadId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadApi - object-oriented interface
 * @export
 * @class ThreadApi
 * @extends {BaseAPI}
 */
export class ThreadApi extends BaseAPI {
    /**
     * 
     * @summary お問い合わせ会話登録
     * @param {CreateThreadRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1CreateThread(body: CreateThreadRequest, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1CreateThread(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ会話履歴削除
     * @param {string} threadId お問い合わせ会話ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1DeleteThread(threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1DeleteThread(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ会話履歴取得
     * @param {string} threadId お問い合わせ会話ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1GetThread(threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1GetThread(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ会話履歴一覧取得
     * @param {string} contactId お問い合わせID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1ListThreadsByContactId(contactId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1ListThreadsByContactId(contactId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary お問い合わせ会話履歴更新
     * @param {string} threadId お問い合わせ会話ID
     * @param {UpdateThreadRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1UpdateThread(threadId: string, body: UpdateThreadRequest, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1UpdateThread(threadId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 購入者削除
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1DeleteUser', 'userId', userId)
            const localVarPath = `/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 購入者詳細
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1GetUser', 'userId', userId)
            const localVarPath = `/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 購入者の注文履歴一覧
         * @param {string} userId 購入者ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListUserOrders: async (userId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1ListUserOrders', 'userId', userId)
            const localVarPath = `/v1/users/{userId}/orders`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 購入者一覧
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListUsers: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 購入者削除
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1DeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 購入者詳細
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1GetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 購入者の注文履歴一覧
         * @param {string} userId 購入者ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListUserOrders(userId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListUserOrders(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1ListUserOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 購入者一覧
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListUsers(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListUsers(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1ListUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary 購入者削除
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 購入者詳細
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.v1GetUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 購入者の注文履歴一覧
         * @param {string} userId 購入者ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListUserOrders(userId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserOrdersResponse> {
            return localVarFp.v1ListUserOrders(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 購入者一覧
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListUsers(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.v1ListUsers(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary 購入者削除
     * @param {string} userId 購入者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1DeleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1DeleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 購入者詳細
     * @param {string} userId 購入者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1GetUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1GetUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 購入者の注文履歴一覧
     * @param {string} userId 購入者ID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1ListUserOrders(userId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1ListUserOrders(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 購入者一覧
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1ListUsers(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1ListUsers(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VideoApi - axios parameter creator
 * @export
 */
export const VideoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary オンデマンド配信登録
         * @param {CreateVideoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateVideo: async (body: CreateVideoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1CreateVideo', 'body', body)
            const localVarPath = `/v1/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信削除
         * @param {string} videoId オンデマンド配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteVideo: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1DeleteVideo', 'videoId', videoId)
            const localVarPath = `/v1/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信取得
         * @param {string} videoId オンデマンド配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetVideo: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1GetVideo', 'videoId', videoId)
            const localVarPath = `/v1/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetVideoFileUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetVideoFileUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/videos/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信サムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetVideoThumbnailUploadUrl: async (body: GetUploadUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1GetVideoThumbnailUploadUrl', 'body', body)
            const localVarPath = `/v1/upload/videos/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] オンデマンド配信名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListVideos: async (limit?: number, offset?: number, producerId?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (producerId !== undefined) {
                localVarQueryParameter['producerId'] = producerId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary オンデマンド配信更新
         * @param {string} videoId オンデマンド配信ID
         * @param {UpdateVideoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateVideo: async (videoId: string, body: UpdateVideoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1UpdateVideo', 'videoId', videoId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('v1UpdateVideo', 'body', body)
            const localVarPath = `/v1/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoApi - functional programming interface
 * @export
 */
export const VideoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary オンデマンド配信登録
         * @param {CreateVideoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreateVideo(body: CreateVideoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreateVideo(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1CreateVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信削除
         * @param {string} videoId オンデマンド配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DeleteVideo(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DeleteVideo(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1DeleteVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信取得
         * @param {string} videoId オンデマンド配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetVideo(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetVideo(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1GetVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetVideoFileUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetVideoFileUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1GetVideoFileUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信サムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GetVideoThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GetVideoThumbnailUploadUrl(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1GetVideoThumbnailUploadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] オンデマンド配信名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ListVideos(limit?: number, offset?: number, producerId?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ListVideos(limit, offset, producerId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1ListVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary オンデマンド配信更新
         * @param {string} videoId オンデマンド配信ID
         * @param {UpdateVideoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UpdateVideo(videoId: string, body: UpdateVideoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UpdateVideo(videoId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1UpdateVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VideoApi - factory interface
 * @export
 */
export const VideoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideoApiFp(configuration)
    return {
        /**
         * 
         * @summary オンデマンド配信登録
         * @param {CreateVideoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreateVideo(body: CreateVideoRequest, options?: RawAxiosRequestConfig): AxiosPromise<VideoResponse> {
            return localVarFp.v1CreateVideo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信削除
         * @param {string} videoId オンデマンド配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DeleteVideo(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1DeleteVideo(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信取得
         * @param {string} videoId オンデマンド配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetVideo(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<VideoResponse> {
            return localVarFp.v1GetVideo(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信動画アップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetVideoFileUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetVideoFileUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信サムネイルアップロード用URL取得
         * @param {GetUploadUrlRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GetVideoThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadUrlResponse> {
            return localVarFp.v1GetVideoThumbnailUploadUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [producerId] 生産者ID
         * @param {string} [name] オンデマンド配信名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ListVideos(limit?: number, offset?: number, producerId?: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<VideosResponse> {
            return localVarFp.v1ListVideos(limit, offset, producerId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary オンデマンド配信更新
         * @param {string} videoId オンデマンド配信ID
         * @param {UpdateVideoRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UpdateVideo(videoId: string, body: UpdateVideoRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1UpdateVideo(videoId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoApi - object-oriented interface
 * @export
 * @class VideoApi
 * @extends {BaseAPI}
 */
export class VideoApi extends BaseAPI {
    /**
     * 
     * @summary オンデマンド配信登録
     * @param {CreateVideoRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1CreateVideo(body: CreateVideoRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1CreateVideo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信削除
     * @param {string} videoId オンデマンド配信ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1DeleteVideo(videoId: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1DeleteVideo(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信取得
     * @param {string} videoId オンデマンド配信ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1GetVideo(videoId: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1GetVideo(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信動画アップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1GetVideoFileUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1GetVideoFileUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信サムネイルアップロード用URL取得
     * @param {GetUploadUrlRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1GetVideoThumbnailUploadUrl(body: GetUploadUrlRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1GetVideoThumbnailUploadUrl(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [producerId] 生産者ID
     * @param {string} [name] オンデマンド配信名(あいまい検索)(64文字以内)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1ListVideos(limit?: number, offset?: number, producerId?: string, name?: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1ListVideos(limit, offset, producerId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary オンデマンド配信更新
     * @param {string} videoId オンデマンド配信ID
     * @param {UpdateVideoRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1UpdateVideo(videoId: string, body: UpdateVideoRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1UpdateVideo(videoId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



