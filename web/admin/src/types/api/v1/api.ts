/* tslint:disable */
/* eslint-disable */
/**
 * ふるマル API - 管理者向け
 * 管理者向けのふるマルAPIです。
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * デフォルト設定の住所情報
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 住所ID
     * @type {string}
     * @memberof Address
     */
    'addressId'?: string;
    /**
     * 町名・番地
     * @type {string}
     * @memberof Address
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof Address
     */
    'addressLine2'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 氏名（名）
     * @type {string}
     * @memberof Address
     */
    'firstname'?: string;
    /**
     * 氏名(名:かな)
     * @type {string}
     * @memberof Address
     */
    'firstnameKana'?: string;
    /**
     * 氏名（姓）
     * @type {string}
     * @memberof Address
     */
    'lastname'?: string;
    /**
     * 氏名(姓:かな)
     * @type {string}
     * @memberof Address
     */
    'lastnameKana'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof Address
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {string}
     * @memberof Address
     */
    'prefecture'?: string;
    /**
     * 都道府県コード
     * @type {number}
     * @memberof Address
     */
    'prefectureCode'?: number;
}
/**
 * 
 * @export
 * @interface AuthGoogleAccountResponse
 */
export interface AuthGoogleAccountResponse {
    /**
     * Googleアカウント連携URL
     * @type {string}
     * @memberof AuthGoogleAccountResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface AuthLINEAccountResponse
 */
export interface AuthLINEAccountResponse {
    /**
     * LINEアカウント連携URL
     * @type {string}
     * @memberof AuthLINEAccountResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * アクセストークン
     * @type {string}
     * @memberof AuthResponse
     */
    'accessToken'?: string;
    /**
     * 管理者ID
     * @type {string}
     * @memberof AuthResponse
     */
    'adminId'?: string;
    /**
     * 有効期限
     * @type {number}
     * @memberof AuthResponse
     */
    'expiresIn'?: number;
    /**
     * 更新トークン
     * @type {string}
     * @memberof AuthResponse
     */
    'refreshToken'?: string;
    /**
     * トークン種別
     * @type {string}
     * @memberof AuthResponse
     */
    'tokenType'?: string;
    /**
     * 管理者種別
     * @type {number}
     * @memberof AuthResponse
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface AuthUserResponse
 */
export interface AuthUserResponse {
    /**
     * メールアドレス
     * @type {string}
     * @memberof AuthUserResponse
     */
    'email'?: string;
    /**
     * 管理者ID
     * @type {string}
     * @memberof AuthUserResponse
     */
    'id'?: string;
    /**
     * 店舗ID一覧
     * @type {Array<string>}
     * @memberof AuthUserResponse
     */
    'shopIds'?: Array<string>;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof AuthUserResponse
     */
    'thumbnailUrl'?: string;
    /**
     * 管理者種別
     * @type {number}
     * @memberof AuthUserResponse
     */
    'type'?: number;
    /**
     * 表示名
     * @type {string}
     * @memberof AuthUserResponse
     */
    'username'?: string;
}
/**
 * 商品種別情報
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 登録日時
     * @type {number}
     * @memberof Category
     */
    'createdAt'?: number;
    /**
     * 商品種別ID
     * @type {string}
     * @memberof Category
     */
    'id'?: string;
    /**
     * 商品種別名
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Category
     */
    'updatedAt'?: number;
}
/**
 * コーディネータ情報
 * @export
 * @interface Coordinator
 */
export interface Coordinator {
    /**
     * 町名・番地
     * @type {string}
     * @memberof Coordinator
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof Coordinator
     */
    'addressLine2'?: string;
    /**
     * 購入特典映像URL
     * @type {string}
     * @memberof Coordinator
     */
    'bonusVideoUrl'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof Coordinator
     */
    'city'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof Coordinator
     */
    'createdAt'?: number;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Coordinator
     */
    'email'?: string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof Coordinator
     */
    'facebookId'?: string;
    /**
     * 名
     * @type {string}
     * @memberof Coordinator
     */
    'firstname'?: string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof Coordinator
     */
    'firstnameKana'?: string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof Coordinator
     */
    'headerUrl'?: string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Coordinator
     */
    'id'?: string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof Coordinator
     */
    'instagramId'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof Coordinator
     */
    'lastname'?: string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof Coordinator
     */
    'lastnameKana'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof Coordinator
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof Coordinator
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {number}
     * @memberof Coordinator
     */
    'prefectureCode'?: number;
    /**
     * 担当する生産者数
     * @type {number}
     * @memberof Coordinator
     */
    'producerTotal'?: number;
    /**
     * 紹介文
     * @type {string}
     * @memberof Coordinator
     */
    'profile'?: string;
    /**
     * 紹介映像URL
     * @type {string}
     * @memberof Coordinator
     */
    'promotionVideoUrl'?: string;
    /**
     * 店舗ID
     * @type {string}
     * @memberof Coordinator
     */
    'shopId'?: string;
    /**
     * 管理者の状態
     * @type {number}
     * @memberof Coordinator
     */
    'status'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Coordinator
     */
    'thumbnailUrl'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Coordinator
     */
    'updatedAt'?: number;
    /**
     * 表示名
     * @type {string}
     * @memberof Coordinator
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface CoordinatorResponse
 */
export interface CoordinatorResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof CoordinatorResponse
     */
    'coordinator'?: Coordinator;
    /**
     * パスワード（登録時のみ）
     * @type {string}
     * @memberof CoordinatorResponse
     */
    'password'?: string;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof CoordinatorResponse
     */
    'productTypes'?: Array<ProductType>;
    /**
     * 
     * @type {TypesShop}
     * @memberof CoordinatorResponse
     */
    'shop'?: TypesShop;
}
/**
 * 
 * @export
 * @interface CoordinatorsResponse
 */
export interface CoordinatorsResponse {
    /**
     * 生産者一覧
     * @type {Array<Coordinator>}
     * @memberof CoordinatorsResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof CoordinatorsResponse
     */
    'productTypes'?: Array<ProductType>;
    /**
     * 店舗一覧
     * @type {Array<TypesShop>}
     * @memberof CoordinatorsResponse
     */
    'shops'?: Array<TypesShop>;
    /**
     * 合計数
     * @type {number}
     * @memberof CoordinatorsResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CreateSpotRequest
 */
export interface CreateSpotRequest {
    /**
     * 説明
     * @type {string}
     * @memberof CreateSpotRequest
     */
    'description'?: string;
    /**
     * 緯度
     * @type {number}
     * @memberof CreateSpotRequest
     */
    'latitude': number;
    /**
     * 経度
     * @type {number}
     * @memberof CreateSpotRequest
     */
    'longitude': number;
    /**
     * スポット名
     * @type {string}
     * @memberof CreateSpotRequest
     */
    'name': string;
    /**
     * スポット種別ID
     * @type {string}
     * @memberof CreateSpotRequest
     */
    'spotTypeId': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof CreateSpotRequest
     */
    'thumbnailUrl'?: string;
}
/**
 * 体験情報
 * @export
 * @interface Experience
 */
export interface Experience {
    /**
     * 営業終了時間
     * @type {string}
     * @memberof Experience
     */
    'businessCloseTime'?: string;
    /**
     * 営業開始時間
     * @type {string}
     * @memberof Experience
     */
    'businessOpenTime'?: string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Experience
     */
    'coordinatorId'?: string;
    /**
     * 作成日時
     * @type {number}
     * @memberof Experience
     */
    'createdAt'?: number;
    /**
     * 説明
     * @type {string}
     * @memberof Experience
     */
    'description'?: string;
    /**
     * アクセス方法
     * @type {string}
     * @memberof Experience
     */
    'direction'?: string;
    /**
     * 体験時間(分)
     * @type {number}
     * @memberof Experience
     */
    'duration'?: number;
    /**
     * 募集終了日時
     * @type {number}
     * @memberof Experience
     */
    'endAt'?: number;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof Experience
     */
    'experienceTypeId'?: string;
    /**
     * 開催場所(住所1)
     * @type {string}
     * @memberof Experience
     */
    'hostAddressLine1'?: string;
    /**
     * 開催場所(住所2)
     * @type {string}
     * @memberof Experience
     */
    'hostAddressLine2'?: string;
    /**
     * 開催場所(市区町村)
     * @type {string}
     * @memberof Experience
     */
    'hostCity'?: string;
    /**
     * 開催場所(郵便番号)
     * @type {string}
     * @memberof Experience
     */
    'hostPostalCode'?: string;
    /**
     * 開催場所(都道府県コード)
     * @type {number}
     * @memberof Experience
     */
    'hostPrefectureCode'?: number;
    /**
     * 体験ID
     * @type {string}
     * @memberof Experience
     */
    'id'?: string;
    /**
     * メディア一覧
     * @type {Array<ExperienceMedia>}
     * @memberof Experience
     */
    'media'?: Array<ExperienceMedia>;
    /**
     * 大人料金
     * @type {number}
     * @memberof Experience
     */
    'priceAdult'?: number;
    /**
     * 小学生料金
     * @type {number}
     * @memberof Experience
     */
    'priceElementarySchool'?: number;
    /**
     * 中学生料金
     * @type {number}
     * @memberof Experience
     */
    'priceJuniorHighSchool'?: number;
    /**
     * 幼児料金
     * @type {number}
     * @memberof Experience
     */
    'pricePreschool'?: number;
    /**
     * シニア料金
     * @type {number}
     * @memberof Experience
     */
    'priceSenior'?: number;
    /**
     * プロデューサーID
     * @type {string}
     * @memberof Experience
     */
    'producerId'?: string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof Experience
     */
    'promotionVideoUrl'?: string;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof Experience
     */
    'public'?: boolean;
    /**
     * おすすめポイント1
     * @type {string}
     * @memberof Experience
     */
    'recommendedPoint1'?: string;
    /**
     * おすすめポイント2
     * @type {string}
     * @memberof Experience
     */
    'recommendedPoint2'?: string;
    /**
     * おすすめポイント3
     * @type {string}
     * @memberof Experience
     */
    'recommendedPoint3'?: string;
    /**
     * 定員オーバー設定
     * @type {boolean}
     * @memberof Experience
     */
    'soldOut'?: boolean;
    /**
     * 募集開始日時
     * @type {number}
     * @memberof Experience
     */
    'startAt'?: number;
    /**
     * 販売状況
     * @type {number}
     * @memberof Experience
     */
    'status'?: number;
    /**
     * タイトル
     * @type {string}
     * @memberof Experience
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Experience
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface ExperienceMedia
 */
export interface ExperienceMedia {
    /**
     * サムネイルとして使用
     * @type {boolean}
     * @memberof ExperienceMedia
     */
    'isThumbnail'?: boolean;
    /**
     * メディアURL
     * @type {string}
     * @memberof ExperienceMedia
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ExperienceResponse
 */
export interface ExperienceResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof ExperienceResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 
     * @type {Experience}
     * @memberof ExperienceResponse
     */
    'experience'?: Experience;
    /**
     * 
     * @type {ExperienceType}
     * @memberof ExperienceResponse
     */
    'experienceType'?: ExperienceType;
    /**
     * 
     * @type {Producer}
     * @memberof ExperienceResponse
     */
    'producer'?: Producer;
}
/**
 * 体験種別情報
 * @export
 * @interface ExperienceType
 */
export interface ExperienceType {
    /**
     * 登録日時
     * @type {number}
     * @memberof ExperienceType
     */
    'createdAt'?: number;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof ExperienceType
     */
    'id'?: string;
    /**
     * 体験種別名
     * @type {string}
     * @memberof ExperienceType
     */
    'name'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof ExperienceType
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface ExperiencesResponse
 */
export interface ExperiencesResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof ExperiencesResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 体験種別一覧
     * @type {Array<ExperienceType>}
     * @memberof ExperiencesResponse
     */
    'experienceTypes'?: Array<ExperienceType>;
    /**
     * 体験一覧
     * @type {Array<Experience>}
     * @memberof ExperiencesResponse
     */
    'experiences'?: Array<Experience>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof ExperiencesResponse
     */
    'producers'?: Array<Producer>;
    /**
     * 体験合計数
     * @type {number}
     * @memberof ExperiencesResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface ForgotAuthPasswordRequest
 */
export interface ForgotAuthPasswordRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof ForgotAuthPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface GetUploadURLRequest
 */
export interface GetUploadURLRequest {
    /**
     * ファイル種別
     * @type {string}
     * @memberof GetUploadURLRequest
     */
    'fileType': string;
}
/**
 * ライブ配信情報
 * @export
 * @interface Live
 */
export interface Live {
    /**
     * コメント
     * @type {string}
     * @memberof Live
     */
    'comment'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof Live
     */
    'createdAt'?: number;
    /**
     * ライブ配信終了日時
     * @type {number}
     * @memberof Live
     */
    'endAt'?: number;
    /**
     * ライブ配信ID
     * @type {string}
     * @memberof Live
     */
    'id'?: string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof Live
     */
    'producerId'?: string;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof Live
     */
    'productIds'?: Array<string>;
    /**
     * マルシェ開催スケジュールID
     * @type {string}
     * @memberof Live
     */
    'scheduleId'?: string;
    /**
     * ライブ配信開始日時
     * @type {number}
     * @memberof Live
     */
    'startAt'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof Live
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface LiveComment
 */
export interface LiveComment {
    /**
     * アカウントID
     * @type {string}
     * @memberof LiveComment
     */
    'accountId'?: string;
    /**
     * コメント
     * @type {string}
     * @memberof LiveComment
     */
    'comment'?: string;
    /**
     * コメント無効フラグ
     * @type {boolean}
     * @memberof LiveComment
     */
    'disabled'?: boolean;
    /**
     * コメントID
     * @type {string}
     * @memberof LiveComment
     */
    'id'?: string;
    /**
     * 投稿日時
     * @type {number}
     * @memberof LiveComment
     */
    'publishedAt'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof LiveComment
     */
    'thumbnailUrl'?: string;
    /**
     * ユーザーID
     * @type {string}
     * @memberof LiveComment
     */
    'userId'?: string;
    /**
     * ユーザー名
     * @type {string}
     * @memberof LiveComment
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface LiveCommentsResponse
 */
export interface LiveCommentsResponse {
    /**
     * コメント一覧
     * @type {Array<LiveComment>}
     * @memberof LiveCommentsResponse
     */
    'comments'?: Array<LiveComment>;
    /**
     * 次の取得開始位置
     * @type {string}
     * @memberof LiveCommentsResponse
     */
    'nextToken'?: string;
}
/**
 * 注文履歴情報
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 対応完了日時
     * @type {number}
     * @memberof Order
     */
    'completedAt'?: number;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Order
     */
    'coordinatorId'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof Order
     */
    'createdAt'?: number;
    /**
     * 
     * @type {OrderExperience}
     * @memberof Order
     */
    'experience'?: OrderExperience;
    /**
     * 配送情報一覧
     * @type {Array<OrderFulfillment>}
     * @memberof Order
     */
    'fulfillments'?: Array<OrderFulfillment>;
    /**
     * 注文履歴ID
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 注文商品一覧
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    'items'?: Array<OrderItem>;
    /**
     * 注文管理用ID
     * @type {number}
     * @memberof Order
     */
    'managementId'?: number;
    /**
     * 
     * @type {TypesOrderMetadata}
     * @memberof Order
     */
    'metadata'?: TypesOrderMetadata;
    /**
     * 
     * @type {OrderPayment}
     * @memberof Order
     */
    'payment'?: OrderPayment;
    /**
     * プロモーションID
     * @type {string}
     * @memberof Order
     */
    'promotionId'?: string;
    /**
     * 
     * @type {OrderRefund}
     * @memberof Order
     */
    'refund'?: OrderRefund;
    /**
     * 発送連絡時のメッセージ
     * @type {string}
     * @memberof Order
     */
    'shippingMessage'?: string;
    /**
     * 注文ステータス
     * @type {number}
     * @memberof Order
     */
    'status'?: number;
    /**
     * 注文種別
     * @type {number}
     * @memberof Order
     */
    'type'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof Order
     */
    'updatedAt'?: number;
    /**
     * ユーザーID
     * @type {string}
     * @memberof Order
     */
    'userId'?: string;
}
/**
 * 注文体験情報
 * @export
 * @interface OrderExperience
 */
export interface OrderExperience {
    /**
     * 大人人数
     * @type {number}
     * @memberof OrderExperience
     */
    'adultCount'?: number;
    /**
     * 大人価格
     * @type {number}
     * @memberof OrderExperience
     */
    'adultPrice'?: number;
    /**
     * 小学生人数
     * @type {number}
     * @memberof OrderExperience
     */
    'elementarySchoolCount'?: number;
    /**
     * 小学生価格
     * @type {number}
     * @memberof OrderExperience
     */
    'elementarySchoolPrice'?: number;
    /**
     * 体験ID
     * @type {string}
     * @memberof OrderExperience
     */
    'experienceId'?: string;
    /**
     * 中学生人数
     * @type {number}
     * @memberof OrderExperience
     */
    'juniorHighSchoolCount'?: number;
    /**
     * 中学生価格
     * @type {number}
     * @memberof OrderExperience
     */
    'juniorHighSchoolPrice'?: number;
    /**
     * 幼児人数
     * @type {number}
     * @memberof OrderExperience
     */
    'preschoolCount'?: number;
    /**
     * 幼児価格
     * @type {number}
     * @memberof OrderExperience
     */
    'preschoolPrice'?: number;
    /**
     * 
     * @type {TypesOrderExperienceRemarks}
     * @memberof OrderExperience
     */
    'remarks'?: TypesOrderExperienceRemarks;
    /**
     * シニア人数
     * @type {number}
     * @memberof OrderExperience
     */
    'seniorCount'?: number;
    /**
     * シニア価格
     * @type {number}
     * @memberof OrderExperience
     */
    'seniorPrice'?: number;
}
/**
 * 
 * @export
 * @interface OrderFulfillment
 */
export interface OrderFulfillment {
    /**
     * 住所ID
     * @type {string}
     * @memberof OrderFulfillment
     */
    'addressId'?: string;
    /**
     * 町名・番地
     * @type {string}
     * @memberof OrderFulfillment
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof OrderFulfillment
     */
    'addressLine2'?: string;
    /**
     * 箱の通番
     * @type {number}
     * @memberof OrderFulfillment
     */
    'boxNumber'?: number;
    /**
     * 箱の占有率
     * @type {number}
     * @memberof OrderFulfillment
     */
    'boxRate'?: number;
    /**
     * 箱の大きさ
     * @type {number}
     * @memberof OrderFulfillment
     */
    'boxSize'?: number;
    /**
     * 市区町村
     * @type {string}
     * @memberof OrderFulfillment
     */
    'city'?: string;
    /**
     * 氏名（名）
     * @type {string}
     * @memberof OrderFulfillment
     */
    'firstname'?: string;
    /**
     * 氏名(名:かな)
     * @type {string}
     * @memberof OrderFulfillment
     */
    'firstnameKana'?: string;
    /**
     * 配送情報ID
     * @type {string}
     * @memberof OrderFulfillment
     */
    'fulfillmentId'?: string;
    /**
     * 氏名（姓）
     * @type {string}
     * @memberof OrderFulfillment
     */
    'lastname'?: string;
    /**
     * 氏名(姓:かな)
     * @type {string}
     * @memberof OrderFulfillment
     */
    'lastnameKana'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof OrderFulfillment
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof OrderFulfillment
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {string}
     * @memberof OrderFulfillment
     */
    'prefecture'?: string;
    /**
     * 都道府県コード
     * @type {number}
     * @memberof OrderFulfillment
     */
    'prefectureCode'?: number;
    /**
     * 配送日時
     * @type {number}
     * @memberof OrderFulfillment
     */
    'shippedAt'?: number;
    /**
     * 配送会社
     * @type {number}
     * @memberof OrderFulfillment
     */
    'shippingCarrier'?: number;
    /**
     * 配送方法
     * @type {number}
     * @memberof OrderFulfillment
     */
    'shippingType'?: number;
    /**
     * 配送状況
     * @type {number}
     * @memberof OrderFulfillment
     */
    'status'?: number;
    /**
     * 伝票番号
     * @type {string}
     * @memberof OrderFulfillment
     */
    'trackingNumber'?: string;
}
/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 配送情報ID
     * @type {string}
     * @memberof OrderItem
     */
    'fulfillmentId'?: string;
    /**
     * 購入価格(税込)
     * @type {number}
     * @memberof OrderItem
     */
    'price'?: number;
    /**
     * 商品ID
     * @type {string}
     * @memberof OrderItem
     */
    'productId'?: string;
    /**
     * 購入数量
     * @type {number}
     * @memberof OrderItem
     */
    'quantity'?: number;
}
/**
 * 支払い情報
 * @export
 * @interface OrderPayment
 */
export interface OrderPayment {
    /**
     * 住所ID
     * @type {string}
     * @memberof OrderPayment
     */
    'addressId'?: string;
    /**
     * 町名・番地
     * @type {string}
     * @memberof OrderPayment
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof OrderPayment
     */
    'addressLine2'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof OrderPayment
     */
    'city'?: string;
    /**
     * 割引金額(税込)
     * @type {number}
     * @memberof OrderPayment
     */
    'discount'?: number;
    /**
     * 氏名（名）
     * @type {string}
     * @memberof OrderPayment
     */
    'firstname'?: string;
    /**
     * 氏名(名:かな)
     * @type {string}
     * @memberof OrderPayment
     */
    'firstnameKana'?: string;
    /**
     * 氏名（姓）
     * @type {string}
     * @memberof OrderPayment
     */
    'lastname'?: string;
    /**
     * 氏名(姓:かな)
     * @type {string}
     * @memberof OrderPayment
     */
    'lastnameKana'?: string;
    /**
     * 決済手段種別
     * @type {number}
     * @memberof OrderPayment
     */
    'methodType'?: number;
    /**
     * 注文日時
     * @type {number}
     * @memberof OrderPayment
     */
    'orderedAt'?: number;
    /**
     * 支払日時
     * @type {number}
     * @memberof OrderPayment
     */
    'paidAt'?: number;
    /**
     * 電話番号
     * @type {string}
     * @memberof OrderPayment
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof OrderPayment
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {string}
     * @memberof OrderPayment
     */
    'prefecture'?: string;
    /**
     * 都道府県コード
     * @type {number}
     * @memberof OrderPayment
     */
    'prefectureCode'?: number;
    /**
     * 配送手数料(税込)
     * @type {number}
     * @memberof OrderPayment
     */
    'shippingFee'?: number;
    /**
     * 支払い状況
     * @type {number}
     * @memberof OrderPayment
     */
    'status'?: number;
    /**
     * 購入金額(税込)
     * @type {number}
     * @memberof OrderPayment
     */
    'subtotal'?: number;
    /**
     * 合計金額(税込)
     * @type {number}
     * @memberof OrderPayment
     */
    'total'?: number;
    /**
     * 取引ID
     * @type {string}
     * @memberof OrderPayment
     */
    'transactionId'?: string;
}
/**
 * 注文キャンセル情報
 * @export
 * @interface OrderRefund
 */
export interface OrderRefund {
    /**
     * 注文キャンセルフラグ
     * @type {boolean}
     * @memberof OrderRefund
     */
    'canceled'?: boolean;
    /**
     * 注文キャンセル日時
     * @type {number}
     * @memberof OrderRefund
     */
    'canceledAt'?: number;
    /**
     * 注文キャンセル理由
     * @type {string}
     * @memberof OrderRefund
     */
    'reason'?: string;
    /**
     * 返金金額
     * @type {number}
     * @memberof OrderRefund
     */
    'total'?: number;
    /**
     * 注文キャンセル種別
     * @type {number}
     * @memberof OrderRefund
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof OrderResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 
     * @type {Experience}
     * @memberof OrderResponse
     */
    'experience'?: Experience;
    /**
     * 
     * @type {Order}
     * @memberof OrderResponse
     */
    'order'?: Order;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof OrderResponse
     */
    'products'?: Array<Product>;
    /**
     * 
     * @type {Promotion}
     * @memberof OrderResponse
     */
    'promotion'?: Promotion;
    /**
     * 
     * @type {TypesUser}
     * @memberof OrderResponse
     */
    'user'?: TypesUser;
}
/**
 * 
 * @export
 * @interface OrdersResponse
 */
export interface OrdersResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof OrdersResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 注文履歴一覧
     * @type {Array<Order>}
     * @memberof OrdersResponse
     */
    'orders'?: Array<Order>;
    /**
     * プロモーション一覧
     * @type {Array<Promotion>}
     * @memberof OrdersResponse
     */
    'promotions'?: Array<Promotion>;
    /**
     * 注文履歴合計数
     * @type {number}
     * @memberof OrdersResponse
     */
    'total'?: number;
    /**
     * 購入者一覧
     * @type {Array<TypesUser>}
     * @memberof OrdersResponse
     */
    'users'?: Array<TypesUser>;
}
/**
 * 
 * @export
 * @interface PaymentSystem
 */
export interface PaymentSystem {
    /**
     * 登録日時
     * @type {number}
     * @memberof PaymentSystem
     */
    'createdAt'?: number;
    /**
     * 決済手段種別
     * @type {number}
     * @memberof PaymentSystem
     */
    'methodType'?: number;
    /**
     * 決済システム状態
     * @type {number}
     * @memberof PaymentSystem
     */
    'status'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof PaymentSystem
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface PaymentSystemsResponse
 */
export interface PaymentSystemsResponse {
    /**
     * 決済システム一覧
     * @type {Array<PaymentSystem>}
     * @memberof PaymentSystemsResponse
     */
    'systems'?: Array<PaymentSystem>;
}
/**
 * 
 * @export
 * @interface PostalCodeResponse
 */
export interface PostalCodeResponse {
    /**
     * 市区町村名
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'city'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'postalCode'?: string;
    /**
     * 都道府県名
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'prefecture'?: string;
    /**
     * 都道府県コード
     * @type {number}
     * @memberof PostalCodeResponse
     */
    'prefectureCode'?: number;
    /**
     * 町域名
     * @type {string}
     * @memberof PostalCodeResponse
     */
    'town'?: string;
}
/**
 * 生産者情報
 * @export
 * @interface Producer
 */
export interface Producer {
    /**
     * 町名・番地
     * @type {string}
     * @memberof Producer
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof Producer
     */
    'addressLine2'?: string;
    /**
     * 購入特典映像URL
     * @type {string}
     * @memberof Producer
     */
    'bonusVideoUrl'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof Producer
     */
    'city'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof Producer
     */
    'createdAt'?: number;
    /**
     * メールアドレス
     * @type {string}
     * @memberof Producer
     */
    'email'?: string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof Producer
     */
    'facebookId'?: string;
    /**
     * 名
     * @type {string}
     * @memberof Producer
     */
    'firstname'?: string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof Producer
     */
    'firstnameKana'?: string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof Producer
     */
    'headerUrl'?: string;
    /**
     * 生産者ID
     * @type {string}
     * @memberof Producer
     */
    'id'?: string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof Producer
     */
    'instagramId'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof Producer
     */
    'lastname'?: string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof Producer
     */
    'lastnameKana'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof Producer
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof Producer
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {number}
     * @memberof Producer
     */
    'prefectureCode'?: number;
    /**
     * 紹介文
     * @type {string}
     * @memberof Producer
     */
    'profile'?: string;
    /**
     * 紹介映像URL
     * @type {string}
     * @memberof Producer
     */
    'promotionVideoUrl'?: string;
    /**
     * 管理者の状態
     * @type {number}
     * @memberof Producer
     */
    'status'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Producer
     */
    'thumbnailUrl'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Producer
     */
    'updatedAt'?: number;
    /**
     * 生産者名
     * @type {string}
     * @memberof Producer
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ProducerResponse
 */
export interface ProducerResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof ProducerResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 
     * @type {Producer}
     * @memberof ProducerResponse
     */
    'producer'?: Producer;
    /**
     * 店舗情報
     * @type {Array<TypesShop>}
     * @memberof ProducerResponse
     */
    'shops'?: Array<TypesShop>;
}
/**
 * 
 * @export
 * @interface ProducersResponse
 */
export interface ProducersResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof ProducersResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof ProducersResponse
     */
    'producers'?: Array<Producer>;
    /**
     * 店舗一覧
     * @type {Array<TypesShop>}
     * @memberof ProducersResponse
     */
    'shops'?: Array<TypesShop>;
    /**
     * 合計数
     * @type {number}
     * @memberof ProducersResponse
     */
    'total'?: number;
}
/**
 * 商品情報
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 箱の占有率(サイズ:60)
     * @type {number}
     * @memberof Product
     */
    'box60Rate'?: number;
    /**
     * 箱の占有率(サイズ:80)
     * @type {number}
     * @memberof Product
     */
    'box80Rate'?: number;
    /**
     * 箱の占有率(サイズ:100)
     * @type {number}
     * @memberof Product
     */
    'box100Rate'?: number;
    /**
     * 商品種別ID
     * @type {string}
     * @memberof Product
     */
    'categoryId'?: string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Product
     */
    'coordinatorId'?: string;
    /**
     * 原価
     * @type {number}
     * @memberof Product
     */
    'cost'?: number;
    /**
     * 登録日時
     * @type {number}
     * @memberof Product
     */
    'createdAt'?: number;
    /**
     * 配送方法
     * @type {number}
     * @memberof Product
     */
    'deliveryType'?: number;
    /**
     * 商品説明
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * 販売終了日時
     * @type {number}
     * @memberof Product
     */
    'endAt'?: number;
    /**
     * 賞味期限(単位:日)
     * @type {number}
     * @memberof Product
     */
    'expirationDate'?: number;
    /**
     * 商品ID
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * 在庫数
     * @type {number}
     * @memberof Product
     */
    'inventory'?: number;
    /**
     * 数量単位説明
     * @type {string}
     * @memberof Product
     */
    'itemDescription'?: string;
    /**
     * 数量単位
     * @type {string}
     * @memberof Product
     */
    'itemUnit'?: string;
    /**
     * メディア一覧
     * @type {Array<ProductMedia>}
     * @memberof Product
     */
    'media'?: Array<ProductMedia>;
    /**
     * 商品名
     * @type {string}
     * @memberof Product
     */
    'name'?: string;
    /**
     * 原産地(市区町村)
     * @type {string}
     * @memberof Product
     */
    'originCity'?: string;
    /**
     * 原産地(都道府県)
     * @type {number}
     * @memberof Product
     */
    'originPrefectureCode'?: number;
    /**
     * 販売価格(税込)
     * @type {number}
     * @memberof Product
     */
    'price'?: number;
    /**
     * 生産者ID
     * @type {string}
     * @memberof Product
     */
    'producerId'?: string;
    /**
     * 商品タグID一覧
     * @type {Array<string>}
     * @memberof Product
     */
    'productTagIds'?: Array<string>;
    /**
     * 品目ID
     * @type {string}
     * @memberof Product
     */
    'productTypeId'?: string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Product
     */
    'public'?: boolean;
    /**
     * おすすめポイント1
     * @type {string}
     * @memberof Product
     */
    'recommendedPoint1'?: string;
    /**
     * おすすめポイント2
     * @type {string}
     * @memberof Product
     */
    'recommendedPoint2'?: string;
    /**
     * おすすめポイント3
     * @type {string}
     * @memberof Product
     */
    'recommendedPoint3'?: string;
    /**
     * 販売開始日時
     * @type {number}
     * @memberof Product
     */
    'startAt'?: number;
    /**
     * 販売状況
     * @type {number}
     * @memberof Product
     */
    'status'?: number;
    /**
     * 保存方法
     * @type {number}
     * @memberof Product
     */
    'storageMethodType'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof Product
     */
    'updatedAt'?: number;
    /**
     * 重量(kg,少数第一位まで)
     * @type {number}
     * @memberof Product
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface ProductMedia
 */
export interface ProductMedia {
    /**
     * サムネイルとして使用
     * @type {boolean}
     * @memberof ProductMedia
     */
    'isThumbnail'?: boolean;
    /**
     * メディアURL
     * @type {string}
     * @memberof ProductMedia
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * 
     * @type {Category}
     * @memberof ProductResponse
     */
    'category'?: Category;
    /**
     * 
     * @type {Coordinator}
     * @memberof ProductResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 
     * @type {Producer}
     * @memberof ProductResponse
     */
    'producer'?: Producer;
    /**
     * 
     * @type {Product}
     * @memberof ProductResponse
     */
    'product'?: Product;
    /**
     * 商品タグ一覧
     * @type {Array<ProductTag>}
     * @memberof ProductResponse
     */
    'productTags'?: Array<ProductTag>;
    /**
     * 
     * @type {ProductType}
     * @memberof ProductResponse
     */
    'productType'?: ProductType;
}
/**
 * 商品タグ情報
 * @export
 * @interface ProductTag
 */
export interface ProductTag {
    /**
     * 登録日時
     * @type {number}
     * @memberof ProductTag
     */
    'createdAt'?: number;
    /**
     * 商品タグID
     * @type {string}
     * @memberof ProductTag
     */
    'id'?: string;
    /**
     * 商品タグ名
     * @type {string}
     * @memberof ProductTag
     */
    'name'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof ProductTag
     */
    'updatedAt'?: number;
}
/**
 * 品目情報
 * @export
 * @interface ProductType
 */
export interface ProductType {
    /**
     * 商品種別ID
     * @type {string}
     * @memberof ProductType
     */
    'categoryId'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof ProductType
     */
    'createdAt'?: number;
    /**
     * アイコンURL
     * @type {string}
     * @memberof ProductType
     */
    'iconUrl'?: string;
    /**
     * 品目ID
     * @type {string}
     * @memberof ProductType
     */
    'id'?: string;
    /**
     * 品目名
     * @type {string}
     * @memberof ProductType
     */
    'name'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof ProductType
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface ProductsResponse
 */
export interface ProductsResponse {
    /**
     * 商品種別一覧
     * @type {Array<Category>}
     * @memberof ProductsResponse
     */
    'categories'?: Array<Category>;
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof ProductsResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof ProductsResponse
     */
    'producers'?: Array<Producer>;
    /**
     * 商品タグ一覧
     * @type {Array<ProductTag>}
     * @memberof ProductsResponse
     */
    'productTags'?: Array<ProductTag>;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof ProductsResponse
     */
    'productTypes'?: Array<ProductType>;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof ProductsResponse
     */
    'products'?: Array<Product>;
    /**
     * 商品合計数
     * @type {number}
     * @memberof ProductsResponse
     */
    'total'?: number;
}
/**
 * プロモーション情報
 * @export
 * @interface Promotion
 */
export interface Promotion {
    /**
     * クーポンコード
     * @type {string}
     * @memberof Promotion
     */
    'code'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof Promotion
     */
    'createdAt'?: number;
    /**
     * 詳細説明
     * @type {string}
     * @memberof Promotion
     */
    'description'?: string;
    /**
     * 割引額(%/円)
     * @type {number}
     * @memberof Promotion
     */
    'discountRate'?: number;
    /**
     * 割引計算方法
     * @type {number}
     * @memberof Promotion
     */
    'discountType'?: number;
    /**
     * クーポン使用可能日時(終了)
     * @type {number}
     * @memberof Promotion
     */
    'endAt'?: number;
    /**
     * プロモーションID
     * @type {string}
     * @memberof Promotion
     */
    'id'?: string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Promotion
     */
    'public'?: boolean;
    /**
     * 店舗ID
     * @type {string}
     * @memberof Promotion
     */
    'shopId'?: string;
    /**
     * クーポン使用可能日時(開始)
     * @type {number}
     * @memberof Promotion
     */
    'startAt'?: number;
    /**
     * ステータス
     * @type {number}
     * @memberof Promotion
     */
    'status'?: number;
    /**
     * 対象商品
     * @type {number}
     * @memberof Promotion
     */
    'targetType'?: number;
    /**
     * タイトル
     * @type {string}
     * @memberof Promotion
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Promotion
     */
    'updatedAt'?: number;
    /**
     * 使用による割引合計額
     * @type {number}
     * @memberof Promotion
     */
    'usedAmount'?: number;
    /**
     * 使用回数
     * @type {number}
     * @memberof Promotion
     */
    'usedCount'?: number;
}
/**
 * 
 * @export
 * @interface PromotionResponse
 */
export interface PromotionResponse {
    /**
     * 
     * @type {Promotion}
     * @memberof PromotionResponse
     */
    'promotion'?: Promotion;
    /**
     * 
     * @type {TypesShop}
     * @memberof PromotionResponse
     */
    'shop'?: TypesShop;
}
/**
 * 
 * @export
 * @interface RefreshAuthTokenRequest
 */
export interface RefreshAuthTokenRequest {
    /**
     * 更新トークン
     * @type {string}
     * @memberof RefreshAuthTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ResetAuthPasswordRequest
 */
export interface ResetAuthPasswordRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'email': string;
    /**
     * パスワード
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'password'?: string;
    /**
     * パスワード (確認用)
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'passwordConfirmation': string;
    /**
     * 検証コード
     * @type {string}
     * @memberof ResetAuthPasswordRequest
     */
    'verifyCode': string;
}
/**
 * マルシェ開催情報
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 承認フラグ
     * @type {boolean}
     * @memberof Schedule
     */
    'approved'?: boolean;
    /**
     * コーディネータID
     * @type {string}
     * @memberof Schedule
     */
    'coordinatorId'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof Schedule
     */
    'createdAt'?: number;
    /**
     * 説明
     * @type {string}
     * @memberof Schedule
     */
    'description'?: string;
    /**
     * 配信終了日時
     * @type {number}
     * @memberof Schedule
     */
    'endAt'?: number;
    /**
     * スケジュールID
     * @type {string}
     * @memberof Schedule
     */
    'id'?: string;
    /**
     * 蓋絵URL
     * @type {string}
     * @memberof Schedule
     */
    'imageUrl'?: string;
    /**
     * オープニング動画URL
     * @type {string}
     * @memberof Schedule
     */
    'openingVideoUrl'?: string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof Schedule
     */
    'public'?: boolean;
    /**
     * 店舗ID
     * @type {string}
     * @memberof Schedule
     */
    'shopId'?: string;
    /**
     * 配信開始日時
     * @type {number}
     * @memberof Schedule
     */
    'startAt'?: number;
    /**
     * 開催状況
     * @type {number}
     * @memberof Schedule
     */
    'status'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Schedule
     */
    'thumbnailUrl'?: string;
    /**
     * タイトル
     * @type {string}
     * @memberof Schedule
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Schedule
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface ScheduleResponse
 */
export interface ScheduleResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof ScheduleResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 
     * @type {Schedule}
     * @memberof ScheduleResponse
     */
    'schedule'?: Schedule;
}
/**
 * 配送設定情報
 * @export
 * @interface Shipping
 */
export interface Shipping {
    /**
     * 箱サイズ60の追加（冷凍便）追加配送料(税込)
     * @type {number}
     * @memberof Shipping
     */
    'box60Frozen'?: number;
    /**
     * 箱サイズ60の通常（常温・冷蔵便）配送料一覧
     * @type {Array<ShippingRate>}
     * @memberof Shipping
     */
    'box60Rates'?: Array<ShippingRate>;
    /**
     * 箱サイズ80の追加（冷凍便）追加配送料(税込)
     * @type {number}
     * @memberof Shipping
     */
    'box80Frozen'?: number;
    /**
     * 箱サイズ80の通常（常温・冷蔵便）配送料一覧
     * @type {Array<ShippingRate>}
     * @memberof Shipping
     */
    'box80Rates'?: Array<ShippingRate>;
    /**
     * 箱サイズ100の追加（冷凍便）追加配送料(税込)
     * @type {number}
     * @memberof Shipping
     */
    'box100Frozen'?: number;
    /**
     * 箱サイズ100の通常（常温・冷蔵便）配送料一覧
     * @type {Array<ShippingRate>}
     * @memberof Shipping
     */
    'box100Rates'?: Array<ShippingRate>;
    /**
     * 登録日時
     * @type {number}
     * @memberof Shipping
     */
    'createdAt'?: number;
    /**
     * 送料無料になる金額(税込)
     * @type {number}
     * @memberof Shipping
     */
    'freeShippingRates'?: number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof Shipping
     */
    'hasFreeShipping'?: boolean;
    /**
     * 配送設定ID
     * @type {string}
     * @memberof Shipping
     */
    'id'?: string;
    /**
     * デフォルト設定フラグ
     * @type {boolean}
     * @memberof Shipping
     */
    'isDefault'?: boolean;
    /**
     * 配送設定名
     * @type {string}
     * @memberof Shipping
     */
    'name'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Shipping
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface ShippingRate
 */
export interface ShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof ShippingRate
     */
    'name'?: string;
    /**
     * No.
     * @type {number}
     * @memberof ShippingRate
     */
    'number'?: number;
    /**
     * 対象都道府県一覧
     * @type {Array<number>}
     * @memberof ShippingRate
     */
    'prefectureCodes'?: Array<number>;
    /**
     * 配送料金(税込)
     * @type {number}
     * @memberof ShippingRate
     */
    'price'?: number;
}
/**
 * 
 * @export
 * @interface SignInRequest
 */
export interface SignInRequest {
    /**
     * パスワード
     * @type {string}
     * @memberof SignInRequest
     */
    'password': string;
    /**
     * ユーザー名 (メールアドレス)
     * @type {string}
     * @memberof SignInRequest
     */
    'username': string;
}
/**
 * スポット情報
 * @export
 * @interface Spot
 */
export interface Spot {
    /**
     * 承認フラグ
     * @type {boolean}
     * @memberof Spot
     */
    'approved'?: boolean;
    /**
     * 登録日時
     * @type {number}
     * @memberof Spot
     */
    'createdAt'?: number;
    /**
     * 説明
     * @type {string}
     * @memberof Spot
     */
    'description'?: string;
    /**
     * スポットID
     * @type {string}
     * @memberof Spot
     */
    'id'?: string;
    /**
     * 座標情報:緯度
     * @type {number}
     * @memberof Spot
     */
    'latitude'?: number;
    /**
     * 座標情報:経度
     * @type {number}
     * @memberof Spot
     */
    'longitude'?: number;
    /**
     * スポット名
     * @type {string}
     * @memberof Spot
     */
    'name'?: string;
    /**
     * スポット種別ID
     * @type {string}
     * @memberof Spot
     */
    'spotTypeId'?: string;
    /**
     * サムネイル画像URL
     * @type {string}
     * @memberof Spot
     */
    'thumbnailUrl'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Spot
     */
    'updatedAt'?: number;
    /**
     * ユーザーID
     * @type {string}
     * @memberof Spot
     */
    'userId'?: string;
    /**
     * 投稿者の種別
     * @type {number}
     * @memberof Spot
     */
    'userType'?: number;
}
/**
 * 
 * @export
 * @interface SpotResponse
 */
export interface SpotResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof SpotResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 
     * @type {Producer}
     * @memberof SpotResponse
     */
    'producer'?: Producer;
    /**
     * 
     * @type {Spot}
     * @memberof SpotResponse
     */
    'spot'?: Spot;
    /**
     * 
     * @type {SpotType}
     * @memberof SpotResponse
     */
    'spotType'?: SpotType;
    /**
     * 
     * @type {TypesUser}
     * @memberof SpotResponse
     */
    'user'?: TypesUser;
}
/**
 * スポット種別情報
 * @export
 * @interface SpotType
 */
export interface SpotType {
    /**
     * 登録日時
     * @type {number}
     * @memberof SpotType
     */
    'createdAt'?: number;
    /**
     * スポット種別ID
     * @type {string}
     * @memberof SpotType
     */
    'id'?: string;
    /**
     * スポット種別名
     * @type {string}
     * @memberof SpotType
     */
    'name'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof SpotType
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface SpotTypesResponse
 */
export interface SpotTypesResponse {
    /**
     * 体験種別一覧
     * @type {Array<SpotType>}
     * @memberof SpotTypesResponse
     */
    'spotTypes'?: Array<SpotType>;
    /**
     * 体験種別合計数
     * @type {number}
     * @memberof SpotTypesResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface SpotsResponse
 */
export interface SpotsResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof SpotsResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof SpotsResponse
     */
    'producers'?: Array<Producer>;
    /**
     * スポット種別一覧
     * @type {Array<SpotType>}
     * @memberof SpotsResponse
     */
    'spotTypes'?: Array<SpotType>;
    /**
     * スポット一覧
     * @type {Array<Spot>}
     * @memberof SpotsResponse
     */
    'spots'?: Array<Spot>;
    /**
     * 合計数
     * @type {number}
     * @memberof SpotsResponse
     */
    'total'?: number;
    /**
     * ユーザ一覧
     * @type {Array<TypesUser>}
     * @memberof SpotsResponse
     */
    'users'?: Array<TypesUser>;
}
/**
 * 
 * @export
 * @interface TypesActivateBroadcastMP4Request
 */
export interface TypesActivateBroadcastMP4Request {
    /**
     * 配信動画URL
     * @type {string}
     * @memberof TypesActivateBroadcastMP4Request
     */
    'inputUrl': string;
}
/**
 * 対応者情報
 * @export
 * @interface TypesAdmin
 */
export interface TypesAdmin {
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesAdmin
     */
    'createdAt'?: number;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesAdmin
     */
    'email'?: string;
    /**
     * 名
     * @type {string}
     * @memberof TypesAdmin
     */
    'firstname'?: string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesAdmin
     */
    'firstnameKana'?: string;
    /**
     * 管理者ID
     * @type {string}
     * @memberof TypesAdmin
     */
    'id'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesAdmin
     */
    'lastname'?: string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesAdmin
     */
    'lastnameKana'?: string;
    /**
     * 管理者種別
     * @type {number}
     * @memberof TypesAdmin
     */
    'role'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesAdmin
     */
    'updateAt'?: number;
}
/**
 * システム管理者情報
 * @export
 * @interface TypesAdministrator
 */
export interface TypesAdministrator {
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesAdministrator
     */
    'createdAt'?: number;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesAdministrator
     */
    'email'?: string;
    /**
     * 名
     * @type {string}
     * @memberof TypesAdministrator
     */
    'firstname'?: string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesAdministrator
     */
    'firstnameKana'?: string;
    /**
     * 管理者ID
     * @type {string}
     * @memberof TypesAdministrator
     */
    'id'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesAdministrator
     */
    'lastname'?: string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesAdministrator
     */
    'lastnameKana'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesAdministrator
     */
    'phoneNumber'?: string;
    /**
     * 管理者の状態
     * @type {number}
     * @memberof TypesAdministrator
     */
    'status'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesAdministrator
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface TypesAdministratorResponse
 */
export interface TypesAdministratorResponse {
    /**
     * 
     * @type {TypesAdministrator}
     * @memberof TypesAdministratorResponse
     */
    'administrator'?: TypesAdministrator;
}
/**
 * 
 * @export
 * @interface TypesAdministratorsResponse
 */
export interface TypesAdministratorsResponse {
    /**
     * システム管理者一覧
     * @type {Array<TypesAdministrator>}
     * @memberof TypesAdministratorsResponse
     */
    'administrators'?: Array<TypesAdministrator>;
    /**
     * 合計数
     * @type {number}
     * @memberof TypesAdministratorsResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesAnalyzeScheduleResponse
 */
export interface TypesAnalyzeScheduleResponse {
    /**
     * 合計視聴者数
     * @type {number}
     * @memberof TypesAnalyzeScheduleResponse
     */
    'totalViewers'?: number;
    /**
     * 視聴者数ログ
     * @type {Array<TypesBroadcastViewerLog>}
     * @memberof TypesAnalyzeScheduleResponse
     */
    'viewerLogs'?: Array<TypesBroadcastViewerLog>;
}
/**
 * 
 * @export
 * @interface TypesAnalyzeVideoResponse
 */
export interface TypesAnalyzeVideoResponse {
    /**
     * 合計視聴者数
     * @type {number}
     * @memberof TypesAnalyzeVideoResponse
     */
    'totalViewers'?: number;
    /**
     * 視聴者数ログ
     * @type {Array<TypesVideoViewerLog>}
     * @memberof TypesAnalyzeVideoResponse
     */
    'viewerLogs'?: Array<TypesVideoViewerLog>;
}
/**
 * 
 * @export
 * @interface TypesApproveScheduleRequest
 */
export interface TypesApproveScheduleRequest {
    /**
     * 承認フラグ
     * @type {boolean}
     * @memberof TypesApproveScheduleRequest
     */
    'approved'?: boolean;
}
/**
 * 
 * @export
 * @interface TypesApproveSpotRequest
 */
export interface TypesApproveSpotRequest {
    /**
     * 承認フラグ
     * @type {boolean}
     * @memberof TypesApproveSpotRequest
     */
    'approved'?: boolean;
}
/**
 * 
 * @export
 * @interface TypesAuthProvider
 */
export interface TypesAuthProvider {
    /**
     * 連携日時
     * @type {number}
     * @memberof TypesAuthProvider
     */
    'connectedAt'?: number;
    /**
     * プロバイダ種別
     * @type {number}
     * @memberof TypesAuthProvider
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface TypesAuthProvidersResponse
 */
export interface TypesAuthProvidersResponse {
    /**
     * プロバイダ一覧
     * @type {Array<TypesAuthProvider>}
     * @memberof TypesAuthProvidersResponse
     */
    'providers'?: Array<TypesAuthProvider>;
}
/**
 * 
 * @export
 * @interface TypesAuthYoutubeBroadcastRequest
 */
export interface TypesAuthYoutubeBroadcastRequest {
    /**
     * 連携先Youtubeアカウント
     * @type {string}
     * @memberof TypesAuthYoutubeBroadcastRequest
     */
    'youtubeHandle': string;
}
/**
 * 
 * @export
 * @interface TypesAuthYoutubeBroadcastResponse
 */
export interface TypesAuthYoutubeBroadcastResponse {
    /**
     * 認証URL
     * @type {string}
     * @memberof TypesAuthYoutubeBroadcastResponse
     */
    'url'?: string;
}
/**
 * ライブ配信情報
 * @export
 * @interface TypesBroadcast
 */
export interface TypesBroadcast {
    /**
     * オンデマンド配信URL
     * @type {string}
     * @memberof TypesBroadcast
     */
    'archiveUrl'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesBroadcast
     */
    'createdAt'?: number;
    /**
     * ライブ配信ID
     * @type {string}
     * @memberof TypesBroadcast
     */
    'id'?: string;
    /**
     * ライブ配信URL(入力)
     * @type {string}
     * @memberof TypesBroadcast
     */
    'inputUrl'?: string;
    /**
     * ライブ配信URL(出力)
     * @type {string}
     * @memberof TypesBroadcast
     */
    'outputUrl'?: string;
    /**
     * 開催スケジュールID
     * @type {string}
     * @memberof TypesBroadcast
     */
    'scheduleId'?: string;
    /**
     * ライブ配信状況
     * @type {number}
     * @memberof TypesBroadcast
     */
    'status'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesBroadcast
     */
    'updatedAt'?: number;
    /**
     * Youtubeアカウント
     * @type {string}
     * @memberof TypesBroadcast
     */
    'youtubeAccount'?: string;
    /**
     * Youtube管理画面URL
     * @type {string}
     * @memberof TypesBroadcast
     */
    'youtubeAdminUrl'?: string;
    /**
     * Youtube視聴画面URL
     * @type {string}
     * @memberof TypesBroadcast
     */
    'youtubeViewerUrl'?: string;
}
/**
 * 
 * @export
 * @interface TypesBroadcastResponse
 */
export interface TypesBroadcastResponse {
    /**
     * 
     * @type {TypesBroadcast}
     * @memberof TypesBroadcastResponse
     */
    'broadcast'?: TypesBroadcast;
}
/**
 * 
 * @export
 * @interface TypesBroadcastViewerLog
 */
export interface TypesBroadcastViewerLog {
    /**
     * ライブ配信ID
     * @type {string}
     * @memberof TypesBroadcastViewerLog
     */
    'broadcastId'?: string;
    /**
     * 集計終了日時
     * @type {number}
     * @memberof TypesBroadcastViewerLog
     */
    'endAt'?: number;
    /**
     * 集計開始日時
     * @type {number}
     * @memberof TypesBroadcastViewerLog
     */
    'startAt'?: number;
    /**
     * 合計視聴者数
     * @type {number}
     * @memberof TypesBroadcastViewerLog
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesCallbackAuthYoutubeBroadcastRequest
 */
export interface TypesCallbackAuthYoutubeBroadcastRequest {
    /**
     * Google認証時に取得したcode
     * @type {string}
     * @memberof TypesCallbackAuthYoutubeBroadcastRequest
     */
    'authCode': string;
    /**
     * Google認証時に取得したstate
     * @type {string}
     * @memberof TypesCallbackAuthYoutubeBroadcastRequest
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface TypesCategoriesResponse
 */
export interface TypesCategoriesResponse {
    /**
     * 商品種別一覧
     * @type {Array<Category>}
     * @memberof TypesCategoriesResponse
     */
    'categories'?: Array<Category>;
    /**
     * 商品種別合計数
     * @type {number}
     * @memberof TypesCategoriesResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesCategoryResponse
 */
export interface TypesCategoryResponse {
    /**
     * 
     * @type {Category}
     * @memberof TypesCategoryResponse
     */
    'category'?: Category;
}
/**
 * 
 * @export
 * @interface TypesCompleteOrderRequest
 */
export interface TypesCompleteOrderRequest {
    /**
     * 発送連絡時のメッセージ
     * @type {string}
     * @memberof TypesCompleteOrderRequest
     */
    'shippingMessage'?: string;
}
/**
 * 
 * @export
 * @interface TypesConnectGoogleAccountRequest
 */
export interface TypesConnectGoogleAccountRequest {
    /**
     * 認証コード
     * @type {string}
     * @memberof TypesConnectGoogleAccountRequest
     */
    'code': string;
    /**
     * セキュア文字列（リプレイアタック対策）
     * @type {string}
     * @memberof TypesConnectGoogleAccountRequest
     */
    'nonce': string;
    /**
     * リダイレクトURI
     * @type {string}
     * @memberof TypesConnectGoogleAccountRequest
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface TypesConnectLINEAccountRequest
 */
export interface TypesConnectLINEAccountRequest {
    /**
     * 認証コード
     * @type {string}
     * @memberof TypesConnectLINEAccountRequest
     */
    'code': string;
    /**
     * セキュア文字列（リプレイアタック対策）
     * @type {string}
     * @memberof TypesConnectLINEAccountRequest
     */
    'nonce': string;
    /**
     * リダイレクトURI
     * @type {string}
     * @memberof TypesConnectLINEAccountRequest
     */
    'redirectUri': string;
}
/**
 * お問い合わせ情報
 * @export
 * @interface TypesContact
 */
export interface TypesContact {
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof TypesContact
     */
    'categoryId'?: string;
    /**
     * 内容
     * @type {string}
     * @memberof TypesContact
     */
    'content'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesContact
     */
    'createdAt'?: number;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesContact
     */
    'email'?: string;
    /**
     * お問い合わせID
     * @type {string}
     * @memberof TypesContact
     */
    'id'?: string;
    /**
     * 対応者メモ
     * @type {string}
     * @memberof TypesContact
     */
    'note'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesContact
     */
    'phoneNumber'?: string;
    /**
     * 対応者ID
     * @type {string}
     * @memberof TypesContact
     */
    'responderId'?: string;
    /**
     * お問い合わせステータス
     * @type {number}
     * @memberof TypesContact
     */
    'status'?: number;
    /**
     * 件名
     * @type {string}
     * @memberof TypesContact
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesContact
     */
    'updatedAt'?: number;
    /**
     * ユーザーID
     * @type {string}
     * @memberof TypesContact
     */
    'userId'?: string;
    /**
     * 氏名
     * @type {string}
     * @memberof TypesContact
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface TypesContactCategoriesResponse
 */
export interface TypesContactCategoriesResponse {
    /**
     * お問い合わせ種別一覧
     * @type {Array<TypesContactCategory>}
     * @memberof TypesContactCategoriesResponse
     */
    'contactCategories'?: Array<TypesContactCategory>;
}
/**
 * お問い合わせ種別情報
 * @export
 * @interface TypesContactCategory
 */
export interface TypesContactCategory {
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesContactCategory
     */
    'createdAt'?: number;
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof TypesContactCategory
     */
    'id'?: string;
    /**
     * お問い合わせ種別名
     * @type {string}
     * @memberof TypesContactCategory
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesContactCategory
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface TypesContactCategoryResponse
 */
export interface TypesContactCategoryResponse {
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesContactCategoryResponse
     */
    'createdAt'?: number;
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof TypesContactCategoryResponse
     */
    'id'?: string;
    /**
     * お問い合わせ種別名
     * @type {string}
     * @memberof TypesContactCategoryResponse
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesContactCategoryResponse
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface TypesContactReadResponse
 */
export interface TypesContactReadResponse {
    /**
     * お問い合わせID
     * @type {string}
     * @memberof TypesContactReadResponse
     */
    'contactId'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesContactReadResponse
     */
    'createdAt'?: number;
    /**
     * お問い合わせ既読管理ID
     * @type {string}
     * @memberof TypesContactReadResponse
     */
    'id'?: string;
    /**
     * 既読フラグ
     * @type {boolean}
     * @memberof TypesContactReadResponse
     */
    'read'?: boolean;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesContactReadResponse
     */
    'updatedAt'?: number;
    /**
     * 既読ユーザーID
     * @type {string}
     * @memberof TypesContactReadResponse
     */
    'userId'?: string;
    /**
     * 既読ユーザータイプ
     * @type {number}
     * @memberof TypesContactReadResponse
     */
    'userType'?: number;
}
/**
 * 
 * @export
 * @interface TypesContactResponse
 */
export interface TypesContactResponse {
    /**
     * 
     * @type {TypesContactCategory}
     * @memberof TypesContactResponse
     */
    'category'?: TypesContactCategory;
    /**
     * 
     * @type {TypesContact}
     * @memberof TypesContactResponse
     */
    'contact'?: TypesContact;
    /**
     * 
     * @type {TypesAdmin}
     * @memberof TypesContactResponse
     */
    'responder'?: TypesAdmin;
    /**
     * お問い合わせ会話履歴一覧
     * @type {Array<TypesThread>}
     * @memberof TypesContactResponse
     */
    'threads'?: Array<TypesThread>;
    /**
     * 
     * @type {TypesUser}
     * @memberof TypesContactResponse
     */
    'user'?: TypesUser;
}
/**
 * 
 * @export
 * @interface TypesContactsResponse
 */
export interface TypesContactsResponse {
    /**
     * 管理者一覧
     * @type {Array<TypesAdmin>}
     * @memberof TypesContactsResponse
     */
    'admins'?: Array<TypesAdmin>;
    /**
     * お問い合わせ種別一覧
     * @type {Array<TypesContactCategory>}
     * @memberof TypesContactsResponse
     */
    'categories'?: Array<TypesContactCategory>;
    /**
     * お問い合わせ一覧
     * @type {Array<TypesContact>}
     * @memberof TypesContactsResponse
     */
    'contacts'?: Array<TypesContact>;
    /**
     * お問い合わせ会話履歴一覧
     * @type {Array<TypesThread>}
     * @memberof TypesContactsResponse
     */
    'threads'?: Array<TypesThread>;
    /**
     * お問い合わせ合計
     * @type {number}
     * @memberof TypesContactsResponse
     */
    'total'?: number;
    /**
     * ユーザー一覧
     * @type {Array<TypesUser>}
     * @memberof TypesContactsResponse
     */
    'users'?: Array<TypesUser>;
}
/**
 * 
 * @export
 * @interface TypesCreateAdministratorRequest
 */
export interface TypesCreateAdministratorRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesCreateAdministratorRequest
     */
    'email': string;
    /**
     * 名
     * @type {string}
     * @memberof TypesCreateAdministratorRequest
     */
    'firstname': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesCreateAdministratorRequest
     */
    'firstnameKana': string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesCreateAdministratorRequest
     */
    'lastname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesCreateAdministratorRequest
     */
    'lastnameKana': string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesCreateAdministratorRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface TypesCreateCategoryRequest
 */
export interface TypesCreateCategoryRequest {
    /**
     * 商品種別名
     * @type {string}
     * @memberof TypesCreateCategoryRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesCreateContactReadRequest
 */
export interface TypesCreateContactReadRequest {
    /**
     * お問い合わせID
     * @type {string}
     * @memberof TypesCreateContactReadRequest
     */
    'contactId': string;
    /**
     * 送信者ID
     * @type {string}
     * @memberof TypesCreateContactReadRequest
     */
    'userId': string;
    /**
     * 送信者種別(不明:0, admin:1, uer:2, guest:3)
     * @type {number}
     * @memberof TypesCreateContactReadRequest
     */
    'userType'?: number;
}
/**
 * 
 * @export
 * @interface TypesCreateContactRequest
 */
export interface TypesCreateContactRequest {
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'categoryId': string;
    /**
     * お問い合わせ内容
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'content': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'email': string;
    /**
     * 対応者メモ
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'note'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'phoneNumber': string;
    /**
     * 対応者ID(null許容)
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'responderId'?: string;
    /**
     * お問い合わせ件名
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'title': string;
    /**
     * 問い合わせ作成者ID(null許容)
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'userId'?: string;
    /**
     * 氏名
     * @type {string}
     * @memberof TypesCreateContactRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface TypesCreateExperienceMedia
 */
export interface TypesCreateExperienceMedia {
    /**
     * サムネイルとして使用
     * @type {boolean}
     * @memberof TypesCreateExperienceMedia
     */
    'isThumbnail'?: boolean;
    /**
     * メディアURL
     * @type {string}
     * @memberof TypesCreateExperienceMedia
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface TypesCreateExperienceRequest
 */
export interface TypesCreateExperienceRequest {
    /**
     * 営業終了時間
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'businessCloseTime'?: string;
    /**
     * 営業開始時間
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'businessOpenTime'?: string;
    /**
     * コーディネータID
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'coordinatorId': string;
    /**
     * 説明
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'description': string;
    /**
     * アクセス方法
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'direction'?: string;
    /**
     * 体験時間(分)
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'duration'?: number;
    /**
     * 募集終了日時
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'endAt': number;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'experienceTypeId': string;
    /**
     * 開催場所(住所1)
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'hostAddressLine1': string;
    /**
     * 開催場所(住所2)
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'hostAddressLine2'?: string;
    /**
     * 開催場所(市区町村)
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'hostCity': string;
    /**
     * 開催場所(郵便番号)
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'hostPostalCode': string;
    /**
     * 開催場所(都道府県コード)
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'hostPrefectureCode': number;
    /**
     * メディア一覧
     * @type {Array<TypesCreateExperienceMedia>}
     * @memberof TypesCreateExperienceRequest
     */
    'media': Array<TypesCreateExperienceMedia>;
    /**
     * 大人料金
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'priceAdult': number;
    /**
     * 小学生料金
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'priceElementarySchool': number;
    /**
     * 中学生料金
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'priceJuniorHighSchool': number;
    /**
     * 幼児料金
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'pricePreschool': number;
    /**
     * シニア料金
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'priceSenior': number;
    /**
     * 生産者ID
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'producerId': string;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'promotionVideoUrl'?: string;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof TypesCreateExperienceRequest
     */
    'public'?: boolean;
    /**
     * おすすめポイント1
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'recommendedPoint1'?: string;
    /**
     * おすすめポイント2
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'recommendedPoint2'?: string;
    /**
     * おすすめポイント3
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'recommendedPoint3'?: string;
    /**
     * 定員オーバーフラグ
     * @type {boolean}
     * @memberof TypesCreateExperienceRequest
     */
    'soldOut'?: boolean;
    /**
     * 募集開始日時
     * @type {number}
     * @memberof TypesCreateExperienceRequest
     */
    'startAt': number;
    /**
     * 体験名
     * @type {string}
     * @memberof TypesCreateExperienceRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesCreateExperienceTypeRequest
 */
export interface TypesCreateExperienceTypeRequest {
    /**
     * 体験種別名
     * @type {string}
     * @memberof TypesCreateExperienceTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesCreateLiveRequest
 */
export interface TypesCreateLiveRequest {
    /**
     * コメント
     * @type {string}
     * @memberof TypesCreateLiveRequest
     */
    'comment': string;
    /**
     * 配信終了日時
     * @type {number}
     * @memberof TypesCreateLiveRequest
     */
    'endAt': number;
    /**
     * 生産者ID
     * @type {string}
     * @memberof TypesCreateLiveRequest
     */
    'producerId': string;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof TypesCreateLiveRequest
     */
    'productIds': Array<string>;
    /**
     * 配信開始日時
     * @type {number}
     * @memberof TypesCreateLiveRequest
     */
    'startAt': number;
}
/**
 * 
 * @export
 * @interface TypesCreateNotificationRequest
 */
export interface TypesCreateNotificationRequest {
    /**
     * 本文
     * @type {string}
     * @memberof TypesCreateNotificationRequest
     */
    'body': string;
    /**
     * 備考
     * @type {string}
     * @memberof TypesCreateNotificationRequest
     */
    'note'?: string;
    /**
     * プロモーションID
     * @type {string}
     * @memberof TypesCreateNotificationRequest
     */
    'promotionId'?: string;
    /**
     * 掲載開始日
     * @type {number}
     * @memberof TypesCreateNotificationRequest
     */
    'publishedAt': number;
    /**
     * 掲載対象一覧
     * @type {Array<number>}
     * @memberof TypesCreateNotificationRequest
     */
    'targets': Array<number>;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesCreateNotificationRequest
     */
    'title': string;
    /**
     * お知らせ種別
     * @type {number}
     * @memberof TypesCreateNotificationRequest
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface TypesCreateProducerRequest
 */
export interface TypesCreateProducerRequest {
    /**
     * 町名・番地
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'addressLine2'?: string;
    /**
     * 購入特典映像URL
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'bonusVideoUrl'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'city'?: string;
    /**
     * 担当コーディネータ名
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'coordinatorId': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'email'?: string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'facebookId'?: string;
    /**
     * 名
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'firstname': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'firstnameKana': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'headerUrl'?: string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'instagramId'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'lastname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'lastnameKana': string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {number}
     * @memberof TypesCreateProducerRequest
     */
    'prefectureCode'?: number;
    /**
     * 紹介文
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'profile'?: string;
    /**
     * 紹介映像URL
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'promotionVideoUrl'?: string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'thumbnailUrl'?: string;
    /**
     * 表示名
     * @type {string}
     * @memberof TypesCreateProducerRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface TypesCreateProductMedia
 */
export interface TypesCreateProductMedia {
    /**
     * サムネイルとして使用
     * @type {boolean}
     * @memberof TypesCreateProductMedia
     */
    'isThumbnail'?: boolean;
    /**
     * メディアURL
     * @type {string}
     * @memberof TypesCreateProductMedia
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface TypesCreateProductRequest
 */
export interface TypesCreateProductRequest {
    /**
     * 箱の占有率(サイズ:60)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'box60Rate'?: number;
    /**
     * 箱の占有率(サイズ:80)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'box80Rate'?: number;
    /**
     * 箱の占有率(サイズ:100)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'box100Rate'?: number;
    /**
     * コーディネータID
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'coordinatorId': string;
    /**
     * 原価(税込)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'cost'?: number;
    /**
     * 配送方法
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'deliveryType': number;
    /**
     * 商品説明
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'description': string;
    /**
     * 販売終了日時
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'endAt': number;
    /**
     * 賞味期限(単位:日)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'expirationDate'?: number;
    /**
     * 在庫数
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'inventory'?: number;
    /**
     * 数量単位説明
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'itemDescription': string;
    /**
     * 数量単位
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'itemUnit': string;
    /**
     * メディア一覧
     * @type {Array<TypesCreateProductMedia>}
     * @memberof TypesCreateProductRequest
     */
    'media'?: Array<TypesCreateProductMedia>;
    /**
     * 商品名
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'name': string;
    /**
     * 原産地(市区町村)
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'originCity'?: string;
    /**
     * 原産地(都道府県)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'originPrefectureCode': number;
    /**
     * 販売価格(税込)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'price'?: number;
    /**
     * 生産者ID
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'producerId': string;
    /**
     * 商品タグID一覧
     * @type {Array<string>}
     * @memberof TypesCreateProductRequest
     */
    'productTagIds': Array<string>;
    /**
     * 品目ID
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'productTypeId': string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof TypesCreateProductRequest
     */
    'public'?: boolean;
    /**
     * おすすめポイント1
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'recommendedPoint1'?: string;
    /**
     * おすすめポイント2
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'recommendedPoint2'?: string;
    /**
     * おすすめポイント3
     * @type {string}
     * @memberof TypesCreateProductRequest
     */
    'recommendedPoint3'?: string;
    /**
     * 販売開始日時
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'startAt': number;
    /**
     * 保存方法
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'storageMethodType': number;
    /**
     * 重量(kg,少数第一位まで)
     * @type {number}
     * @memberof TypesCreateProductRequest
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface TypesCreateProductTagRequest
 */
export interface TypesCreateProductTagRequest {
    /**
     * 商品タグ名
     * @type {string}
     * @memberof TypesCreateProductTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesCreateProductTypeRequest
 */
export interface TypesCreateProductTypeRequest {
    /**
     * アイコンURL
     * @type {string}
     * @memberof TypesCreateProductTypeRequest
     */
    'iconUrl': string;
    /**
     * 品目名
     * @type {string}
     * @memberof TypesCreateProductTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesCreatePromotionRequest
 */
export interface TypesCreatePromotionRequest {
    /**
     * 
     * @type {string}
     * @memberof TypesCreatePromotionRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypesCreatePromotionRequest
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof TypesCreatePromotionRequest
     */
    'discountRate'?: number;
    /**
     * 割引計算方法
     * @type {number}
     * @memberof TypesCreatePromotionRequest
     */
    'discountType': number;
    /**
     * 
     * @type {number}
     * @memberof TypesCreatePromotionRequest
     */
    'endAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof TypesCreatePromotionRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TypesCreatePromotionRequest
     */
    'startAt': number;
    /**
     * 
     * @type {string}
     * @memberof TypesCreatePromotionRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesCreateScheduleRequest
 */
export interface TypesCreateScheduleRequest {
    /**
     * コーディネータID
     * @type {string}
     * @memberof TypesCreateScheduleRequest
     */
    'coordinatorId': string;
    /**
     * 説明
     * @type {string}
     * @memberof TypesCreateScheduleRequest
     */
    'description': string;
    /**
     * 配信終了日時
     * @type {number}
     * @memberof TypesCreateScheduleRequest
     */
    'endAt': number;
    /**
     * 蓋絵URL
     * @type {string}
     * @memberof TypesCreateScheduleRequest
     */
    'imageUrl'?: string;
    /**
     * オープニング動画URL
     * @type {string}
     * @memberof TypesCreateScheduleRequest
     */
    'openingVideoUrl'?: string;
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof TypesCreateScheduleRequest
     */
    'public'?: boolean;
    /**
     * 配信開始日時
     * @type {number}
     * @memberof TypesCreateScheduleRequest
     */
    'startAt': number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesCreateScheduleRequest
     */
    'thumbnailUrl'?: string;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesCreateScheduleRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesCreateShippingRate
 */
export interface TypesCreateShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof TypesCreateShippingRate
     */
    'name': string;
    /**
     * 対象都道府県一覧
     * @type {Array<number>}
     * @memberof TypesCreateShippingRate
     */
    'prefectureCodes': Array<number>;
    /**
     * 配送料金(税込)
     * @type {number}
     * @memberof TypesCreateShippingRate
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface TypesCreateShippingRequest
 */
export interface TypesCreateShippingRequest {
    /**
     * 箱サイズ60の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesCreateShippingRequest
     */
    'box60Frozen': number;
    /**
     * 箱サイズ60の通常便配送料一覧
     * @type {Array<TypesCreateShippingRate>}
     * @memberof TypesCreateShippingRequest
     */
    'box60Rates': Array<TypesCreateShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesCreateShippingRequest
     */
    'box80Frozen': number;
    /**
     * 箱サイズ80の通常便配送料一覧
     * @type {Array<TypesCreateShippingRate>}
     * @memberof TypesCreateShippingRequest
     */
    'box80Rates': Array<TypesCreateShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesCreateShippingRequest
     */
    'box100Frozen': number;
    /**
     * 箱サイズ100の通常便配送料一覧
     * @type {Array<TypesCreateShippingRate>}
     * @memberof TypesCreateShippingRequest
     */
    'box100Rates': Array<TypesCreateShippingRate>;
    /**
     * 送料無料になる金額(税込)
     * @type {number}
     * @memberof TypesCreateShippingRequest
     */
    'freeShippingRates'?: number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof TypesCreateShippingRequest
     */
    'hasFreeShipping'?: boolean;
    /**
     * 配送設定名
     * @type {string}
     * @memberof TypesCreateShippingRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesCreateSpotTypeRequest
 */
export interface TypesCreateSpotTypeRequest {
    /**
     * スポット種別名
     * @type {string}
     * @memberof TypesCreateSpotTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesCreateThreadRequest
 */
export interface TypesCreateThreadRequest {
    /**
     * お問い合わせID
     * @type {string}
     * @memberof TypesCreateThreadRequest
     */
    'contactId': string;
    /**
     * 内容
     * @type {string}
     * @memberof TypesCreateThreadRequest
     */
    'content': string;
    /**
     * 送信者ID
     * @type {string}
     * @memberof TypesCreateThreadRequest
     */
    'userId': string;
    /**
     * 送信者タイプ
     * @type {number}
     * @memberof TypesCreateThreadRequest
     */
    'userType'?: number;
}
/**
 * 
 * @export
 * @interface TypesCreateVideoRequest
 */
export interface TypesCreateVideoRequest {
    /**
     * コーディネータID
     * @type {string}
     * @memberof TypesCreateVideoRequest
     */
    'coordinatorId': string;
    /**
     * 説明
     * @type {string}
     * @memberof TypesCreateVideoRequest
     */
    'description': string;
    /**
     * 体験への表示設定
     * @type {boolean}
     * @memberof TypesCreateVideoRequest
     */
    'displayExperience'?: boolean;
    /**
     * 商品への表示設定
     * @type {boolean}
     * @memberof TypesCreateVideoRequest
     */
    'displayProduct'?: boolean;
    /**
     * 体験ID一覧
     * @type {Array<string>}
     * @memberof TypesCreateVideoRequest
     */
    'experienceIds': Array<string>;
    /**
     * 限定公開設定
     * @type {boolean}
     * @memberof TypesCreateVideoRequest
     */
    'limited'?: boolean;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof TypesCreateVideoRequest
     */
    'productIds': Array<string>;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof TypesCreateVideoRequest
     */
    'public'?: boolean;
    /**
     * 公開日時
     * @type {number}
     * @memberof TypesCreateVideoRequest
     */
    'publishedAt': number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesCreateVideoRequest
     */
    'thumbnailUrl': string;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesCreateVideoRequest
     */
    'title': string;
    /**
     * 動画URL
     * @type {string}
     * @memberof TypesCreateVideoRequest
     */
    'videoUrl': string;
}
/**
 * 
 * @export
 * @interface TypesCreateYoutubeBroadcastRequest
 */
export interface TypesCreateYoutubeBroadcastRequest {
    /**
     * ライブ配信説明
     * @type {string}
     * @memberof TypesCreateYoutubeBroadcastRequest
     */
    'description'?: string;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof TypesCreateYoutubeBroadcastRequest
     */
    'public'?: boolean;
    /**
     * ライブ配信タイトル
     * @type {string}
     * @memberof TypesCreateYoutubeBroadcastRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesDraftOrderRequest
 */
export interface TypesDraftOrderRequest {
    /**
     * 発送連絡時のメッセージ
     * @type {string}
     * @memberof TypesDraftOrderRequest
     */
    'shippingMessage'?: string;
}
/**
 * 
 * @export
 * @interface TypesExperienceTypeResponse
 */
export interface TypesExperienceTypeResponse {
    /**
     * 
     * @type {ExperienceType}
     * @memberof TypesExperienceTypeResponse
     */
    'experienceType'?: ExperienceType;
}
/**
 * 
 * @export
 * @interface TypesExperienceTypesResponse
 */
export interface TypesExperienceTypesResponse {
    /**
     * 体験種別一覧
     * @type {Array<ExperienceType>}
     * @memberof TypesExperienceTypesResponse
     */
    'experienceTypes'?: Array<ExperienceType>;
    /**
     * 体験種別合計数
     * @type {number}
     * @memberof TypesExperienceTypesResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesExportOrdersRequest
 */
export interface TypesExportOrdersRequest {
    /**
     * 文字コード種別
     * @type {number}
     * @memberof TypesExportOrdersRequest
     */
    'characterEncodingType'?: number;
    /**
     * 配送会社
     * @type {number}
     * @memberof TypesExportOrdersRequest
     */
    'shippingCarrier': number;
}
/**
 * ゲスト用ライブ配信情報
 * @export
 * @interface TypesGuestBroadcast
 */
export interface TypesGuestBroadcast {
    /**
     * ライブ配信担当者(マルシェ)
     * @type {string}
     * @memberof TypesGuestBroadcast
     */
    'coordinatorMarche'?: string;
    /**
     * ライブ配信担当者(名前)
     * @type {string}
     * @memberof TypesGuestBroadcast
     */
    'coordinatorName'?: string;
    /**
     * ライブ配信説明
     * @type {string}
     * @memberof TypesGuestBroadcast
     */
    'description'?: string;
    /**
     * ライブ配信終了日時
     * @type {number}
     * @memberof TypesGuestBroadcast
     */
    'endAt'?: number;
    /**
     * ライブ配信開始日時
     * @type {number}
     * @memberof TypesGuestBroadcast
     */
    'startAt'?: number;
    /**
     * ライブ配信タイトル
     * @type {string}
     * @memberof TypesGuestBroadcast
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface TypesGuestBroadcastResponse
 */
export interface TypesGuestBroadcastResponse {
    /**
     * 
     * @type {TypesGuestBroadcast}
     * @memberof TypesGuestBroadcastResponse
     */
    'broadcast'?: TypesGuestBroadcast;
}
/**
 * 
 * @export
 * @interface TypesLiveResponse
 */
export interface TypesLiveResponse {
    /**
     * 
     * @type {Live}
     * @memberof TypesLiveResponse
     */
    'live'?: Live;
    /**
     * 
     * @type {Producer}
     * @memberof TypesLiveResponse
     */
    'producer'?: Producer;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof TypesLiveResponse
     */
    'products'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface TypesLivesResponse
 */
export interface TypesLivesResponse {
    /**
     * ライブ配信一覧
     * @type {Array<Live>}
     * @memberof TypesLivesResponse
     */
    'lives'?: Array<Live>;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof TypesLivesResponse
     */
    'producers'?: Array<Producer>;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof TypesLivesResponse
     */
    'products'?: Array<Product>;
    /**
     * 合計数
     * @type {number}
     * @memberof TypesLivesResponse
     */
    'total'?: number;
}
/**
 * メッセージ情報
 * @export
 * @interface TypesMessage
 */
export interface TypesMessage {
    /**
     * メッセージ内容
     * @type {string}
     * @memberof TypesMessage
     */
    'body'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesMessage
     */
    'createdAt'?: number;
    /**
     * メッセージID
     * @type {string}
     * @memberof TypesMessage
     */
    'id'?: string;
    /**
     * 遷移先リンク
     * @type {string}
     * @memberof TypesMessage
     */
    'link'?: string;
    /**
     * 既読フラグ
     * @type {boolean}
     * @memberof TypesMessage
     */
    'read'?: boolean;
    /**
     * 受信日時
     * @type {number}
     * @memberof TypesMessage
     */
    'receivedAt'?: number;
    /**
     * メッセージ件名
     * @type {string}
     * @memberof TypesMessage
     */
    'title'?: string;
    /**
     * メッセージ種別
     * @type {number}
     * @memberof TypesMessage
     */
    'type'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesMessage
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface TypesMessageResponse
 */
export interface TypesMessageResponse {
    /**
     * 
     * @type {TypesMessage}
     * @memberof TypesMessageResponse
     */
    'message'?: TypesMessage;
}
/**
 * 
 * @export
 * @interface TypesMessagesResponse
 */
export interface TypesMessagesResponse {
    /**
     * メッセージ一覧
     * @type {Array<TypesMessage>}
     * @memberof TypesMessagesResponse
     */
    'messages'?: Array<TypesMessage>;
    /**
     * 合計数
     * @type {number}
     * @memberof TypesMessagesResponse
     */
    'total'?: number;
}
/**
 * お知らせ情報
 * @export
 * @interface TypesNotification
 */
export interface TypesNotification {
    /**
     * 本文
     * @type {string}
     * @memberof TypesNotification
     */
    'body'?: string;
    /**
     * 作成日時
     * @type {number}
     * @memberof TypesNotification
     */
    'createdAt'?: number;
    /**
     * 登録者ID
     * @type {string}
     * @memberof TypesNotification
     */
    'createdBy'?: string;
    /**
     * お知らせID
     * @type {string}
     * @memberof TypesNotification
     */
    'id'?: string;
    /**
     * 備考
     * @type {string}
     * @memberof TypesNotification
     */
    'note'?: string;
    /**
     * プロモーションID
     * @type {string}
     * @memberof TypesNotification
     */
    'promotionId'?: string;
    /**
     * 掲載開始日時
     * @type {number}
     * @memberof TypesNotification
     */
    'publishedAt'?: number;
    /**
     * お知らせ状態
     * @type {number}
     * @memberof TypesNotification
     */
    'status'?: number;
    /**
     * 掲載対象一覧
     * @type {Array<number>}
     * @memberof TypesNotification
     */
    'targets'?: Array<number>;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesNotification
     */
    'title'?: string;
    /**
     * お知らせ種別
     * @type {number}
     * @memberof TypesNotification
     */
    'type'?: number;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesNotification
     */
    'updatedAt'?: number;
    /**
     * 更新者ID
     * @type {string}
     * @memberof TypesNotification
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface TypesNotificationResponse
 */
export interface TypesNotificationResponse {
    /**
     * 
     * @type {TypesAdmin}
     * @memberof TypesNotificationResponse
     */
    'admin'?: TypesAdmin;
    /**
     * 
     * @type {TypesNotification}
     * @memberof TypesNotificationResponse
     */
    'notification'?: TypesNotification;
}
/**
 * 
 * @export
 * @interface TypesNotificationsResponse
 */
export interface TypesNotificationsResponse {
    /**
     * 登録者情報一覧
     * @type {Array<TypesAdmin>}
     * @memberof TypesNotificationsResponse
     */
    'admins'?: Array<TypesAdmin>;
    /**
     * お知らせ一覧
     * @type {Array<TypesNotification>}
     * @memberof TypesNotificationsResponse
     */
    'notifications'?: Array<TypesNotification>;
    /**
     * お知らせ合計数
     * @type {number}
     * @memberof TypesNotificationsResponse
     */
    'total'?: number;
}
/**
 * 備考
 * @export
 * @interface TypesOrderExperienceRemarks
 */
export interface TypesOrderExperienceRemarks {
    /**
     * 体験希望日
     * @type {string}
     * @memberof TypesOrderExperienceRemarks
     */
    'requestedDate'?: string;
    /**
     * 体験希望時間
     * @type {string}
     * @memberof TypesOrderExperienceRemarks
     */
    'requestedTime'?: string;
    /**
     * 交通手段
     * @type {string}
     * @memberof TypesOrderExperienceRemarks
     */
    'transportation'?: string;
}
/**
 * 注文付加情報
 * @export
 * @interface TypesOrderMetadata
 */
export interface TypesOrderMetadata {
    /**
     * 受け取り日時
     * @type {number}
     * @memberof TypesOrderMetadata
     */
    'pickupAt'?: number;
    /**
     * 受け取り場所
     * @type {string}
     * @memberof TypesOrderMetadata
     */
    'pickupLocation'?: string;
}
/**
 * 
 * @export
 * @interface TypesProductTagResponse
 */
export interface TypesProductTagResponse {
    /**
     * 
     * @type {ProductTag}
     * @memberof TypesProductTagResponse
     */
    'productTag'?: ProductTag;
}
/**
 * 
 * @export
 * @interface TypesProductTagsResponse
 */
export interface TypesProductTagsResponse {
    /**
     * 商品タグ一覧
     * @type {Array<ProductTag>}
     * @memberof TypesProductTagsResponse
     */
    'productTags'?: Array<ProductTag>;
    /**
     * 商品タグ合計数
     * @type {number}
     * @memberof TypesProductTagsResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesProductTypeResponse
 */
export interface TypesProductTypeResponse {
    /**
     * 
     * @type {Category}
     * @memberof TypesProductTypeResponse
     */
    'category'?: Category;
    /**
     * 
     * @type {ProductType}
     * @memberof TypesProductTypeResponse
     */
    'productType'?: ProductType;
}
/**
 * 
 * @export
 * @interface TypesProductTypesResponse
 */
export interface TypesProductTypesResponse {
    /**
     * 商品種別一覧
     * @type {Array<Category>}
     * @memberof TypesProductTypesResponse
     */
    'categories'?: Array<Category>;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof TypesProductTypesResponse
     */
    'productTypes'?: Array<ProductType>;
    /**
     * 品目合計数
     * @type {number}
     * @memberof TypesProductTypesResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesPromotionsResponse
 */
export interface TypesPromotionsResponse {
    /**
     * プロモーション情報一覧
     * @type {Array<Promotion>}
     * @memberof TypesPromotionsResponse
     */
    'promotions'?: Array<Promotion>;
    /**
     * 店舗情報一覧
     * @type {Array<TypesShop>}
     * @memberof TypesPromotionsResponse
     */
    'shops'?: Array<TypesShop>;
    /**
     * プロモーション合計数
     * @type {number}
     * @memberof TypesPromotionsResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesPublishScheduleRequest
 */
export interface TypesPublishScheduleRequest {
    /**
     * 公開フラグ
     * @type {boolean}
     * @memberof TypesPublishScheduleRequest
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface TypesRefundOrderRequest
 */
export interface TypesRefundOrderRequest {
    /**
     * 返金理由
     * @type {string}
     * @memberof TypesRefundOrderRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TypesRegisterAuthDeviceRequest
 */
export interface TypesRegisterAuthDeviceRequest {
    /**
     * デバイスID
     * @type {string}
     * @memberof TypesRegisterAuthDeviceRequest
     */
    'device': string;
}
/**
 * 
 * @export
 * @interface TypesSchedulesResponse
 */
export interface TypesSchedulesResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof TypesSchedulesResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * マルシェ開催一覧
     * @type {Array<Schedule>}
     * @memberof TypesSchedulesResponse
     */
    'schedules'?: Array<Schedule>;
    /**
     * 合計数
     * @type {number}
     * @memberof TypesSchedulesResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesShippingResponse
 */
export interface TypesShippingResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof TypesShippingResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 
     * @type {Shipping}
     * @memberof TypesShippingResponse
     */
    'shipping'?: Shipping;
}
/**
 * 
 * @export
 * @interface TypesShippingsResponse
 */
export interface TypesShippingsResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof TypesShippingsResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 配送設定一覧
     * @type {Array<Shipping>}
     * @memberof TypesShippingsResponse
     */
    'shippings'?: Array<Shipping>;
    /**
     * 合計数
     * @type {number}
     * @memberof TypesShippingsResponse
     */
    'total'?: number;
}
/**
 * 店舗情報
 * @export
 * @interface TypesShop
 */
export interface TypesShop {
    /**
     * 営業曜日(発送可能日)
     * @type {Array<number>}
     * @memberof TypesShop
     */
    'businessDays'?: Array<number>;
    /**
     * コーディネータID
     * @type {string}
     * @memberof TypesShop
     */
    'coordinatorId'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesShop
     */
    'createdAt'?: number;
    /**
     * 店舗ID
     * @type {string}
     * @memberof TypesShop
     */
    'id'?: string;
    /**
     * 店舗名
     * @type {string}
     * @memberof TypesShop
     */
    'name'?: string;
    /**
     * 生産者ID一覧
     * @type {Array<string>}
     * @memberof TypesShop
     */
    'producerIds'?: Array<string>;
    /**
     * 取り扱い品目一覧
     * @type {Array<string>}
     * @memberof TypesShop
     */
    'productTypeIds'?: Array<string>;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesShop
     */
    'updatedAt'?: number;
}
/**
 * 
 * @export
 * @interface TypesShopResponse
 */
export interface TypesShopResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof TypesShopResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 生産者一覧
     * @type {Array<Producer>}
     * @memberof TypesShopResponse
     */
    'producers'?: Array<Producer>;
    /**
     * 品目一覧
     * @type {Array<ProductType>}
     * @memberof TypesShopResponse
     */
    'productTypes'?: Array<ProductType>;
    /**
     * 
     * @type {TypesShop}
     * @memberof TypesShopResponse
     */
    'shop'?: TypesShop;
}
/**
 * 
 * @export
 * @interface TypesSpotTypeResponse
 */
export interface TypesSpotTypeResponse {
    /**
     * 
     * @type {SpotType}
     * @memberof TypesSpotTypeResponse
     */
    'spotType'?: SpotType;
}
/**
 * お問い合わせ会話履歴
 * @export
 * @interface TypesThread
 */
export interface TypesThread {
    /**
     * お問い合わせID
     * @type {string}
     * @memberof TypesThread
     */
    'contactId'?: string;
    /**
     * 会話内容
     * @type {string}
     * @memberof TypesThread
     */
    'content'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesThread
     */
    'createdAt'?: number;
    /**
     * お問い合わせ会話履歴ID
     * @type {string}
     * @memberof TypesThread
     */
    'id'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesThread
     */
    'updatedAt'?: number;
    /**
     * 送信者ID
     * @type {string}
     * @memberof TypesThread
     */
    'userId'?: string;
    /**
     * 送信者タイプ
     * @type {number}
     * @memberof TypesThread
     */
    'userType'?: number;
}
/**
 * 
 * @export
 * @interface TypesThreadResponse
 */
export interface TypesThreadResponse {
    /**
     * 
     * @type {TypesAdmin}
     * @memberof TypesThreadResponse
     */
    'admin'?: TypesAdmin;
    /**
     * 
     * @type {TypesThread}
     * @memberof TypesThreadResponse
     */
    'thread'?: TypesThread;
    /**
     * 
     * @type {TypesUser}
     * @memberof TypesThreadResponse
     */
    'user'?: TypesUser;
}
/**
 * 
 * @export
 * @interface TypesThreadsResponse
 */
export interface TypesThreadsResponse {
    /**
     * 送信者一覧
     * @type {Array<TypesAdmin>}
     * @memberof TypesThreadsResponse
     */
    'admins'?: Array<TypesAdmin>;
    /**
     * お問い合わせ会話履歴一覧
     * @type {Array<TypesThread>}
     * @memberof TypesThreadsResponse
     */
    'threads'?: Array<TypesThread>;
    /**
     * 会話履歴合計
     * @type {number}
     * @memberof TypesThreadsResponse
     */
    'total'?: number;
    /**
     * 送信者一覧
     * @type {Array<TypesUser>}
     * @memberof TypesThreadsResponse
     */
    'users'?: Array<TypesUser>;
}
/**
 * 
 * @export
 * @interface TypesTopOrderPayment
 */
export interface TypesTopOrderPayment {
    /**
     * 注文数
     * @type {number}
     * @memberof TypesTopOrderPayment
     */
    'orderCount'?: number;
    /**
     * 決済手段種別
     * @type {number}
     * @memberof TypesTopOrderPayment
     */
    'paymentMethodType'?: number;
    /**
     * 割合（支払い方法別注文数 / 注文数）
     * @type {number}
     * @memberof TypesTopOrderPayment
     */
    'rate'?: number;
    /**
     * 売上合計
     * @type {number}
     * @memberof TypesTopOrderPayment
     */
    'salesTotal'?: number;
    /**
     * ユーザー数
     * @type {number}
     * @memberof TypesTopOrderPayment
     */
    'userCount'?: number;
}
/**
 * 
 * @export
 * @interface TypesTopOrderSalesTrend
 */
export interface TypesTopOrderSalesTrend {
    /**
     * 期間
     * @type {string}
     * @memberof TypesTopOrderSalesTrend
     */
    'period'?: string;
    /**
     * 売上合計
     * @type {number}
     * @memberof TypesTopOrderSalesTrend
     */
    'salesTotal'?: number;
}
/**
 * 注文数
 * @export
 * @interface TypesTopOrderValue
 */
export interface TypesTopOrderValue {
    /**
     * 比較値（％：前日比など）
     * @type {number}
     * @memberof TypesTopOrderValue
     */
    'comparison'?: number;
    /**
     * 値
     * @type {number}
     * @memberof TypesTopOrderValue
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface TypesTopOrdersResponse
 */
export interface TypesTopOrdersResponse {
    /**
     * 終了日時
     * @type {number}
     * @memberof TypesTopOrdersResponse
     */
    'endAt'?: number;
    /**
     * 
     * @type {TypesTopOrderValue}
     * @memberof TypesTopOrdersResponse
     */
    'orders'?: TypesTopOrderValue;
    /**
     * 支払い方法別情報
     * @type {Array<TypesTopOrderPayment>}
     * @memberof TypesTopOrdersResponse
     */
    'payments'?: Array<TypesTopOrderPayment>;
    /**
     * 期間種別
     * @type {string}
     * @memberof TypesTopOrdersResponse
     */
    'periodType'?: string;
    /**
     * 
     * @type {TypesTopOrderValue}
     * @memberof TypesTopOrdersResponse
     */
    'sales'?: TypesTopOrderValue;
    /**
     * 売上推移（グラフ描画用）
     * @type {Array<TypesTopOrderSalesTrend>}
     * @memberof TypesTopOrdersResponse
     */
    'salesTrends'?: Array<TypesTopOrderSalesTrend>;
    /**
     * 開始日時
     * @type {number}
     * @memberof TypesTopOrdersResponse
     */
    'startAt'?: number;
    /**
     * 
     * @type {TypesTopOrderValue}
     * @memberof TypesTopOrdersResponse
     */
    'users'?: TypesTopOrderValue;
}
/**
 * 
 * @export
 * @interface TypesUpdateAdministratorEmailRequest
 */
export interface TypesUpdateAdministratorEmailRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesUpdateAdministratorEmailRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateAdministratorRequest
 */
export interface TypesUpdateAdministratorRequest {
    /**
     * 名
     * @type {string}
     * @memberof TypesUpdateAdministratorRequest
     */
    'firstname': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesUpdateAdministratorRequest
     */
    'firstnameKana': string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesUpdateAdministratorRequest
     */
    'lastname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesUpdateAdministratorRequest
     */
    'lastnameKana': string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesUpdateAdministratorRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateAuthEmailRequest
 */
export interface TypesUpdateAuthEmailRequest {
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesUpdateAuthEmailRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateBroadcastArchiveRequest
 */
export interface TypesUpdateBroadcastArchiveRequest {
    /**
     * アーカイブ動画URL
     * @type {string}
     * @memberof TypesUpdateBroadcastArchiveRequest
     */
    'archiveUrl': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateCategoryRequest
 */
export interface TypesUpdateCategoryRequest {
    /**
     * 商品種別名
     * @type {string}
     * @memberof TypesUpdateCategoryRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateContactRequest
 */
export interface TypesUpdateContactRequest {
    /**
     * お問い合わせ種別ID
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'categoryId': string;
    /**
     * お問い合わせ内容
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'content': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'email': string;
    /**
     * 対応者メモ
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'note'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'phoneNumber': string;
    /**
     * 対応者ID(null許容)
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'responderId'?: string;
    /**
     * お問い合わせステータス
     * @type {number}
     * @memberof TypesUpdateContactRequest
     */
    'status'?: number;
    /**
     * お問い合わせ件名
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'title': string;
    /**
     * 問い合わせ作成者ID(null許容)
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'userId'?: string;
    /**
     * 氏名
     * @type {string}
     * @memberof TypesUpdateContactRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateCoordinatorRequest
 */
export interface TypesUpdateCoordinatorRequest {
    /**
     * 町名・番地
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'addressLine1': string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'addressLine2'?: string;
    /**
     * 購入特典映像URL
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'bonusVideoUrl'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'city': string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'facebookId'?: string;
    /**
     * 名
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'firstname': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'firstnameKana': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'headerUrl'?: string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'instagramId'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'lastname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'lastnameKana': string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'phoneNumber': string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {number}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'prefectureCode': number;
    /**
     * 紹介文
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'profile': string;
    /**
     * 紹介映像URL
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'promotionVideoUrl'?: string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'thumbnailUrl'?: string;
    /**
     * 表示名
     * @type {string}
     * @memberof TypesUpdateCoordinatorRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateDefaultShippingRate
 */
export interface TypesUpdateDefaultShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof TypesUpdateDefaultShippingRate
     */
    'name': string;
    /**
     * 対象都道府県一覧
     * @type {Array<number>}
     * @memberof TypesUpdateDefaultShippingRate
     */
    'prefectureCodes': Array<number>;
    /**
     * 配送料金(税込)
     * @type {number}
     * @memberof TypesUpdateDefaultShippingRate
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface TypesUpdateDefaultShippingRequest
 */
export interface TypesUpdateDefaultShippingRequest {
    /**
     * 箱サイズ60の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'box60Frozen': number;
    /**
     * 箱サイズ60の通常便配送料一覧
     * @type {Array<TypesUpdateDefaultShippingRate>}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'box60Rates': Array<TypesUpdateDefaultShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'box80Frozen': number;
    /**
     * 箱サイズ80の通常便配送料一覧
     * @type {Array<TypesUpdateDefaultShippingRate>}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'box80Rates': Array<TypesUpdateDefaultShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'box100Frozen': number;
    /**
     * 箱サイズ100の通常便配送料一覧
     * @type {Array<TypesUpdateDefaultShippingRate>}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'box100Rates': Array<TypesUpdateDefaultShippingRate>;
    /**
     * 送料無料になる金額(税込)
     * @type {number}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'freeShippingRates'?: number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof TypesUpdateDefaultShippingRequest
     */
    'hasFreeShipping'?: boolean;
}
/**
 * 
 * @export
 * @interface TypesUpdateExperienceMedia
 */
export interface TypesUpdateExperienceMedia {
    /**
     * サムネイルとして使用
     * @type {boolean}
     * @memberof TypesUpdateExperienceMedia
     */
    'isThumbnail'?: boolean;
    /**
     * メディアURL
     * @type {string}
     * @memberof TypesUpdateExperienceMedia
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateExperienceRequest
 */
export interface TypesUpdateExperienceRequest {
    /**
     * 営業終了時間
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'businessCloseTime'?: string;
    /**
     * 営業開始時間
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'businessOpenTime'?: string;
    /**
     * 説明
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'description': string;
    /**
     * アクセス方法
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'direction'?: string;
    /**
     * 体験時間(分)
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'duration'?: number;
    /**
     * 募集終了日時
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'endAt': number;
    /**
     * 体験種別ID
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'experienceTypeId': string;
    /**
     * 開催場所(住所1)
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'hostAddressLine1': string;
    /**
     * 開催場所(住所2)
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'hostAddressLine2'?: string;
    /**
     * 開催場所(市区町村)
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'hostCity': string;
    /**
     * 開催場所(郵便番号)
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'hostPostalCode': string;
    /**
     * 開催場所(都道府県コード)
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'hostPrefectureCode': number;
    /**
     * メディア一覧
     * @type {Array<TypesUpdateExperienceMedia>}
     * @memberof TypesUpdateExperienceRequest
     */
    'media': Array<TypesUpdateExperienceMedia>;
    /**
     * 大人料金
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'priceAdult': number;
    /**
     * 小学生料金
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'priceElementarySchool': number;
    /**
     * 中学生料金
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'priceJuniorHighSchool': number;
    /**
     * 幼児料金
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'pricePreschool': number;
    /**
     * シニア料金
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'priceSenior': number;
    /**
     * 紹介動画URL
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'promotionVideoUrl'?: string;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof TypesUpdateExperienceRequest
     */
    'public'?: boolean;
    /**
     * おすすめポイント1
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'recommendedPoint1'?: string;
    /**
     * おすすめポイント2
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'recommendedPoint2'?: string;
    /**
     * おすすめポイント3
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'recommendedPoint3'?: string;
    /**
     * 定員オーバーフラグ
     * @type {boolean}
     * @memberof TypesUpdateExperienceRequest
     */
    'soldOut'?: boolean;
    /**
     * 募集開始日時
     * @type {number}
     * @memberof TypesUpdateExperienceRequest
     */
    'startAt': number;
    /**
     * 体験名
     * @type {string}
     * @memberof TypesUpdateExperienceRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateExperienceTypeRequest
 */
export interface TypesUpdateExperienceTypeRequest {
    /**
     * 体験種別名
     * @type {string}
     * @memberof TypesUpdateExperienceTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateLiveCommentRequest
 */
export interface TypesUpdateLiveCommentRequest {
    /**
     * コメント無効フラグ
     * @type {boolean}
     * @memberof TypesUpdateLiveCommentRequest
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface TypesUpdateLiveRequest
 */
export interface TypesUpdateLiveRequest {
    /**
     * コメント
     * @type {string}
     * @memberof TypesUpdateLiveRequest
     */
    'comment': string;
    /**
     * 配信終了日時
     * @type {number}
     * @memberof TypesUpdateLiveRequest
     */
    'endAt': number;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof TypesUpdateLiveRequest
     */
    'productIds': Array<string>;
    /**
     * 配信開始日時
     * @type {number}
     * @memberof TypesUpdateLiveRequest
     */
    'startAt': number;
}
/**
 * 
 * @export
 * @interface TypesUpdateNotificationRequest
 */
export interface TypesUpdateNotificationRequest {
    /**
     * 本文
     * @type {string}
     * @memberof TypesUpdateNotificationRequest
     */
    'body': string;
    /**
     * 備考
     * @type {string}
     * @memberof TypesUpdateNotificationRequest
     */
    'note'?: string;
    /**
     * 掲載開始日
     * @type {number}
     * @memberof TypesUpdateNotificationRequest
     */
    'publishedAt': number;
    /**
     * 掲載対象一覧
     * @type {Array<number>}
     * @memberof TypesUpdateNotificationRequest
     */
    'targets': Array<number>;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesUpdateNotificationRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesUpdatePaymentSystemRequest
 */
export interface TypesUpdatePaymentSystemRequest {
    /**
     * 決済システム状態
     * @type {number}
     * @memberof TypesUpdatePaymentSystemRequest
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface TypesUpdateProducerRequest
 */
export interface TypesUpdateProducerRequest {
    /**
     * 町名・番地
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'addressLine1'?: string;
    /**
     * ビル名・号室など
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'addressLine2'?: string;
    /**
     * 購入特典映像URL
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'bonusVideoUrl'?: string;
    /**
     * 市区町村
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'city'?: string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'email'?: string;
    /**
     * Facebookアカウント
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'facebookId'?: string;
    /**
     * 名
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'firstname': string;
    /**
     * 名(かな)
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'firstnameKana': string;
    /**
     * ヘッダー画像URL
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'headerUrl'?: string;
    /**
     * Instagramアカウント
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'instagramId'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'lastname': string;
    /**
     * 姓(かな)
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'lastnameKana': string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'phoneNumber'?: string;
    /**
     * 郵便番号
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'postalCode'?: string;
    /**
     * 都道府県
     * @type {number}
     * @memberof TypesUpdateProducerRequest
     */
    'prefectureCode'?: number;
    /**
     * 紹介文
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'profile'?: string;
    /**
     * 紹介映像URL
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'promotionVideoUrl'?: string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'thumbnailUrl'?: string;
    /**
     * 表示名
     * @type {string}
     * @memberof TypesUpdateProducerRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateProductTagRequest
 */
export interface TypesUpdateProductTagRequest {
    /**
     * 商品タグ名
     * @type {string}
     * @memberof TypesUpdateProductTagRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateProductTypeRequest
 */
export interface TypesUpdateProductTypeRequest {
    /**
     * アイコンURL
     * @type {string}
     * @memberof TypesUpdateProductTypeRequest
     */
    'iconUrl': string;
    /**
     * 品目名
     * @type {string}
     * @memberof TypesUpdateProductTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesUpdatePromotionRequest
 */
export interface TypesUpdatePromotionRequest {
    /**
     * 
     * @type {string}
     * @memberof TypesUpdatePromotionRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypesUpdatePromotionRequest
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof TypesUpdatePromotionRequest
     */
    'discountRate'?: number;
    /**
     * 割引計算方法
     * @type {number}
     * @memberof TypesUpdatePromotionRequest
     */
    'discountType': number;
    /**
     * 
     * @type {number}
     * @memberof TypesUpdatePromotionRequest
     */
    'endAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof TypesUpdatePromotionRequest
     */
    'public'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TypesUpdatePromotionRequest
     */
    'startAt': number;
    /**
     * 
     * @type {string}
     * @memberof TypesUpdatePromotionRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateScheduleRequest
 */
export interface TypesUpdateScheduleRequest {
    /**
     * 説明
     * @type {string}
     * @memberof TypesUpdateScheduleRequest
     */
    'description': string;
    /**
     * 配信終了日時
     * @type {number}
     * @memberof TypesUpdateScheduleRequest
     */
    'endAt': number;
    /**
     * 蓋絵URL
     * @type {string}
     * @memberof TypesUpdateScheduleRequest
     */
    'imageUrl'?: string;
    /**
     * オープニング動画URL
     * @type {string}
     * @memberof TypesUpdateScheduleRequest
     */
    'openingVideoUrl'?: string;
    /**
     * 配信開始日時
     * @type {number}
     * @memberof TypesUpdateScheduleRequest
     */
    'startAt': number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesUpdateScheduleRequest
     */
    'thumbnailUrl'?: string;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesUpdateScheduleRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateShippingRate
 */
export interface TypesUpdateShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof TypesUpdateShippingRate
     */
    'name': string;
    /**
     * 対象都道府県一覧
     * @type {Array<number>}
     * @memberof TypesUpdateShippingRate
     */
    'prefectureCodes': Array<number>;
    /**
     * 配送料金(税込)
     * @type {number}
     * @memberof TypesUpdateShippingRate
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface TypesUpdateShippingRequest
 */
export interface TypesUpdateShippingRequest {
    /**
     * 箱サイズ60の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpdateShippingRequest
     */
    'box60Frozen': number;
    /**
     * 箱サイズ60の通常便配送料一覧
     * @type {Array<TypesUpdateShippingRate>}
     * @memberof TypesUpdateShippingRequest
     */
    'box60Rates': Array<TypesUpdateShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpdateShippingRequest
     */
    'box80Frozen': number;
    /**
     * 箱サイズ80の通常便配送料一覧
     * @type {Array<TypesUpdateShippingRate>}
     * @memberof TypesUpdateShippingRequest
     */
    'box80Rates': Array<TypesUpdateShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpdateShippingRequest
     */
    'box100Frozen': number;
    /**
     * 箱サイズ100の通常便配送料一覧
     * @type {Array<TypesUpdateShippingRate>}
     * @memberof TypesUpdateShippingRequest
     */
    'box100Rates': Array<TypesUpdateShippingRate>;
    /**
     * 送料無料になる金額(税込)
     * @type {number}
     * @memberof TypesUpdateShippingRequest
     */
    'freeShippingRates'?: number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof TypesUpdateShippingRequest
     */
    'hasFreeShipping'?: boolean;
    /**
     * 配送設定名
     * @type {string}
     * @memberof TypesUpdateShippingRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateShopRequest
 */
export interface TypesUpdateShopRequest {
    /**
     * 営業曜日(発送可能日)
     * @type {Set<number>}
     * @memberof TypesUpdateShopRequest
     */
    'businessDays'?: Set<number>;
    /**
     * 店舗名
     * @type {string}
     * @memberof TypesUpdateShopRequest
     */
    'name': string;
    /**
     * 取り扱い品目一覧
     * @type {Array<string>}
     * @memberof TypesUpdateShopRequest
     */
    'productTypeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface TypesUpdateSpotTypeRequest
 */
export interface TypesUpdateSpotTypeRequest {
    /**
     * スポット種別名
     * @type {string}
     * @memberof TypesUpdateSpotTypeRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypesUpdateThreadRequest
 */
export interface TypesUpdateThreadRequest {
    /**
     * 内容
     * @type {string}
     * @memberof TypesUpdateThreadRequest
     */
    'content': string;
    /**
     * お問い合わせID
     * @type {string}
     * @memberof TypesUpdateThreadRequest
     */
    'threadId': string;
    /**
     * 送信者ID
     * @type {string}
     * @memberof TypesUpdateThreadRequest
     */
    'userId': string;
    /**
     * 送信者タイプ
     * @type {number}
     * @memberof TypesUpdateThreadRequest
     */
    'userType'?: number;
}
/**
 * 
 * @export
 * @interface TypesUpdateVideoCommentRequest
 */
export interface TypesUpdateVideoCommentRequest {
    /**
     * コメント無効フラグ
     * @type {boolean}
     * @memberof TypesUpdateVideoCommentRequest
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface TypesUpdateVideoRequest
 */
export interface TypesUpdateVideoRequest {
    /**
     * コーディネータID
     * @type {string}
     * @memberof TypesUpdateVideoRequest
     */
    'coordinatorId': string;
    /**
     * 説明
     * @type {string}
     * @memberof TypesUpdateVideoRequest
     */
    'description': string;
    /**
     * 体験への表示設定
     * @type {boolean}
     * @memberof TypesUpdateVideoRequest
     */
    'displayExperience'?: boolean;
    /**
     * 商品への表示設定
     * @type {boolean}
     * @memberof TypesUpdateVideoRequest
     */
    'displayProduct'?: boolean;
    /**
     * 体験ID一覧
     * @type {Array<string>}
     * @memberof TypesUpdateVideoRequest
     */
    'experienceIds': Array<string>;
    /**
     * 限定公開設定
     * @type {boolean}
     * @memberof TypesUpdateVideoRequest
     */
    'limited'?: boolean;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof TypesUpdateVideoRequest
     */
    'productIds': Array<string>;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof TypesUpdateVideoRequest
     */
    'public'?: boolean;
    /**
     * 公開日時
     * @type {number}
     * @memberof TypesUpdateVideoRequest
     */
    'publishedAt': number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesUpdateVideoRequest
     */
    'thumbnailUrl': string;
    /**
     * タイトル
     * @type {string}
     * @memberof TypesUpdateVideoRequest
     */
    'title': string;
    /**
     * 動画URL
     * @type {string}
     * @memberof TypesUpdateVideoRequest
     */
    'videoUrl': string;
}
/**
 * 
 * @export
 * @interface TypesUpsertShippingRate
 */
export interface TypesUpsertShippingRate {
    /**
     * 配送料金設定名
     * @type {string}
     * @memberof TypesUpsertShippingRate
     */
    'name': string;
    /**
     * 対象都道府県一覧
     * @type {Array<number>}
     * @memberof TypesUpsertShippingRate
     */
    'prefectureCodes': Array<number>;
    /**
     * 配送料金(税込)
     * @type {number}
     * @memberof TypesUpsertShippingRate
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface TypesUpsertShippingRequest
 */
export interface TypesUpsertShippingRequest {
    /**
     * 箱サイズ60の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpsertShippingRequest
     */
    'box60Frozen': number;
    /**
     * 箱サイズ60の通常便配送料一覧
     * @type {Array<TypesUpsertShippingRate>}
     * @memberof TypesUpsertShippingRequest
     */
    'box60Rates': Array<TypesUpsertShippingRate>;
    /**
     * 箱サイズ80の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpsertShippingRequest
     */
    'box80Frozen': number;
    /**
     * 箱サイズ80の通常便配送料一覧
     * @type {Array<TypesUpsertShippingRate>}
     * @memberof TypesUpsertShippingRequest
     */
    'box80Rates': Array<TypesUpsertShippingRate>;
    /**
     * 箱サイズ100の冷凍便追加配送料(税込)
     * @type {number}
     * @memberof TypesUpsertShippingRequest
     */
    'box100Frozen': number;
    /**
     * 箱サイズ100の通常便配送料一覧
     * @type {Array<TypesUpsertShippingRate>}
     * @memberof TypesUpsertShippingRequest
     */
    'box100Rates': Array<TypesUpsertShippingRate>;
    /**
     * 送料無料になる金額(税込)
     * @type {number}
     * @memberof TypesUpsertShippingRequest
     */
    'freeShippingRates'?: number;
    /**
     * 送料無料オプションの有無
     * @type {boolean}
     * @memberof TypesUpsertShippingRequest
     */
    'hasFreeShipping'?: boolean;
}
/**
 * ユーザー情報
 * @export
 * @interface TypesUser
 */
export interface TypesUser {
    /**
     * ユーザー名（検索用）
     * @type {string}
     * @memberof TypesUser
     */
    'accountId'?: string;
    /**
     * 登録日時
     * @type {number}
     * @memberof TypesUser
     */
    'createdAt'?: number;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesUser
     */
    'email'?: string;
    /**
     * 氏名（名）
     * @type {string}
     * @memberof TypesUser
     */
    'firstname'?: string;
    /**
     * 氏名(名:かな)
     * @type {string}
     * @memberof TypesUser
     */
    'firstnameKana'?: string;
    /**
     * 購入者ID
     * @type {string}
     * @memberof TypesUser
     */
    'id'?: string;
    /**
     * 氏名（姓）
     * @type {string}
     * @memberof TypesUser
     */
    'lastname'?: string;
    /**
     * 氏名(姓:かな)
     * @type {string}
     * @memberof TypesUser
     */
    'lastnameKana'?: string;
    /**
     * 電話番号
     * @type {string}
     * @memberof TypesUser
     */
    'phoneNumber'?: string;
    /**
     * 会員登録フラグ
     * @type {boolean}
     * @memberof TypesUser
     */
    'registered'?: boolean;
    /**
     * 購入者ステータス
     * @type {number}
     * @memberof TypesUser
     */
    'status'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof TypesUser
     */
    'thumbnailUrl'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof TypesUser
     */
    'updateAt'?: number;
    /**
     * ユーザー名（表示名）
     * @type {string}
     * @memberof TypesUser
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface TypesUserOrder
 */
export interface TypesUserOrder {
    /**
     * 注文情報ID
     * @type {string}
     * @memberof TypesUserOrder
     */
    'orderId'?: string;
    /**
     * 注文日時
     * @type {number}
     * @memberof TypesUserOrder
     */
    'orderedAt'?: number;
    /**
     * 支払日時
     * @type {number}
     * @memberof TypesUserOrder
     */
    'paidAt'?: number;
    /**
     * 支払い状況
     * @type {number}
     * @memberof TypesUserOrder
     */
    'status'?: number;
    /**
     * 商品合計金額
     * @type {number}
     * @memberof TypesUserOrder
     */
    'subtotal'?: number;
    /**
     * 支払い合計金額
     * @type {number}
     * @memberof TypesUserOrder
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TypesUserOrdersResponse
 */
export interface TypesUserOrdersResponse {
    /**
     * 注文合計回数
     * @type {number}
     * @memberof TypesUserOrdersResponse
     */
    'orderTotalCount'?: number;
    /**
     * 注文履歴一覧
     * @type {Array<TypesUserOrder>}
     * @memberof TypesUserOrdersResponse
     */
    'orders'?: Array<TypesUserOrder>;
    /**
     * 支払い合計金額
     * @type {number}
     * @memberof TypesUserOrdersResponse
     */
    'paymentTotalAmount'?: number;
    /**
     * 支払い合計回数
     * @type {number}
     * @memberof TypesUserOrdersResponse
     */
    'paymentTotalCount'?: number;
    /**
     * 購入商品合計金額
     * @type {number}
     * @memberof TypesUserOrdersResponse
     */
    'productTotalAmount'?: number;
}
/**
 * 
 * @export
 * @interface TypesUserResponse
 */
export interface TypesUserResponse {
    /**
     * 
     * @type {Address}
     * @memberof TypesUserResponse
     */
    'address'?: Address;
    /**
     * 
     * @type {TypesUser}
     * @memberof TypesUserResponse
     */
    'user'?: TypesUser;
}
/**
 * 
 * @export
 * @interface TypesUserToList
 */
export interface TypesUserToList {
    /**
     * 市区町村
     * @type {string}
     * @memberof TypesUserToList
     */
    'city'?: string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof TypesUserToList
     */
    'email'?: string;
    /**
     * 名
     * @type {string}
     * @memberof TypesUserToList
     */
    'firstname'?: string;
    /**
     * 購入者ID
     * @type {string}
     * @memberof TypesUserToList
     */
    'id'?: string;
    /**
     * 姓
     * @type {string}
     * @memberof TypesUserToList
     */
    'lastname'?: string;
    /**
     * 支払い回数
     * @type {number}
     * @memberof TypesUserToList
     */
    'paymentTotalCount'?: number;
    /**
     * 都道府県
     * @type {number}
     * @memberof TypesUserToList
     */
    'prefectureCode'?: number;
    /**
     * 会員登録フラグ
     * @type {boolean}
     * @memberof TypesUserToList
     */
    'registered'?: boolean;
    /**
     * 購入者ステータス
     * @type {number}
     * @memberof TypesUserToList
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface TypesUsersResponse
 */
export interface TypesUsersResponse {
    /**
     * 購入者合計数
     * @type {number}
     * @memberof TypesUsersResponse
     */
    'total'?: number;
    /**
     * 購入者一覧
     * @type {Array<TypesUserToList>}
     * @memberof TypesUsersResponse
     */
    'users'?: Array<TypesUserToList>;
}
/**
 * 
 * @export
 * @interface TypesVerifyAuthEmailRequest
 */
export interface TypesVerifyAuthEmailRequest {
    /**
     * 検証コード
     * @type {string}
     * @memberof TypesVerifyAuthEmailRequest
     */
    'verifyCode': string;
}
/**
 * 
 * @export
 * @interface TypesVideoViewerLog
 */
export interface TypesVideoViewerLog {
    /**
     * 集計終了日時
     * @type {number}
     * @memberof TypesVideoViewerLog
     */
    'endAt'?: number;
    /**
     * 集計開始日時
     * @type {number}
     * @memberof TypesVideoViewerLog
     */
    'startAt'?: number;
    /**
     * 合計視聴者数
     * @type {number}
     * @memberof TypesVideoViewerLog
     */
    'total'?: number;
    /**
     * オンデマンド動画ID
     * @type {string}
     * @memberof TypesVideoViewerLog
     */
    'videoId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAuthPasswordRequest
 */
export interface UpdateAuthPasswordRequest {
    /**
     * 新しいパスワード
     * @type {string}
     * @memberof UpdateAuthPasswordRequest
     */
    'newPassword'?: string;
    /**
     * 現在のパスワード
     * @type {string}
     * @memberof UpdateAuthPasswordRequest
     */
    'oldPassword': string;
    /**
     * パスワード (確認用)
     * @type {string}
     * @memberof UpdateAuthPasswordRequest
     */
    'passwordConfirmation': string;
}
/**
 * 
 * @export
 * @interface UpdateSpotRequest
 */
export interface UpdateSpotRequest {
    /**
     * 説明
     * @type {string}
     * @memberof UpdateSpotRequest
     */
    'description'?: string;
    /**
     * 緯度
     * @type {number}
     * @memberof UpdateSpotRequest
     */
    'latitude': number;
    /**
     * 経度
     * @type {number}
     * @memberof UpdateSpotRequest
     */
    'longitude': number;
    /**
     * スポット名
     * @type {string}
     * @memberof UpdateSpotRequest
     */
    'name': string;
    /**
     * スポット種別ID
     * @type {string}
     * @memberof UpdateSpotRequest
     */
    'spotTypeId': string;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof UpdateSpotRequest
     */
    'thumbnailUrl'?: string;
}
/**
 * 
 * @export
 * @interface UploadStateResponse
 */
export interface UploadStateResponse {
    /**
     * アップロード結果
     * @type {number}
     * @memberof UploadStateResponse
     */
    'status'?: number;
    /**
     * 参照先URL
     * @type {string}
     * @memberof UploadStateResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface UploadURLResponse
 */
export interface UploadURLResponse {
    /**
     * アップロード後の状態参照用キー
     * @type {string}
     * @memberof UploadURLResponse
     */
    'key'?: string;
    /**
     * アップロード用の署名付きURL
     * @type {string}
     * @memberof UploadURLResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface UtilErrorResponse
 */
export interface UtilErrorResponse {
    /**
     * エラー詳細
     * @type {string}
     * @memberof UtilErrorResponse
     */
    'detail'?: string;
    /**
     * エラー概要
     * @type {string}
     * @memberof UtilErrorResponse
     */
    'message'?: string;
    /**
     * ステータスコード
     * @type {number}
     * @memberof UtilErrorResponse
     */
    'status'?: number;
}
/**
 * オンデマンド動画情報
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * コーディネータID
     * @type {string}
     * @memberof Video
     */
    'coordinatorId'?: string;
    /**
     * 作成日時
     * @type {number}
     * @memberof Video
     */
    'createdAt'?: number;
    /**
     * 説明
     * @type {string}
     * @memberof Video
     */
    'description'?: string;
    /**
     * 体験への表示設定
     * @type {boolean}
     * @memberof Video
     */
    'displayExperience'?: boolean;
    /**
     * 商品への表示設定
     * @type {boolean}
     * @memberof Video
     */
    'displayProduct'?: boolean;
    /**
     * 体験ID一覧
     * @type {Array<string>}
     * @memberof Video
     */
    'experienceIds'?: Array<string>;
    /**
     * オンデマンド動画ID
     * @type {string}
     * @memberof Video
     */
    'id'?: string;
    /**
     * 限定公開設定
     * @type {boolean}
     * @memberof Video
     */
    'limited'?: boolean;
    /**
     * 商品ID一覧
     * @type {Array<string>}
     * @memberof Video
     */
    'productIds'?: Array<string>;
    /**
     * 公開設定
     * @type {boolean}
     * @memberof Video
     */
    'public'?: boolean;
    /**
     * 公開日時
     * @type {number}
     * @memberof Video
     */
    'publishedAt'?: number;
    /**
     * 配信状況
     * @type {number}
     * @memberof Video
     */
    'status'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof Video
     */
    'thumbnailUrl'?: string;
    /**
     * タイトル
     * @type {string}
     * @memberof Video
     */
    'title'?: string;
    /**
     * 更新日時
     * @type {number}
     * @memberof Video
     */
    'updatedAt'?: number;
    /**
     * 動画URL
     * @type {string}
     * @memberof Video
     */
    'videoUrl'?: string;
}
/**
 * 
 * @export
 * @interface VideoComment
 */
export interface VideoComment {
    /**
     * アカウントID
     * @type {string}
     * @memberof VideoComment
     */
    'accountId'?: string;
    /**
     * コメント
     * @type {string}
     * @memberof VideoComment
     */
    'comment'?: string;
    /**
     * コメント無効フラグ
     * @type {boolean}
     * @memberof VideoComment
     */
    'disabled'?: boolean;
    /**
     * コメントID
     * @type {string}
     * @memberof VideoComment
     */
    'id'?: string;
    /**
     * 投稿日時
     * @type {number}
     * @memberof VideoComment
     */
    'publishedAt'?: number;
    /**
     * サムネイルURL
     * @type {string}
     * @memberof VideoComment
     */
    'thumbnailUrl'?: string;
    /**
     * ユーザーID
     * @type {string}
     * @memberof VideoComment
     */
    'userId'?: string;
    /**
     * ユーザー名
     * @type {string}
     * @memberof VideoComment
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface VideoCommentsResponse
 */
export interface VideoCommentsResponse {
    /**
     * コメント一覧
     * @type {Array<VideoComment>}
     * @memberof VideoCommentsResponse
     */
    'comments'?: Array<VideoComment>;
    /**
     * 次の取得開始位置
     * @type {string}
     * @memberof VideoCommentsResponse
     */
    'nextToken'?: string;
}
/**
 * 
 * @export
 * @interface VideoResponse
 */
export interface VideoResponse {
    /**
     * 
     * @type {Coordinator}
     * @memberof VideoResponse
     */
    'coordinator'?: Coordinator;
    /**
     * 体験一覧
     * @type {Array<Experience>}
     * @memberof VideoResponse
     */
    'experiences'?: Array<Experience>;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof VideoResponse
     */
    'products'?: Array<Product>;
    /**
     * 
     * @type {Video}
     * @memberof VideoResponse
     */
    'video'?: Video;
}
/**
 * 
 * @export
 * @interface VideosResponse
 */
export interface VideosResponse {
    /**
     * コーディネータ一覧
     * @type {Array<Coordinator>}
     * @memberof VideosResponse
     */
    'coordinators'?: Array<Coordinator>;
    /**
     * 体験一覧
     * @type {Array<Experience>}
     * @memberof VideosResponse
     */
    'experiences'?: Array<Experience>;
    /**
     * 商品一覧
     * @type {Array<Product>}
     * @memberof VideosResponse
     */
    'products'?: Array<Product>;
    /**
     * オンデマンド動画合計数
     * @type {number}
     * @memberof VideosResponse
     */
    'total'?: number;
    /**
     * オンデマンド動画一覧
     * @type {Array<Video>}
     * @memberof VideosResponse
     */
    'videos'?: Array<Video>;
}

/**
 * AdministratorApi - axios parameter creator
 * @export
 */
export const AdministratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * システム管理者を削除します。
         * @summary システム管理者退会
         * @param {string} adminId システム管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdDelete: async (adminId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdDelete', 'adminId', adminId)
            const localVarPath = `/v1/administrators/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * システム管理者のメールアドレスを更新します。
         * @summary システム管理者メールアドレス更新
         * @param {string} adminId システム管理者ID
         * @param {TypesUpdateAdministratorEmailRequest} typesUpdateAdministratorEmailRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdEmailPatch: async (adminId: string, typesUpdateAdministratorEmailRequest: TypesUpdateAdministratorEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdEmailPatch', 'adminId', adminId)
            // verify required parameter 'typesUpdateAdministratorEmailRequest' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdEmailPatch', 'typesUpdateAdministratorEmailRequest', typesUpdateAdministratorEmailRequest)
            const localVarPath = `/v1/administrators/{adminId}/email`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateAdministratorEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * システム管理者の詳細情報を取得します。
         * @summary システム管理者取得
         * @param {string} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdGet: async (adminId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdGet', 'adminId', adminId)
            const localVarPath = `/v1/administrators/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * システム管理者のパスワードをランダムに生成して更新します。
         * @summary システム管理者パスワード更新(ランダム生成)
         * @param {string} adminId システム管理者ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdPasswordPatch: async (adminId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdPasswordPatch', 'adminId', adminId)
            const localVarPath = `/v1/administrators/{adminId}/password`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * システム管理者の情報を更新します。
         * @summary システム管理者更新
         * @param {string} adminId システム管理者ID
         * @param {TypesUpdateAdministratorRequest} typesUpdateAdministratorRequest システム管理者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdPatch: async (adminId: string, typesUpdateAdministratorRequest: TypesUpdateAdministratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminId' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdPatch', 'adminId', adminId)
            // verify required parameter 'typesUpdateAdministratorRequest' is not null or undefined
            assertParamExists('v1AdministratorsAdminIdPatch', 'typesUpdateAdministratorRequest', typesUpdateAdministratorRequest)
            const localVarPath = `/v1/administrators/{adminId}`
                .replace(`{${"adminId"}}`, encodeURIComponent(String(adminId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateAdministratorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * システム管理者の一覧を取得します。
         * @summary システム管理者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsGet: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/administrators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいシステム管理者を登録します。
         * @summary システム管理者登録
         * @param {TypesCreateAdministratorRequest} typesCreateAdministratorRequest システム管理者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsPost: async (typesCreateAdministratorRequest: TypesCreateAdministratorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateAdministratorRequest' is not null or undefined
            assertParamExists('v1AdministratorsPost', 'typesCreateAdministratorRequest', typesCreateAdministratorRequest)
            const localVarPath = `/v1/administrators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateAdministratorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdministratorApi - functional programming interface
 * @export
 */
export const AdministratorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdministratorApiAxiosParamCreator(configuration)
    return {
        /**
         * システム管理者を削除します。
         * @summary システム管理者退会
         * @param {string} adminId システム管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsAdminIdDelete(adminId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsAdminIdDelete(adminId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsAdminIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * システム管理者のメールアドレスを更新します。
         * @summary システム管理者メールアドレス更新
         * @param {string} adminId システム管理者ID
         * @param {TypesUpdateAdministratorEmailRequest} typesUpdateAdministratorEmailRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsAdminIdEmailPatch(adminId: string, typesUpdateAdministratorEmailRequest: TypesUpdateAdministratorEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsAdminIdEmailPatch(adminId, typesUpdateAdministratorEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsAdminIdEmailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * システム管理者の詳細情報を取得します。
         * @summary システム管理者取得
         * @param {string} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsAdminIdGet(adminId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAdministratorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsAdminIdGet(adminId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsAdminIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * システム管理者のパスワードをランダムに生成して更新します。
         * @summary システム管理者パスワード更新(ランダム生成)
         * @param {string} adminId システム管理者ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsAdminIdPasswordPatch(adminId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsAdminIdPasswordPatch(adminId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsAdminIdPasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * システム管理者の情報を更新します。
         * @summary システム管理者更新
         * @param {string} adminId システム管理者ID
         * @param {TypesUpdateAdministratorRequest} typesUpdateAdministratorRequest システム管理者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsAdminIdPatch(adminId: string, typesUpdateAdministratorRequest: TypesUpdateAdministratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsAdminIdPatch(adminId, typesUpdateAdministratorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsAdminIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * システム管理者の一覧を取得します。
         * @summary システム管理者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAdministratorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいシステム管理者を登録します。
         * @summary システム管理者登録
         * @param {TypesCreateAdministratorRequest} typesCreateAdministratorRequest システム管理者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AdministratorsPost(typesCreateAdministratorRequest: TypesCreateAdministratorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAdministratorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AdministratorsPost(typesCreateAdministratorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdministratorApi.v1AdministratorsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdministratorApi - factory interface
 * @export
 */
export const AdministratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdministratorApiFp(configuration)
    return {
        /**
         * システム管理者を削除します。
         * @summary システム管理者退会
         * @param {string} adminId システム管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdDelete(adminId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AdministratorsAdminIdDelete(adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * システム管理者のメールアドレスを更新します。
         * @summary システム管理者メールアドレス更新
         * @param {string} adminId システム管理者ID
         * @param {TypesUpdateAdministratorEmailRequest} typesUpdateAdministratorEmailRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdEmailPatch(adminId: string, typesUpdateAdministratorEmailRequest: TypesUpdateAdministratorEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AdministratorsAdminIdEmailPatch(adminId, typesUpdateAdministratorEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * システム管理者の詳細情報を取得します。
         * @summary システム管理者取得
         * @param {string} adminId 管理者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdGet(adminId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesAdministratorResponse> {
            return localVarFp.v1AdministratorsAdminIdGet(adminId, options).then((request) => request(axios, basePath));
        },
        /**
         * システム管理者のパスワードをランダムに生成して更新します。
         * @summary システム管理者パスワード更新(ランダム生成)
         * @param {string} adminId システム管理者ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdPasswordPatch(adminId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AdministratorsAdminIdPasswordPatch(adminId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * システム管理者の情報を更新します。
         * @summary システム管理者更新
         * @param {string} adminId システム管理者ID
         * @param {TypesUpdateAdministratorRequest} typesUpdateAdministratorRequest システム管理者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsAdminIdPatch(adminId: string, typesUpdateAdministratorRequest: TypesUpdateAdministratorRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AdministratorsAdminIdPatch(adminId, typesUpdateAdministratorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * システム管理者の一覧を取得します。
         * @summary システム管理者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesAdministratorsResponse> {
            return localVarFp.v1AdministratorsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいシステム管理者を登録します。
         * @summary システム管理者登録
         * @param {TypesCreateAdministratorRequest} typesCreateAdministratorRequest システム管理者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AdministratorsPost(typesCreateAdministratorRequest: TypesCreateAdministratorRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesAdministratorResponse> {
            return localVarFp.v1AdministratorsPost(typesCreateAdministratorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdministratorApi - object-oriented interface
 * @export
 * @class AdministratorApi
 * @extends {BaseAPI}
 */
export class AdministratorApi extends BaseAPI {
    /**
     * システム管理者を削除します。
     * @summary システム管理者退会
     * @param {string} adminId システム管理者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsAdminIdDelete(adminId: string, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsAdminIdDelete(adminId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * システム管理者のメールアドレスを更新します。
     * @summary システム管理者メールアドレス更新
     * @param {string} adminId システム管理者ID
     * @param {TypesUpdateAdministratorEmailRequest} typesUpdateAdministratorEmailRequest メールアドレス
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsAdminIdEmailPatch(adminId: string, typesUpdateAdministratorEmailRequest: TypesUpdateAdministratorEmailRequest, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsAdminIdEmailPatch(adminId, typesUpdateAdministratorEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * システム管理者の詳細情報を取得します。
     * @summary システム管理者取得
     * @param {string} adminId 管理者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsAdminIdGet(adminId: string, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsAdminIdGet(adminId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * システム管理者のパスワードをランダムに生成して更新します。
     * @summary システム管理者パスワード更新(ランダム生成)
     * @param {string} adminId システム管理者ID
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsAdminIdPasswordPatch(adminId: string, body?: object, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsAdminIdPasswordPatch(adminId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * システム管理者の情報を更新します。
     * @summary システム管理者更新
     * @param {string} adminId システム管理者ID
     * @param {TypesUpdateAdministratorRequest} typesUpdateAdministratorRequest システム管理者情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsAdminIdPatch(adminId: string, typesUpdateAdministratorRequest: TypesUpdateAdministratorRequest, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsAdminIdPatch(adminId, typesUpdateAdministratorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * システム管理者の一覧を取得します。
     * @summary システム管理者一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいシステム管理者を登録します。
     * @summary システム管理者登録
     * @param {TypesCreateAdministratorRequest} typesCreateAdministratorRequest システム管理者情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public v1AdministratorsPost(typesCreateAdministratorRequest: TypesCreateAdministratorRequest, options?: RawAxiosRequestConfig) {
        return AdministratorApiFp(this.configuration).v1AdministratorsPost(typesCreateAdministratorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ログイン中のコーディネータの詳細情報を取得します。
         * @summary 自身のコーディネータ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/coordinator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン中のコーディネータの情報を更新します。
         * @summary 自身のコーディネータ情報更新
         * @param {TypesUpdateCoordinatorRequest} typesUpdateCoordinatorRequest コーディネータ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorPatch: async (typesUpdateCoordinatorRequest: TypesUpdateCoordinatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesUpdateCoordinatorRequest' is not null or undefined
            assertParamExists('v1AuthCoordinatorPatch', 'typesUpdateCoordinatorRequest', typesUpdateCoordinatorRequest)
            const localVarPath = `/v1/auth/coordinator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateCoordinatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン中のコーディネータの配送設定を取得します。
         * @summary 自身の配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorShippingsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/coordinator/shippings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン中のコーディネータの配送設定を更新します。
         * @summary 自身の配送設定更新
         * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorShippingsPatch: async (typesUpsertShippingRequest: TypesUpsertShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesUpsertShippingRequest' is not null or undefined
            assertParamExists('v1AuthCoordinatorShippingsPatch', 'typesUpsertShippingRequest', typesUpsertShippingRequest)
            const localVarPath = `/v1/auth/coordinator/shippings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpsertShippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * サインアウトします。
         * @summary サインアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * プッシュ通知用のデバイストークンを登録します。
         * @summary デバイストークン登録
         * @param {TypesRegisterAuthDeviceRequest} typesRegisterAuthDeviceRequest デバイストークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthDevicePost: async (typesRegisterAuthDeviceRequest: TypesRegisterAuthDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesRegisterAuthDeviceRequest' is not null or undefined
            assertParamExists('v1AuthDevicePost', 'typesRegisterAuthDeviceRequest', typesRegisterAuthDeviceRequest)
            const localVarPath = `/v1/auth/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesRegisterAuthDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン中のユーザーのメールアドレスを更新します。
         * @summary メールアドレス更新
         * @param {TypesUpdateAuthEmailRequest} typesUpdateAuthEmailRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthEmailPatch: async (typesUpdateAuthEmailRequest: TypesUpdateAuthEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesUpdateAuthEmailRequest' is not null or undefined
            assertParamExists('v1AuthEmailPatch', 'typesUpdateAuthEmailRequest', typesUpdateAuthEmailRequest)
            const localVarPath = `/v1/auth/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateAuthEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * メールアドレス更新用の検証コードを確認します。
         * @summary メールアドレス更新 - コード検証
         * @param {TypesVerifyAuthEmailRequest} typesVerifyAuthEmailRequest 検証コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthEmailVerifiedPost: async (typesVerifyAuthEmailRequest: TypesVerifyAuthEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesVerifyAuthEmailRequest' is not null or undefined
            assertParamExists('v1AuthEmailVerifiedPost', 'typesVerifyAuthEmailRequest', typesVerifyAuthEmailRequest)
            const localVarPath = `/v1/auth/email/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesVerifyAuthEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワードリセット用のメールを送信します。
         * @summary パスワードリセット
         * @param {ForgotAuthPasswordRequest} forgotAuthPasswordRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthForgotPasswordPost: async (forgotAuthPasswordRequest: ForgotAuthPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotAuthPasswordRequest' is not null or undefined
            assertParamExists('v1AuthForgotPasswordPost', 'forgotAuthPasswordRequest', forgotAuthPasswordRequest)
            const localVarPath = `/v1/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotAuthPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パスワードリセット用の検証コードを確認し、新しいパスワードを設定します。
         * @summary パスワードリセット - コード検証
         * @param {ResetAuthPasswordRequest} resetAuthPasswordRequest パスワードリセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthForgotPasswordVerifiedPost: async (resetAuthPasswordRequest: ResetAuthPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetAuthPasswordRequest' is not null or undefined
            assertParamExists('v1AuthForgotPasswordVerifiedPost', 'resetAuthPasswordRequest', resetAuthPasswordRequest)
            const localVarPath = `/v1/auth/forgot-password/verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetAuthPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証トークンを検証し、認証情報を取得します。
         * @summary トークン検証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Googleアカウント連携用の認証URLを発行します。
         * @summary Google認証用URLの発行
         * @param {string} state CSRF対策用のstate
         * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthGoogleGet: async (state: string, redirectUri?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('v1AuthGoogleGet', 'state', state)
            const localVarPath = `/v1/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Googleアカウントを連携します。
         * @summary Googleアカウントの連携
         * @param {TypesConnectGoogleAccountRequest} typesConnectGoogleAccountRequest 連携リクエスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthGooglePost: async (typesConnectGoogleAccountRequest: TypesConnectGoogleAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesConnectGoogleAccountRequest' is not null or undefined
            assertParamExists('v1AuthGooglePost', 'typesConnectGoogleAccountRequest', typesConnectGoogleAccountRequest)
            const localVarPath = `/v1/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesConnectGoogleAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * LINEアカウント連携用の認証URLを発行します。
         * @summary LINE認証用URLの発行
         * @param {string} state CSRF対策用のstate
         * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLineGet: async (state: string, redirectUri?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('v1AuthLineGet', 'state', state)
            const localVarPath = `/v1/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * LINEアカウントを連携します。
         * @summary LINEアカウントの連携
         * @param {TypesConnectLINEAccountRequest} typesConnectLINEAccountRequest 連携リクエスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLinePost: async (typesConnectLINEAccountRequest: TypesConnectLINEAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesConnectLINEAccountRequest' is not null or undefined
            assertParamExists('v1AuthLinePost', 'typesConnectLINEAccountRequest', typesConnectLINEAccountRequest)
            const localVarPath = `/v1/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesConnectLINEAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン中のユーザーのパスワードを更新します。
         * @summary パスワード更新
         * @param {UpdateAuthPasswordRequest} updateAuthPasswordRequest パスワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthPasswordPatch: async (updateAuthPasswordRequest: UpdateAuthPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAuthPasswordRequest' is not null or undefined
            assertParamExists('v1AuthPasswordPatch', 'updateAuthPasswordRequest', updateAuthPasswordRequest)
            const localVarPath = `/v1/auth/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAuthPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * メールアドレスとパスワードでサインインします。
         * @summary サインイン
         * @param {SignInRequest} signInRequest サインイン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthPost: async (signInRequest: SignInRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInRequest' is not null or undefined
            assertParamExists('v1AuthPost', 'signInRequest', signInRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 連携済みの外部認証プロバイダ一覧を取得します。
         * @summary 認証済みプロバイダ一覧の取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthProvidersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * リフレッシュトークンを使用してアクセストークンを更新します。
         * @summary トークン更新
         * @param {RefreshAuthTokenRequest} refreshAuthTokenRequest トークン更新
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRefreshTokenPost: async (refreshAuthTokenRequest: RefreshAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshAuthTokenRequest' is not null or undefined
            assertParamExists('v1AuthRefreshTokenPost', 'refreshAuthTokenRequest', refreshAuthTokenRequest)
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログイン中の管理者情報を取得します。
         * @summary 管理者情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * ログイン中のコーディネータの詳細情報を取得します。
         * @summary 自身のコーディネータ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthCoordinatorGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoordinatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthCoordinatorGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthCoordinatorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ログイン中のコーディネータの情報を更新します。
         * @summary 自身のコーディネータ情報更新
         * @param {TypesUpdateCoordinatorRequest} typesUpdateCoordinatorRequest コーディネータ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthCoordinatorPatch(typesUpdateCoordinatorRequest: TypesUpdateCoordinatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthCoordinatorPatch(typesUpdateCoordinatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthCoordinatorPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ログイン中のコーディネータの配送設定を取得します。
         * @summary 自身の配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthCoordinatorShippingsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthCoordinatorShippingsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthCoordinatorShippingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ログイン中のコーディネータの配送設定を更新します。
         * @summary 自身の配送設定更新
         * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthCoordinatorShippingsPatch(typesUpsertShippingRequest: TypesUpsertShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthCoordinatorShippingsPatch(typesUpsertShippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthCoordinatorShippingsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * サインアウトします。
         * @summary サインアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * プッシュ通知用のデバイストークンを登録します。
         * @summary デバイストークン登録
         * @param {TypesRegisterAuthDeviceRequest} typesRegisterAuthDeviceRequest デバイストークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthDevicePost(typesRegisterAuthDeviceRequest: TypesRegisterAuthDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthDevicePost(typesRegisterAuthDeviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthDevicePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ログイン中のユーザーのメールアドレスを更新します。
         * @summary メールアドレス更新
         * @param {TypesUpdateAuthEmailRequest} typesUpdateAuthEmailRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthEmailPatch(typesUpdateAuthEmailRequest: TypesUpdateAuthEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthEmailPatch(typesUpdateAuthEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthEmailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * メールアドレス更新用の検証コードを確認します。
         * @summary メールアドレス更新 - コード検証
         * @param {TypesVerifyAuthEmailRequest} typesVerifyAuthEmailRequest 検証コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthEmailVerifiedPost(typesVerifyAuthEmailRequest: TypesVerifyAuthEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthEmailVerifiedPost(typesVerifyAuthEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthEmailVerifiedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * パスワードリセット用のメールを送信します。
         * @summary パスワードリセット
         * @param {ForgotAuthPasswordRequest} forgotAuthPasswordRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthForgotPasswordPost(forgotAuthPasswordRequest: ForgotAuthPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthForgotPasswordPost(forgotAuthPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthForgotPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * パスワードリセット用の検証コードを確認し、新しいパスワードを設定します。
         * @summary パスワードリセット - コード検証
         * @param {ResetAuthPasswordRequest} resetAuthPasswordRequest パスワードリセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthForgotPasswordVerifiedPost(resetAuthPasswordRequest: ResetAuthPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthForgotPasswordVerifiedPost(resetAuthPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthForgotPasswordVerifiedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証トークンを検証し、認証情報を取得します。
         * @summary トークン検証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Googleアカウント連携用の認証URLを発行します。
         * @summary Google認証用URLの発行
         * @param {string} state CSRF対策用のstate
         * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthGoogleGet(state: string, redirectUri?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthGoogleAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthGoogleGet(state, redirectUri, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthGoogleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Googleアカウントを連携します。
         * @summary Googleアカウントの連携
         * @param {TypesConnectGoogleAccountRequest} typesConnectGoogleAccountRequest 連携リクエスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthGooglePost(typesConnectGoogleAccountRequest: TypesConnectGoogleAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthGooglePost(typesConnectGoogleAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthGooglePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * LINEアカウント連携用の認証URLを発行します。
         * @summary LINE認証用URLの発行
         * @param {string} state CSRF対策用のstate
         * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthLineGet(state: string, redirectUri?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLINEAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthLineGet(state, redirectUri, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthLineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * LINEアカウントを連携します。
         * @summary LINEアカウントの連携
         * @param {TypesConnectLINEAccountRequest} typesConnectLINEAccountRequest 連携リクエスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthLinePost(typesConnectLINEAccountRequest: TypesConnectLINEAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthLinePost(typesConnectLINEAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthLinePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ログイン中のユーザーのパスワードを更新します。
         * @summary パスワード更新
         * @param {UpdateAuthPasswordRequest} updateAuthPasswordRequest パスワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthPasswordPatch(updateAuthPasswordRequest: UpdateAuthPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthPasswordPatch(updateAuthPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthPasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * メールアドレスとパスワードでサインインします。
         * @summary サインイン
         * @param {SignInRequest} signInRequest サインイン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthPost(signInRequest: SignInRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthPost(signInRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 連携済みの外部認証プロバイダ一覧を取得します。
         * @summary 認証済みプロバイダ一覧の取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthProvidersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAuthProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthProvidersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthProvidersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * リフレッシュトークンを使用してアクセストークンを更新します。
         * @summary トークン更新
         * @param {RefreshAuthTokenRequest} refreshAuthTokenRequest トークン更新
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthRefreshTokenPost(refreshAuthTokenRequest: RefreshAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthRefreshTokenPost(refreshAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthRefreshTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ログイン中の管理者情報を取得します。
         * @summary 管理者情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthUserGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.v1AuthUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * ログイン中のコーディネータの詳細情報を取得します。
         * @summary 自身のコーディネータ情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorGet(options?: RawAxiosRequestConfig): AxiosPromise<CoordinatorResponse> {
            return localVarFp.v1AuthCoordinatorGet(options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン中のコーディネータの情報を更新します。
         * @summary 自身のコーディネータ情報更新
         * @param {TypesUpdateCoordinatorRequest} typesUpdateCoordinatorRequest コーディネータ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorPatch(typesUpdateCoordinatorRequest: TypesUpdateCoordinatorRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthCoordinatorPatch(typesUpdateCoordinatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン中のコーディネータの配送設定を取得します。
         * @summary 自身の配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorShippingsGet(options?: RawAxiosRequestConfig): AxiosPromise<TypesShippingResponse> {
            return localVarFp.v1AuthCoordinatorShippingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン中のコーディネータの配送設定を更新します。
         * @summary 自身の配送設定更新
         * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthCoordinatorShippingsPatch(typesUpsertShippingRequest: TypesUpsertShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthCoordinatorShippingsPatch(typesUpsertShippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * サインアウトします。
         * @summary サインアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * プッシュ通知用のデバイストークンを登録します。
         * @summary デバイストークン登録
         * @param {TypesRegisterAuthDeviceRequest} typesRegisterAuthDeviceRequest デバイストークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthDevicePost(typesRegisterAuthDeviceRequest: TypesRegisterAuthDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthDevicePost(typesRegisterAuthDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン中のユーザーのメールアドレスを更新します。
         * @summary メールアドレス更新
         * @param {TypesUpdateAuthEmailRequest} typesUpdateAuthEmailRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthEmailPatch(typesUpdateAuthEmailRequest: TypesUpdateAuthEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthEmailPatch(typesUpdateAuthEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * メールアドレス更新用の検証コードを確認します。
         * @summary メールアドレス更新 - コード検証
         * @param {TypesVerifyAuthEmailRequest} typesVerifyAuthEmailRequest 検証コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthEmailVerifiedPost(typesVerifyAuthEmailRequest: TypesVerifyAuthEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthEmailVerifiedPost(typesVerifyAuthEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * パスワードリセット用のメールを送信します。
         * @summary パスワードリセット
         * @param {ForgotAuthPasswordRequest} forgotAuthPasswordRequest メールアドレス
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthForgotPasswordPost(forgotAuthPasswordRequest: ForgotAuthPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthForgotPasswordPost(forgotAuthPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * パスワードリセット用の検証コードを確認し、新しいパスワードを設定します。
         * @summary パスワードリセット - コード検証
         * @param {ResetAuthPasswordRequest} resetAuthPasswordRequest パスワードリセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthForgotPasswordVerifiedPost(resetAuthPasswordRequest: ResetAuthPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthForgotPasswordVerifiedPost(resetAuthPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 認証トークンを検証し、認証情報を取得します。
         * @summary トークン検証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthGet(options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1AuthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Googleアカウント連携用の認証URLを発行します。
         * @summary Google認証用URLの発行
         * @param {string} state CSRF対策用のstate
         * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthGoogleGet(state: string, redirectUri?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthGoogleAccountResponse> {
            return localVarFp.v1AuthGoogleGet(state, redirectUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Googleアカウントを連携します。
         * @summary Googleアカウントの連携
         * @param {TypesConnectGoogleAccountRequest} typesConnectGoogleAccountRequest 連携リクエスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthGooglePost(typesConnectGoogleAccountRequest: TypesConnectGoogleAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1AuthGooglePost(typesConnectGoogleAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * LINEアカウント連携用の認証URLを発行します。
         * @summary LINE認証用URLの発行
         * @param {string} state CSRF対策用のstate
         * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLineGet(state: string, redirectUri?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthLINEAccountResponse> {
            return localVarFp.v1AuthLineGet(state, redirectUri, options).then((request) => request(axios, basePath));
        },
        /**
         * LINEアカウントを連携します。
         * @summary LINEアカウントの連携
         * @param {TypesConnectLINEAccountRequest} typesConnectLINEAccountRequest 連携リクエスト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLinePost(typesConnectLINEAccountRequest: TypesConnectLINEAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1AuthLinePost(typesConnectLINEAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン中のユーザーのパスワードを更新します。
         * @summary パスワード更新
         * @param {UpdateAuthPasswordRequest} updateAuthPasswordRequest パスワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthPasswordPatch(updateAuthPasswordRequest: UpdateAuthPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1AuthPasswordPatch(updateAuthPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * メールアドレスとパスワードでサインインします。
         * @summary サインイン
         * @param {SignInRequest} signInRequest サインイン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthPost(signInRequest: SignInRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1AuthPost(signInRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 連携済みの外部認証プロバイダ一覧を取得します。
         * @summary 認証済みプロバイダ一覧の取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthProvidersGet(options?: RawAxiosRequestConfig): AxiosPromise<TypesAuthProvidersResponse> {
            return localVarFp.v1AuthProvidersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * リフレッシュトークンを使用してアクセストークンを更新します。
         * @summary トークン更新
         * @param {RefreshAuthTokenRequest} refreshAuthTokenRequest トークン更新
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRefreshTokenPost(refreshAuthTokenRequest: RefreshAuthTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.v1AuthRefreshTokenPost(refreshAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ログイン中の管理者情報を取得します。
         * @summary 管理者情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthUserGet(options?: RawAxiosRequestConfig): AxiosPromise<AuthUserResponse> {
            return localVarFp.v1AuthUserGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * ログイン中のコーディネータの詳細情報を取得します。
     * @summary 自身のコーディネータ情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthCoordinatorGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthCoordinatorGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン中のコーディネータの情報を更新します。
     * @summary 自身のコーディネータ情報更新
     * @param {TypesUpdateCoordinatorRequest} typesUpdateCoordinatorRequest コーディネータ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthCoordinatorPatch(typesUpdateCoordinatorRequest: TypesUpdateCoordinatorRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthCoordinatorPatch(typesUpdateCoordinatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン中のコーディネータの配送設定を取得します。
     * @summary 自身の配送設定取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthCoordinatorShippingsGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthCoordinatorShippingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン中のコーディネータの配送設定を更新します。
     * @summary 自身の配送設定更新
     * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthCoordinatorShippingsPatch(typesUpsertShippingRequest: TypesUpsertShippingRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthCoordinatorShippingsPatch(typesUpsertShippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * サインアウトします。
     * @summary サインアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthDelete(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * プッシュ通知用のデバイストークンを登録します。
     * @summary デバイストークン登録
     * @param {TypesRegisterAuthDeviceRequest} typesRegisterAuthDeviceRequest デバイストークン
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthDevicePost(typesRegisterAuthDeviceRequest: TypesRegisterAuthDeviceRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthDevicePost(typesRegisterAuthDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン中のユーザーのメールアドレスを更新します。
     * @summary メールアドレス更新
     * @param {TypesUpdateAuthEmailRequest} typesUpdateAuthEmailRequest メールアドレス
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthEmailPatch(typesUpdateAuthEmailRequest: TypesUpdateAuthEmailRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthEmailPatch(typesUpdateAuthEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * メールアドレス更新用の検証コードを確認します。
     * @summary メールアドレス更新 - コード検証
     * @param {TypesVerifyAuthEmailRequest} typesVerifyAuthEmailRequest 検証コード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthEmailVerifiedPost(typesVerifyAuthEmailRequest: TypesVerifyAuthEmailRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthEmailVerifiedPost(typesVerifyAuthEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワードリセット用のメールを送信します。
     * @summary パスワードリセット
     * @param {ForgotAuthPasswordRequest} forgotAuthPasswordRequest メールアドレス
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthForgotPasswordPost(forgotAuthPasswordRequest: ForgotAuthPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthForgotPasswordPost(forgotAuthPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パスワードリセット用の検証コードを確認し、新しいパスワードを設定します。
     * @summary パスワードリセット - コード検証
     * @param {ResetAuthPasswordRequest} resetAuthPasswordRequest パスワードリセット
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthForgotPasswordVerifiedPost(resetAuthPasswordRequest: ResetAuthPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthForgotPasswordVerifiedPost(resetAuthPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証トークンを検証し、認証情報を取得します。
     * @summary トークン検証
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Googleアカウント連携用の認証URLを発行します。
     * @summary Google認証用URLの発行
     * @param {string} state CSRF対策用のstate
     * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthGoogleGet(state: string, redirectUri?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthGoogleGet(state, redirectUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Googleアカウントを連携します。
     * @summary Googleアカウントの連携
     * @param {TypesConnectGoogleAccountRequest} typesConnectGoogleAccountRequest 連携リクエスト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthGooglePost(typesConnectGoogleAccountRequest: TypesConnectGoogleAccountRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthGooglePost(typesConnectGoogleAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * LINEアカウント連携用の認証URLを発行します。
     * @summary LINE認証用URLの発行
     * @param {string} state CSRF対策用のstate
     * @param {string} [redirectUri] 認証後のリダイレクト先（変更したいときのみ指定）
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthLineGet(state: string, redirectUri?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthLineGet(state, redirectUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * LINEアカウントを連携します。
     * @summary LINEアカウントの連携
     * @param {TypesConnectLINEAccountRequest} typesConnectLINEAccountRequest 連携リクエスト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthLinePost(typesConnectLINEAccountRequest: TypesConnectLINEAccountRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthLinePost(typesConnectLINEAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン中のユーザーのパスワードを更新します。
     * @summary パスワード更新
     * @param {UpdateAuthPasswordRequest} updateAuthPasswordRequest パスワード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthPasswordPatch(updateAuthPasswordRequest: UpdateAuthPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthPasswordPatch(updateAuthPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * メールアドレスとパスワードでサインインします。
     * @summary サインイン
     * @param {SignInRequest} signInRequest サインイン
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthPost(signInRequest: SignInRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthPost(signInRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 連携済みの外部認証プロバイダ一覧を取得します。
     * @summary 認証済みプロバイダ一覧の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthProvidersGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthProvidersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * リフレッシュトークンを使用してアクセストークンを更新します。
     * @summary トークン更新
     * @param {RefreshAuthTokenRequest} refreshAuthTokenRequest トークン更新
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthRefreshTokenPost(refreshAuthTokenRequest: RefreshAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthRefreshTokenPost(refreshAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ログイン中の管理者情報を取得します。
     * @summary 管理者情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthUserGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthUserGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BroadcastApi - axios parameter creator
 * @export
 */
export const BroadcastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/guests/schedules/-/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieauth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Youtube認証完了後のコールバック処理を行います。
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost: async (typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCallbackAuthYoutubeBroadcastRequest' is not null or undefined
            assertParamExists('v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost', 'typesCallbackAuthYoutubeBroadcastRequest', typesCallbackAuthYoutubeBroadcastRequest)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube/auth/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCallbackAuthYoutubeBroadcastRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Youtube側でライブ配信を作成します。
         * @summary マルシェライブ配信のYoutube連携
         * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubePost: async (typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateYoutubeBroadcastRequest' is not null or undefined
            assertParamExists('v1GuestsSchedulesBroadcastsYoutubePost', 'typesCreateYoutubeBroadcastRequest', typesCreateYoutubeBroadcastRequest)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieauth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateYoutubeBroadcastRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信終了後にオンデマンド配信用の映像をアップロードします。
         * @summary オンデマンド配信用の映像をアップロード
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesUpdateBroadcastArchiveRequest} typesUpdateBroadcastArchiveRequest アーカイブURL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsArchiveVideoPost: async (scheduleId: string, typesUpdateBroadcastArchiveRequest: TypesUpdateBroadcastArchiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsArchiveVideoPost', 'scheduleId', scheduleId)
            // verify required parameter 'typesUpdateBroadcastArchiveRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsArchiveVideoPost', 'typesUpdateBroadcastArchiveRequest', typesUpdateBroadcastArchiveRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/archive-video`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateBroadcastArchiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信を一時停止します。
         * @summary マルシェライブ配信一時停止
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsDelete: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsDelete', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたスケジュールのライブ配信情報を取得します。
         * @summary マルシェライブ配信取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsGet: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信の入力ソースをMP4ファイルに切り替えます。
         * @summary ライブ配信中の入力をMP4へ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesActivateBroadcastMP4Request} typesActivateBroadcastMP4Request MP4ファイルURL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsMp4Post: async (scheduleId: string, typesActivateBroadcastMP4Request: TypesActivateBroadcastMP4Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsMp4Post', 'scheduleId', scheduleId)
            // verify required parameter 'typesActivateBroadcastMP4Request' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsMp4Post', 'typesActivateBroadcastMP4Request', typesActivateBroadcastMP4Request)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/mp4`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesActivateBroadcastMP4Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信の一時停止を解除します。
         * @summary マルシェライブ配信一時停止解除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsPost: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsPost', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信の入力ソースをRTMPに切り替えます。
         * @summary ライブ配信中の入力をRTMPへ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsRtmpPost: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsRtmpPost', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/rtmp`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信中のふた絵（静止画）を無効化して通常配信に戻します。
         * @summary ライブ配信のふた絵を無効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsStaticImageDelete: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsStaticImageDelete', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/static-image`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信中にふた絵（静止画）を表示します。
         * @summary ライブ配信のふた絵を有効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsStaticImagePost: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsStaticImagePost', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/static-image`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Youtube配信用の認証URLを取得します。
         * @summary マルシェライブ配信のYoutube連携を認証
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesAuthYoutubeBroadcastRequest} typesAuthYoutubeBroadcastRequest Youtubeハンドル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsYoutubeAuthPost: async (scheduleId: string, typesAuthYoutubeBroadcastRequest: TypesAuthYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsYoutubeAuthPost', 'scheduleId', scheduleId)
            // verify required parameter 'typesAuthYoutubeBroadcastRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdBroadcastsYoutubeAuthPost', 'typesAuthYoutubeBroadcastRequest', typesAuthYoutubeBroadcastRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/broadcasts/youtube/auth`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesAuthYoutubeBroadcastRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BroadcastApi - functional programming interface
 * @export
 */
export const BroadcastApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BroadcastApiAxiosParamCreator(configuration)
    return {
        /**
         * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestsSchedulesBroadcastsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesGuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestsSchedulesBroadcastsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GuestsSchedulesBroadcastsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Youtube認証完了後のコールバック処理を行います。
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesGuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Youtube側でライブ配信を作成します。
         * @summary マルシェライブ配信のYoutube連携
         * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1GuestsSchedulesBroadcastsYoutubePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信終了後にオンデマンド配信用の映像をアップロードします。
         * @summary オンデマンド配信用の映像をアップロード
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesUpdateBroadcastArchiveRequest} typesUpdateBroadcastArchiveRequest アーカイブURL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsArchiveVideoPost(scheduleId: string, typesUpdateBroadcastArchiveRequest: TypesUpdateBroadcastArchiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsArchiveVideoPost(scheduleId, typesUpdateBroadcastArchiveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsArchiveVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信を一時停止します。
         * @summary マルシェライブ配信一時停止
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsDelete(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsDelete(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたスケジュールのライブ配信情報を取得します。
         * @summary マルシェライブ配信取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsGet(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsGet(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信の入力ソースをMP4ファイルに切り替えます。
         * @summary ライブ配信中の入力をMP4へ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesActivateBroadcastMP4Request} typesActivateBroadcastMP4Request MP4ファイルURL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsMp4Post(scheduleId: string, typesActivateBroadcastMP4Request: TypesActivateBroadcastMP4Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsMp4Post(scheduleId, typesActivateBroadcastMP4Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsMp4Post']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信の一時停止を解除します。
         * @summary マルシェライブ配信一時停止解除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsPost(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsPost(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信の入力ソースをRTMPに切り替えます。
         * @summary ライブ配信中の入力をRTMPへ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsRtmpPost(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsRtmpPost(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsRtmpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信中のふた絵（静止画）を無効化して通常配信に戻します。
         * @summary ライブ配信のふた絵を無効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsStaticImageDelete(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsStaticImageDelete(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsStaticImageDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信中にふた絵（静止画）を表示します。
         * @summary ライブ配信のふた絵を有効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsStaticImagePost(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsStaticImagePost(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsStaticImagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Youtube配信用の認証URLを取得します。
         * @summary マルシェライブ配信のYoutube連携を認証
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesAuthYoutubeBroadcastRequest} typesAuthYoutubeBroadcastRequest Youtubeハンドル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdBroadcastsYoutubeAuthPost(scheduleId: string, typesAuthYoutubeBroadcastRequest: TypesAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAuthYoutubeBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdBroadcastsYoutubeAuthPost(scheduleId, typesAuthYoutubeBroadcastRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BroadcastApi.v1SchedulesScheduleIdBroadcastsYoutubeAuthPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BroadcastApi - factory interface
 * @export
 */
export const BroadcastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BroadcastApiFp(configuration)
    return {
        /**
         * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsGet(options?: RawAxiosRequestConfig): AxiosPromise<TypesGuestBroadcastResponse> {
            return localVarFp.v1GuestsSchedulesBroadcastsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Youtube認証完了後のコールバック処理を行います。
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesGuestBroadcastResponse> {
            return localVarFp.v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Youtube側でライブ配信を作成します。
         * @summary マルシェライブ配信のYoutube連携
         * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信終了後にオンデマンド配信用の映像をアップロードします。
         * @summary オンデマンド配信用の映像をアップロード
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesUpdateBroadcastArchiveRequest} typesUpdateBroadcastArchiveRequest アーカイブURL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsArchiveVideoPost(scheduleId: string, typesUpdateBroadcastArchiveRequest: TypesUpdateBroadcastArchiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsArchiveVideoPost(scheduleId, typesUpdateBroadcastArchiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信を一時停止します。
         * @summary マルシェライブ配信一時停止
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsDelete(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsDelete(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたスケジュールのライブ配信情報を取得します。
         * @summary マルシェライブ配信取得
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsGet(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesBroadcastResponse> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsGet(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信の入力ソースをMP4ファイルに切り替えます。
         * @summary ライブ配信中の入力をMP4へ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesActivateBroadcastMP4Request} typesActivateBroadcastMP4Request MP4ファイルURL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsMp4Post(scheduleId: string, typesActivateBroadcastMP4Request: TypesActivateBroadcastMP4Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsMp4Post(scheduleId, typesActivateBroadcastMP4Request, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信の一時停止を解除します。
         * @summary マルシェライブ配信一時停止解除
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsPost(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsPost(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信の入力ソースをRTMPに切り替えます。
         * @summary ライブ配信中の入力をRTMPへ切り替え
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsRtmpPost(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsRtmpPost(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信中のふた絵（静止画）を無効化して通常配信に戻します。
         * @summary ライブ配信のふた絵を無効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsStaticImageDelete(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsStaticImageDelete(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信中にふた絵（静止画）を表示します。
         * @summary ライブ配信のふた絵を有効化
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsStaticImagePost(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsStaticImagePost(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Youtube配信用の認証URLを取得します。
         * @summary マルシェライブ配信のYoutube連携を認証
         * @param {string} scheduleId マルシェ開催スケジュールID
         * @param {TypesAuthYoutubeBroadcastRequest} typesAuthYoutubeBroadcastRequest Youtubeハンドル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdBroadcastsYoutubeAuthPost(scheduleId: string, typesAuthYoutubeBroadcastRequest: TypesAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesAuthYoutubeBroadcastResponse> {
            return localVarFp.v1SchedulesScheduleIdBroadcastsYoutubeAuthPost(scheduleId, typesAuthYoutubeBroadcastRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BroadcastApi - object-oriented interface
 * @export
 * @class BroadcastApi
 * @extends {BaseAPI}
 */
export class BroadcastApi extends BaseAPI {
    /**
     * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
     * @summary ゲスト用ライブ配信情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GuestsSchedulesBroadcastsGet(options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GuestsSchedulesBroadcastsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Youtube認証完了後のコールバック処理を行います。
     * @summary マルシェライブ配信のYoutube認証後処理
     * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Youtube側でライブ配信を作成します。
     * @summary マルシェライブ配信のYoutube連携
     * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信終了後にオンデマンド配信用の映像をアップロードします。
     * @summary オンデマンド配信用の映像をアップロード
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {TypesUpdateBroadcastArchiveRequest} typesUpdateBroadcastArchiveRequest アーカイブURL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsArchiveVideoPost(scheduleId: string, typesUpdateBroadcastArchiveRequest: TypesUpdateBroadcastArchiveRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsArchiveVideoPost(scheduleId, typesUpdateBroadcastArchiveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信を一時停止します。
     * @summary マルシェライブ配信一時停止
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsDelete(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsDelete(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたスケジュールのライブ配信情報を取得します。
     * @summary マルシェライブ配信取得
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsGet(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsGet(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信の入力ソースをMP4ファイルに切り替えます。
     * @summary ライブ配信中の入力をMP4へ切り替え
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {TypesActivateBroadcastMP4Request} typesActivateBroadcastMP4Request MP4ファイルURL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsMp4Post(scheduleId: string, typesActivateBroadcastMP4Request: TypesActivateBroadcastMP4Request, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsMp4Post(scheduleId, typesActivateBroadcastMP4Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信の一時停止を解除します。
     * @summary マルシェライブ配信一時停止解除
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsPost(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsPost(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信の入力ソースをRTMPに切り替えます。
     * @summary ライブ配信中の入力をRTMPへ切り替え
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsRtmpPost(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsRtmpPost(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信中のふた絵（静止画）を無効化して通常配信に戻します。
     * @summary ライブ配信のふた絵を無効化
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsStaticImageDelete(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsStaticImageDelete(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信中にふた絵（静止画）を表示します。
     * @summary ライブ配信のふた絵を有効化
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsStaticImagePost(scheduleId: string, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsStaticImagePost(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Youtube配信用の認証URLを取得します。
     * @summary マルシェライブ配信のYoutube連携を認証
     * @param {string} scheduleId マルシェ開催スケジュールID
     * @param {TypesAuthYoutubeBroadcastRequest} typesAuthYoutubeBroadcastRequest Youtubeハンドル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BroadcastApi
     */
    public v1SchedulesScheduleIdBroadcastsYoutubeAuthPost(scheduleId: string, typesAuthYoutubeBroadcastRequest: TypesAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return BroadcastApiFp(this.configuration).v1SchedulesScheduleIdBroadcastsYoutubeAuthPost(scheduleId, typesAuthYoutubeBroadcastRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 商品種別を削除します。
         * @summary 商品種別削除
         * @param {string} categoryId 商品種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdDelete: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdDelete', 'categoryId', categoryId)
            const localVarPath = `/v1/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品種別の情報を更新します。
         * @summary 商品種別更新
         * @param {string} categoryId 商品種別ID
         * @param {TypesUpdateCategoryRequest} typesUpdateCategoryRequest 商品種別情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdPatch: async (categoryId: string, typesUpdateCategoryRequest: TypesUpdateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdPatch', 'categoryId', categoryId)
            // verify required parameter 'typesUpdateCategoryRequest' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdPatch', 'typesUpdateCategoryRequest', typesUpdateCategoryRequest)
            const localVarPath = `/v1/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品種別の一覧を取得します。
         * @summary 商品種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesGet: async (limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい商品種別を登録します。
         * @summary 商品種別登録
         * @param {TypesCreateCategoryRequest} typesCreateCategoryRequest 商品種別情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesPost: async (typesCreateCategoryRequest: TypesCreateCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateCategoryRequest' is not null or undefined
            assertParamExists('v1CategoriesPost', 'typesCreateCategoryRequest', typesCreateCategoryRequest)
            const localVarPath = `/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 商品種別を削除します。
         * @summary 商品種別削除
         * @param {string} categoryId 商品種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesCategoryIdDelete(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesCategoryIdDelete(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1CategoriesCategoryIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品種別の情報を更新します。
         * @summary 商品種別更新
         * @param {string} categoryId 商品種別ID
         * @param {TypesUpdateCategoryRequest} typesUpdateCategoryRequest 商品種別情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesCategoryIdPatch(categoryId: string, typesUpdateCategoryRequest: TypesUpdateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesCategoryIdPatch(categoryId, typesUpdateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1CategoriesCategoryIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品種別の一覧を取得します。
         * @summary 商品種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesGet(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesGet(limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1CategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい商品種別を登録します。
         * @summary 商品種別登録
         * @param {TypesCreateCategoryRequest} typesCreateCategoryRequest 商品種別情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesPost(typesCreateCategoryRequest: TypesCreateCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesPost(typesCreateCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.v1CategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 商品種別を削除します。
         * @summary 商品種別削除
         * @param {string} categoryId 商品種別ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdDelete(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CategoriesCategoryIdDelete(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品種別の情報を更新します。
         * @summary 商品種別更新
         * @param {string} categoryId 商品種別ID
         * @param {TypesUpdateCategoryRequest} typesUpdateCategoryRequest 商品種別情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdPatch(categoryId: string, typesUpdateCategoryRequest: TypesUpdateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CategoriesCategoryIdPatch(categoryId, typesUpdateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品種別の一覧を取得します。
         * @summary 商品種別一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesGet(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesCategoriesResponse> {
            return localVarFp.v1CategoriesGet(limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい商品種別を登録します。
         * @summary 商品種別登録
         * @param {TypesCreateCategoryRequest} typesCreateCategoryRequest 商品種別情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesPost(typesCreateCategoryRequest: TypesCreateCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesCategoryResponse> {
            return localVarFp.v1CategoriesPost(typesCreateCategoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 商品種別を削除します。
     * @summary 商品種別削除
     * @param {string} categoryId 商品種別ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1CategoriesCategoryIdDelete(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1CategoriesCategoryIdDelete(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品種別の情報を更新します。
     * @summary 商品種別更新
     * @param {string} categoryId 商品種別ID
     * @param {TypesUpdateCategoryRequest} typesUpdateCategoryRequest 商品種別情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1CategoriesCategoryIdPatch(categoryId: string, typesUpdateCategoryRequest: TypesUpdateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1CategoriesCategoryIdPatch(categoryId, typesUpdateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品種別の一覧を取得します。
     * @summary 商品種別一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 商品種別名(あいまい検索)(32文字以内)
     * @param {string} [orders] ソート(name,-name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1CategoriesGet(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1CategoriesGet(limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい商品種別を登録します。
     * @summary 商品種別登録
     * @param {TypesCreateCategoryRequest} typesCreateCategoryRequest 商品種別情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public v1CategoriesPost(typesCreateCategoryRequest: TypesCreateCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).v1CategoriesPost(typesCreateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactApi - axios parameter creator
 * @export
 */
export const ContactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * お問い合わせを削除します。
         * @summary お問い合わせ削除
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdDelete: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdDelete', 'contactId', contactId)
            const localVarPath = `/v1/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたお問い合わせの詳細情報を取得します。
         * @summary お問い合わせ取得
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdGet: async (contactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdGet', 'contactId', contactId)
            const localVarPath = `/v1/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お問い合わせの情報を更新します。
         * @summary お問い合わせ更新
         * @param {string} contactId お問い合わせID
         * @param {TypesUpdateContactRequest} typesUpdateContactRequest お問い合わせ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdPatch: async (contactId: string, typesUpdateContactRequest: TypesUpdateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdPatch', 'contactId', contactId)
            // verify required parameter 'typesUpdateContactRequest' is not null or undefined
            assertParamExists('v1ContactsContactIdPatch', 'typesUpdateContactRequest', typesUpdateContactRequest)
            const localVarPath = `/v1/contacts/{contactId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お問い合わせの一覧を取得します。
         * @summary お問い合わせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsGet: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいお問い合わせを登録します。
         * @summary お問い合わせ登録
         * @param {TypesCreateContactRequest} typesCreateContactRequest お問い合わせ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsPost: async (typesCreateContactRequest: TypesCreateContactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateContactRequest' is not null or undefined
            assertParamExists('v1ContactsPost', 'typesCreateContactRequest', typesCreateContactRequest)
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateContactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactApiAxiosParamCreator(configuration)
    return {
        /**
         * お問い合わせを削除します。
         * @summary お問い合わせ削除
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdDelete(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdDelete(contactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1ContactsContactIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたお問い合わせの詳細情報を取得します。
         * @summary お問い合わせ取得
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdGet(contactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdGet(contactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1ContactsContactIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * お問い合わせの情報を更新します。
         * @summary お問い合わせ更新
         * @param {string} contactId お問い合わせID
         * @param {TypesUpdateContactRequest} typesUpdateContactRequest お問い合わせ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdPatch(contactId: string, typesUpdateContactRequest: TypesUpdateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdPatch(contactId, typesUpdateContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1ContactsContactIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * お問い合わせの一覧を取得します。
         * @summary お問い合わせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1ContactsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいお問い合わせを登録します。
         * @summary お問い合わせ登録
         * @param {TypesCreateContactRequest} typesCreateContactRequest お問い合わせ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsPost(typesCreateContactRequest: TypesCreateContactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesContactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsPost(typesCreateContactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactApi.v1ContactsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactApiFp(configuration)
    return {
        /**
         * お問い合わせを削除します。
         * @summary お問い合わせ削除
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdDelete(contactId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ContactsContactIdDelete(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたお問い合わせの詳細情報を取得します。
         * @summary お問い合わせ取得
         * @param {string} contactId お問い合わせID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdGet(contactId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesContactResponse> {
            return localVarFp.v1ContactsContactIdGet(contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * お問い合わせの情報を更新します。
         * @summary お問い合わせ更新
         * @param {string} contactId お問い合わせID
         * @param {TypesUpdateContactRequest} typesUpdateContactRequest お問い合わせ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdPatch(contactId: string, typesUpdateContactRequest: TypesUpdateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ContactsContactIdPatch(contactId, typesUpdateContactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * お問い合わせの一覧を取得します。
         * @summary お問い合わせ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesContactsResponse> {
            return localVarFp.v1ContactsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいお問い合わせを登録します。
         * @summary お問い合わせ登録
         * @param {TypesCreateContactRequest} typesCreateContactRequest お問い合わせ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsPost(typesCreateContactRequest: TypesCreateContactRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesContactResponse> {
            return localVarFp.v1ContactsPost(typesCreateContactRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * お問い合わせを削除します。
     * @summary お問い合わせ削除
     * @param {string} contactId お問い合わせID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1ContactsContactIdDelete(contactId: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1ContactsContactIdDelete(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたお問い合わせの詳細情報を取得します。
     * @summary お問い合わせ取得
     * @param {string} contactId お問い合わせID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1ContactsContactIdGet(contactId: string, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1ContactsContactIdGet(contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * お問い合わせの情報を更新します。
     * @summary お問い合わせ更新
     * @param {string} contactId お問い合わせID
     * @param {TypesUpdateContactRequest} typesUpdateContactRequest お問い合わせ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1ContactsContactIdPatch(contactId: string, typesUpdateContactRequest: TypesUpdateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1ContactsContactIdPatch(contactId, typesUpdateContactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * お問い合わせの一覧を取得します。
     * @summary お問い合わせ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1ContactsGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1ContactsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいお問い合わせを登録します。
     * @summary お問い合わせ登録
     * @param {TypesCreateContactRequest} typesCreateContactRequest お問い合わせ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public v1ContactsPost(typesCreateContactRequest: TypesCreateContactRequest, options?: RawAxiosRequestConfig) {
        return ContactApiFp(this.configuration).v1ContactsPost(typesCreateContactRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactCategoryApi - axios parameter creator
 * @export
 */
export const ContactCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたお問い合わせカテゴリの詳細情報を取得します。
         * @summary お問い合わせカテゴリ取得
         * @param {string} contactCategoryId お問い合わせカテゴリID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactCategoriesContactCategoryIdGet: async (contactCategoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactCategoryId' is not null or undefined
            assertParamExists('v1ContactCategoriesContactCategoryIdGet', 'contactCategoryId', contactCategoryId)
            const localVarPath = `/v1/contact-categories/{contactCategoryId}`
                .replace(`{${"contactCategoryId"}}`, encodeURIComponent(String(contactCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お問い合わせカテゴリの一覧を取得します。
         * @summary お問い合わせカテゴリ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactCategoriesGet: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contact-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactCategoryApi - functional programming interface
 * @export
 */
export const ContactCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたお問い合わせカテゴリの詳細情報を取得します。
         * @summary お問い合わせカテゴリ取得
         * @param {string} contactCategoryId お問い合わせカテゴリID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactCategoriesContactCategoryIdGet(contactCategoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesContactCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactCategoriesContactCategoryIdGet(contactCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactCategoryApi.v1ContactCategoriesContactCategoryIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * お問い合わせカテゴリの一覧を取得します。
         * @summary お問い合わせカテゴリ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactCategoriesGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesContactCategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactCategoriesGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactCategoryApi.v1ContactCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactCategoryApi - factory interface
 * @export
 */
export const ContactCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactCategoryApiFp(configuration)
    return {
        /**
         * 指定されたお問い合わせカテゴリの詳細情報を取得します。
         * @summary お問い合わせカテゴリ取得
         * @param {string} contactCategoryId お問い合わせカテゴリID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactCategoriesContactCategoryIdGet(contactCategoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesContactCategoryResponse> {
            return localVarFp.v1ContactCategoriesContactCategoryIdGet(contactCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * お問い合わせカテゴリの一覧を取得します。
         * @summary お問い合わせカテゴリ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactCategoriesGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesContactCategoriesResponse> {
            return localVarFp.v1ContactCategoriesGet(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactCategoryApi - object-oriented interface
 * @export
 * @class ContactCategoryApi
 * @extends {BaseAPI}
 */
export class ContactCategoryApi extends BaseAPI {
    /**
     * 指定されたお問い合わせカテゴリの詳細情報を取得します。
     * @summary お問い合わせカテゴリ取得
     * @param {string} contactCategoryId お問い合わせカテゴリID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactCategoryApi
     */
    public v1ContactCategoriesContactCategoryIdGet(contactCategoryId: string, options?: RawAxiosRequestConfig) {
        return ContactCategoryApiFp(this.configuration).v1ContactCategoriesContactCategoryIdGet(contactCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * お問い合わせカテゴリの一覧を取得します。
     * @summary お問い合わせカテゴリ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactCategoryApi
     */
    public v1ContactCategoriesGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ContactCategoryApiFp(this.configuration).v1ContactCategoriesGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactReadApi - axios parameter creator
 * @export
 */
export const ContactReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * お問い合わせの既読状態を登録します。
         * @summary お問い合わせ既読登録
         * @param {TypesCreateContactReadRequest} typesCreateContactReadRequest 既読情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactReadsPost: async (typesCreateContactReadRequest: TypesCreateContactReadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateContactReadRequest' is not null or undefined
            assertParamExists('v1ContactReadsPost', 'typesCreateContactReadRequest', typesCreateContactReadRequest)
            const localVarPath = `/v1/contact-reads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateContactReadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactReadApi - functional programming interface
 * @export
 */
export const ContactReadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactReadApiAxiosParamCreator(configuration)
    return {
        /**
         * お問い合わせの既読状態を登録します。
         * @summary お問い合わせ既読登録
         * @param {TypesCreateContactReadRequest} typesCreateContactReadRequest 既読情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactReadsPost(typesCreateContactReadRequest: TypesCreateContactReadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesContactReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactReadsPost(typesCreateContactReadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactReadApi.v1ContactReadsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactReadApi - factory interface
 * @export
 */
export const ContactReadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactReadApiFp(configuration)
    return {
        /**
         * お問い合わせの既読状態を登録します。
         * @summary お問い合わせ既読登録
         * @param {TypesCreateContactReadRequest} typesCreateContactReadRequest 既読情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactReadsPost(typesCreateContactReadRequest: TypesCreateContactReadRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesContactReadResponse> {
            return localVarFp.v1ContactReadsPost(typesCreateContactReadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactReadApi - object-oriented interface
 * @export
 * @class ContactReadApi
 * @extends {BaseAPI}
 */
export class ContactReadApi extends BaseAPI {
    /**
     * お問い合わせの既読状態を登録します。
     * @summary お問い合わせ既読登録
     * @param {TypesCreateContactReadRequest} typesCreateContactReadRequest 既読情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactReadApi
     */
    public v1ContactReadsPost(typesCreateContactReadRequest: TypesCreateContactReadRequest, options?: RawAxiosRequestConfig) {
        return ContactReadApiFp(this.configuration).v1ContactReadsPost(typesCreateContactReadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoordinatorApi - axios parameter creator
 * @export
 */
export const CoordinatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * コーディネータの一覧を取得します。
         * @summary コーディネータ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsGet: async (limit?: number, offset?: number, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/coordinators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoordinatorApi - functional programming interface
 * @export
 */
export const CoordinatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoordinatorApiAxiosParamCreator(configuration)
    return {
        /**
         * コーディネータの一覧を取得します。
         * @summary コーディネータ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsGet(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoordinatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsGet(limit, offset, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoordinatorApi.v1CoordinatorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoordinatorApi - factory interface
 * @export
 */
export const CoordinatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoordinatorApiFp(configuration)
    return {
        /**
         * コーディネータの一覧を取得します。
         * @summary コーディネータ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsGet(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<CoordinatorsResponse> {
            return localVarFp.v1CoordinatorsGet(limit, offset, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoordinatorApi - object-oriented interface
 * @export
 * @class CoordinatorApi
 * @extends {BaseAPI}
 */
export class CoordinatorApi extends BaseAPI {
    /**
     * コーディネータの一覧を取得します。
     * @summary コーディネータ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [username] コーディネータ名(あいまい検索)(64文字以内)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoordinatorApi
     */
    public v1CoordinatorsGet(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig) {
        return CoordinatorApiFp(this.configuration).v1CoordinatorsGet(limit, offset, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperienceApi - axios parameter creator
 * @export
 */
export const ExperienceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 体験を削除します。
         * @summary 体験削除
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesExperienceIdDelete: async (experienceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceId' is not null or undefined
            assertParamExists('v1ExperiencesExperienceIdDelete', 'experienceId', experienceId)
            const localVarPath = `/v1/experiences/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された体験の詳細情報を取得します。
         * @summary 体験取得
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesExperienceIdGet: async (experienceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceId' is not null or undefined
            assertParamExists('v1ExperiencesExperienceIdGet', 'experienceId', experienceId)
            const localVarPath = `/v1/experiences/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験の情報を更新します。
         * @summary 体験更新
         * @param {string} experienceId 体験ID
         * @param {TypesUpdateExperienceRequest} typesUpdateExperienceRequest 体験情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesExperienceIdPatch: async (experienceId: string, typesUpdateExperienceRequest: TypesUpdateExperienceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceId' is not null or undefined
            assertParamExists('v1ExperiencesExperienceIdPatch', 'experienceId', experienceId)
            // verify required parameter 'typesUpdateExperienceRequest' is not null or undefined
            assertParamExists('v1ExperiencesExperienceIdPatch', 'typesUpdateExperienceRequest', typesUpdateExperienceRequest)
            const localVarPath = `/v1/experiences/{experienceId}`
                .replace(`{${"experienceId"}}`, encodeURIComponent(String(experienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateExperienceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験の一覧を取得します。店舗、生産者、名前でのフィルタリングが可能です。
         * @summary 体験一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 体験名(あいまい検索)
         * @param {string} [producerId] 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesGet: async (limit?: number, offset?: number, name?: string, producerId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/experiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (producerId !== undefined) {
                localVarQueryParameter['producerId'] = producerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい体験を登録します。コーディネーターは管理店舗の生産者の体験のみ登録可能です。
         * @summary 体験登録
         * @param {TypesCreateExperienceRequest} typesCreateExperienceRequest 体験情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesPost: async (typesCreateExperienceRequest: TypesCreateExperienceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateExperienceRequest' is not null or undefined
            assertParamExists('v1ExperiencesPost', 'typesCreateExperienceRequest', typesCreateExperienceRequest)
            const localVarPath = `/v1/experiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateExperienceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperienceApi - functional programming interface
 * @export
 */
export const ExperienceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperienceApiAxiosParamCreator(configuration)
    return {
        /**
         * 体験を削除します。
         * @summary 体験削除
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperiencesExperienceIdDelete(experienceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperiencesExperienceIdDelete(experienceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1ExperiencesExperienceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された体験の詳細情報を取得します。
         * @summary 体験取得
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperiencesExperienceIdGet(experienceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperiencesExperienceIdGet(experienceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1ExperiencesExperienceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験の情報を更新します。
         * @summary 体験更新
         * @param {string} experienceId 体験ID
         * @param {TypesUpdateExperienceRequest} typesUpdateExperienceRequest 体験情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperiencesExperienceIdPatch(experienceId: string, typesUpdateExperienceRequest: TypesUpdateExperienceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperiencesExperienceIdPatch(experienceId, typesUpdateExperienceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1ExperiencesExperienceIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験の一覧を取得します。店舗、生産者、名前でのフィルタリングが可能です。
         * @summary 体験一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 体験名(あいまい検索)
         * @param {string} [producerId] 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperiencesGet(limit?: number, offset?: number, name?: string, producerId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperiencesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperiencesGet(limit, offset, name, producerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1ExperiencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい体験を登録します。コーディネーターは管理店舗の生産者の体験のみ登録可能です。
         * @summary 体験登録
         * @param {TypesCreateExperienceRequest} typesCreateExperienceRequest 体験情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperiencesPost(typesCreateExperienceRequest: TypesCreateExperienceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperiencesPost(typesCreateExperienceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceApi.v1ExperiencesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExperienceApi - factory interface
 * @export
 */
export const ExperienceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperienceApiFp(configuration)
    return {
        /**
         * 体験を削除します。
         * @summary 体験削除
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesExperienceIdDelete(experienceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ExperiencesExperienceIdDelete(experienceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された体験の詳細情報を取得します。
         * @summary 体験取得
         * @param {string} experienceId 体験ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesExperienceIdGet(experienceId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExperienceResponse> {
            return localVarFp.v1ExperiencesExperienceIdGet(experienceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験の情報を更新します。
         * @summary 体験更新
         * @param {string} experienceId 体験ID
         * @param {TypesUpdateExperienceRequest} typesUpdateExperienceRequest 体験情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesExperienceIdPatch(experienceId: string, typesUpdateExperienceRequest: TypesUpdateExperienceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ExperiencesExperienceIdPatch(experienceId, typesUpdateExperienceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験の一覧を取得します。店舗、生産者、名前でのフィルタリングが可能です。
         * @summary 体験一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 体験名(あいまい検索)
         * @param {string} [producerId] 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesGet(limit?: number, offset?: number, name?: string, producerId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ExperiencesResponse> {
            return localVarFp.v1ExperiencesGet(limit, offset, name, producerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい体験を登録します。コーディネーターは管理店舗の生産者の体験のみ登録可能です。
         * @summary 体験登録
         * @param {TypesCreateExperienceRequest} typesCreateExperienceRequest 体験情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperiencesPost(typesCreateExperienceRequest: TypesCreateExperienceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExperienceResponse> {
            return localVarFp.v1ExperiencesPost(typesCreateExperienceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperienceApi - object-oriented interface
 * @export
 * @class ExperienceApi
 * @extends {BaseAPI}
 */
export class ExperienceApi extends BaseAPI {
    /**
     * 体験を削除します。
     * @summary 体験削除
     * @param {string} experienceId 体験ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1ExperiencesExperienceIdDelete(experienceId: string, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1ExperiencesExperienceIdDelete(experienceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された体験の詳細情報を取得します。
     * @summary 体験取得
     * @param {string} experienceId 体験ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1ExperiencesExperienceIdGet(experienceId: string, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1ExperiencesExperienceIdGet(experienceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験の情報を更新します。
     * @summary 体験更新
     * @param {string} experienceId 体験ID
     * @param {TypesUpdateExperienceRequest} typesUpdateExperienceRequest 体験情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1ExperiencesExperienceIdPatch(experienceId: string, typesUpdateExperienceRequest: TypesUpdateExperienceRequest, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1ExperiencesExperienceIdPatch(experienceId, typesUpdateExperienceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験の一覧を取得します。店舗、生産者、名前でのフィルタリングが可能です。
     * @summary 体験一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 体験名(あいまい検索)
     * @param {string} [producerId] 生産者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1ExperiencesGet(limit?: number, offset?: number, name?: string, producerId?: string, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1ExperiencesGet(limit, offset, name, producerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい体験を登録します。コーディネーターは管理店舗の生産者の体験のみ登録可能です。
     * @summary 体験登録
     * @param {TypesCreateExperienceRequest} typesCreateExperienceRequest 体験情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceApi
     */
    public v1ExperiencesPost(typesCreateExperienceRequest: TypesCreateExperienceRequest, options?: RawAxiosRequestConfig) {
        return ExperienceApiFp(this.configuration).v1ExperiencesPost(typesCreateExperienceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExperienceTypeApi - axios parameter creator
 * @export
 */
export const ExperienceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 体験タイプを削除します。
         * @summary 体験タイプ削除
         * @param {string} experienceTypeId 体験タイプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesExperienceTypeIdDelete: async (experienceTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTypeId' is not null or undefined
            assertParamExists('v1ExperienceTypesExperienceTypeIdDelete', 'experienceTypeId', experienceTypeId)
            const localVarPath = `/v1/experience-types/{experienceTypeId}`
                .replace(`{${"experienceTypeId"}}`, encodeURIComponent(String(experienceTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験タイプの情報を更新します。
         * @summary 体験タイプ更新
         * @param {string} experienceTypeId 体験タイプID
         * @param {TypesUpdateExperienceTypeRequest} typesUpdateExperienceTypeRequest 体験タイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesExperienceTypeIdPatch: async (experienceTypeId: string, typesUpdateExperienceTypeRequest: TypesUpdateExperienceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceTypeId' is not null or undefined
            assertParamExists('v1ExperienceTypesExperienceTypeIdPatch', 'experienceTypeId', experienceTypeId)
            // verify required parameter 'typesUpdateExperienceTypeRequest' is not null or undefined
            assertParamExists('v1ExperienceTypesExperienceTypeIdPatch', 'typesUpdateExperienceTypeRequest', typesUpdateExperienceTypeRequest)
            const localVarPath = `/v1/experience-types/{experienceTypeId}`
                .replace(`{${"experienceTypeId"}}`, encodeURIComponent(String(experienceTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateExperienceTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験タイプの一覧を取得します。名前でのフィルタリングが可能です。
         * @summary 体験タイプ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 体験タイプ名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesGet: async (limit?: number, offset?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/experience-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい体験タイプを登録します。
         * @summary 体験タイプ登録
         * @param {TypesCreateExperienceTypeRequest} typesCreateExperienceTypeRequest 体験タイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesPost: async (typesCreateExperienceTypeRequest: TypesCreateExperienceTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateExperienceTypeRequest' is not null or undefined
            assertParamExists('v1ExperienceTypesPost', 'typesCreateExperienceTypeRequest', typesCreateExperienceTypeRequest)
            const localVarPath = `/v1/experience-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateExperienceTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperienceTypeApi - functional programming interface
 * @export
 */
export const ExperienceTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExperienceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 体験タイプを削除します。
         * @summary 体験タイプ削除
         * @param {string} experienceTypeId 体験タイプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperienceTypesExperienceTypeIdDelete(experienceTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperienceTypesExperienceTypeIdDelete(experienceTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1ExperienceTypesExperienceTypeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験タイプの情報を更新します。
         * @summary 体験タイプ更新
         * @param {string} experienceTypeId 体験タイプID
         * @param {TypesUpdateExperienceTypeRequest} typesUpdateExperienceTypeRequest 体験タイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperienceTypesExperienceTypeIdPatch(experienceTypeId: string, typesUpdateExperienceTypeRequest: TypesUpdateExperienceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperienceTypesExperienceTypeIdPatch(experienceTypeId, typesUpdateExperienceTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1ExperienceTypesExperienceTypeIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験タイプの一覧を取得します。名前でのフィルタリングが可能です。
         * @summary 体験タイプ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 体験タイプ名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperienceTypesGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesExperienceTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperienceTypesGet(limit, offset, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1ExperienceTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい体験タイプを登録します。
         * @summary 体験タイプ登録
         * @param {TypesCreateExperienceTypeRequest} typesCreateExperienceTypeRequest 体験タイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ExperienceTypesPost(typesCreateExperienceTypeRequest: TypesCreateExperienceTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesExperienceTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ExperienceTypesPost(typesCreateExperienceTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExperienceTypeApi.v1ExperienceTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExperienceTypeApi - factory interface
 * @export
 */
export const ExperienceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExperienceTypeApiFp(configuration)
    return {
        /**
         * 体験タイプを削除します。
         * @summary 体験タイプ削除
         * @param {string} experienceTypeId 体験タイプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesExperienceTypeIdDelete(experienceTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ExperienceTypesExperienceTypeIdDelete(experienceTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験タイプの情報を更新します。
         * @summary 体験タイプ更新
         * @param {string} experienceTypeId 体験タイプID
         * @param {TypesUpdateExperienceTypeRequest} typesUpdateExperienceTypeRequest 体験タイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesExperienceTypeIdPatch(experienceTypeId: string, typesUpdateExperienceTypeRequest: TypesUpdateExperienceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ExperienceTypesExperienceTypeIdPatch(experienceTypeId, typesUpdateExperienceTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験タイプの一覧を取得します。名前でのフィルタリングが可能です。
         * @summary 体験タイプ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 体験タイプ名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesExperienceTypesResponse> {
            return localVarFp.v1ExperienceTypesGet(limit, offset, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい体験タイプを登録します。
         * @summary 体験タイプ登録
         * @param {TypesCreateExperienceTypeRequest} typesCreateExperienceTypeRequest 体験タイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ExperienceTypesPost(typesCreateExperienceTypeRequest: TypesCreateExperienceTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesExperienceTypeResponse> {
            return localVarFp.v1ExperienceTypesPost(typesCreateExperienceTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExperienceTypeApi - object-oriented interface
 * @export
 * @class ExperienceTypeApi
 * @extends {BaseAPI}
 */
export class ExperienceTypeApi extends BaseAPI {
    /**
     * 体験タイプを削除します。
     * @summary 体験タイプ削除
     * @param {string} experienceTypeId 体験タイプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1ExperienceTypesExperienceTypeIdDelete(experienceTypeId: string, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1ExperienceTypesExperienceTypeIdDelete(experienceTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験タイプの情報を更新します。
     * @summary 体験タイプ更新
     * @param {string} experienceTypeId 体験タイプID
     * @param {TypesUpdateExperienceTypeRequest} typesUpdateExperienceTypeRequest 体験タイプ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1ExperienceTypesExperienceTypeIdPatch(experienceTypeId: string, typesUpdateExperienceTypeRequest: TypesUpdateExperienceTypeRequest, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1ExperienceTypesExperienceTypeIdPatch(experienceTypeId, typesUpdateExperienceTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験タイプの一覧を取得します。名前でのフィルタリングが可能です。
     * @summary 体験タイプ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 体験タイプ名(あいまい検索)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1ExperienceTypesGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1ExperienceTypesGet(limit, offset, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい体験タイプを登録します。
     * @summary 体験タイプ登録
     * @param {TypesCreateExperienceTypeRequest} typesCreateExperienceTypeRequest 体験タイプ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperienceTypeApi
     */
    public v1ExperienceTypesPost(typesCreateExperienceTypeRequest: TypesCreateExperienceTypeRequest, options?: RawAxiosRequestConfig) {
        return ExperienceTypeApiFp(this.configuration).v1ExperienceTypesPost(typesCreateExperienceTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GuestApi - axios parameter creator
 * @export
 */
export const GuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/guests/schedules/-/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieauth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Youtube認証完了後のコールバック処理を行います。
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost: async (typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCallbackAuthYoutubeBroadcastRequest' is not null or undefined
            assertParamExists('v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost', 'typesCallbackAuthYoutubeBroadcastRequest', typesCallbackAuthYoutubeBroadcastRequest)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube/auth/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCallbackAuthYoutubeBroadcastRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Youtube側でライブ配信を作成します。
         * @summary マルシェライブ配信のYoutube連携
         * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubePost: async (typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateYoutubeBroadcastRequest' is not null or undefined
            assertParamExists('v1GuestsSchedulesBroadcastsYoutubePost', 'typesCreateYoutubeBroadcastRequest', typesCreateYoutubeBroadcastRequest)
            const localVarPath = `/v1/guests/schedules/-/broadcasts/youtube`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieauth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateYoutubeBroadcastRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestApi - functional programming interface
 * @export
 */
export const GuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestApiAxiosParamCreator(configuration)
    return {
        /**
         * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestsSchedulesBroadcastsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesGuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestsSchedulesBroadcastsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.v1GuestsSchedulesBroadcastsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Youtube認証完了後のコールバック処理を行います。
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesGuestBroadcastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Youtube側でライブ配信を作成します。
         * @summary マルシェライブ配信のYoutube連携
         * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.v1GuestsSchedulesBroadcastsYoutubePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuestApi - factory interface
 * @export
 */
export const GuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestApiFp(configuration)
    return {
        /**
         * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
         * @summary ゲスト用ライブ配信情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsGet(options?: RawAxiosRequestConfig): AxiosPromise<TypesGuestBroadcastResponse> {
            return localVarFp.v1GuestsSchedulesBroadcastsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Youtube認証完了後のコールバック処理を行います。
         * @summary マルシェライブ配信のYoutube認証後処理
         * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesGuestBroadcastResponse> {
            return localVarFp.v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Youtube側でライブ配信を作成します。
         * @summary マルシェライブ配信のYoutube連携
         * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestApi - object-oriented interface
 * @export
 * @class GuestApi
 * @extends {BaseAPI}
 */
export class GuestApi extends BaseAPI {
    /**
     * セッションIDを使用してゲスト向けのライブ配信情報を取得します。
     * @summary ゲスト用ライブ配信情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public v1GuestsSchedulesBroadcastsGet(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).v1GuestsSchedulesBroadcastsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Youtube認証完了後のコールバック処理を行います。
     * @summary マルシェライブ配信のYoutube認証後処理
     * @param {TypesCallbackAuthYoutubeBroadcastRequest} typesCallbackAuthYoutubeBroadcastRequest 認証コールバック
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest: TypesCallbackAuthYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).v1GuestsSchedulesBroadcastsYoutubeAuthCompletePost(typesCallbackAuthYoutubeBroadcastRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Youtube側でライブ配信を作成します。
     * @summary マルシェライブ配信のYoutube連携
     * @param {TypesCreateYoutubeBroadcastRequest} typesCreateYoutubeBroadcastRequest Youtube配信設定
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest: TypesCreateYoutubeBroadcastRequest, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).v1GuestsSchedulesBroadcastsYoutubePost(typesCreateYoutubeBroadcastRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LiveApi - axios parameter creator
 * @export
 */
export const LiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたスケジュールのライブ配信一覧を取得します。
         * @summary ライブ配信一覧取得
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesGet: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/lives`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信を削除します。
         * @summary ライブ配信削除
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesLiveIdDelete: async (scheduleId: string, liveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdDelete', 'scheduleId', scheduleId)
            // verify required parameter 'liveId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdDelete', 'liveId', liveId)
            const localVarPath = `/v1/schedules/{scheduleId}/lives/{liveId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"liveId"}}`, encodeURIComponent(String(liveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたライブ配信の詳細情報を取得します。
         * @summary ライブ配信取得
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesLiveIdGet: async (scheduleId: string, liveId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdGet', 'scheduleId', scheduleId)
            // verify required parameter 'liveId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdGet', 'liveId', liveId)
            const localVarPath = `/v1/schedules/{scheduleId}/lives/{liveId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"liveId"}}`, encodeURIComponent(String(liveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信の情報を更新します。
         * @summary ライブ配信更新
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {TypesUpdateLiveRequest} typesUpdateLiveRequest ライブ配信情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesLiveIdPatch: async (scheduleId: string, liveId: string, typesUpdateLiveRequest: TypesUpdateLiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdPatch', 'scheduleId', scheduleId)
            // verify required parameter 'liveId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdPatch', 'liveId', liveId)
            // verify required parameter 'typesUpdateLiveRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesLiveIdPatch', 'typesUpdateLiveRequest', typesUpdateLiveRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/lives/{liveId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"liveId"}}`, encodeURIComponent(String(liveId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateLiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいライブ配信を登録します。
         * @summary ライブ配信登録
         * @param {string} scheduleId スケジュールID
         * @param {TypesCreateLiveRequest} typesCreateLiveRequest ライブ配信情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesPost: async (scheduleId: string, typesCreateLiveRequest: TypesCreateLiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesPost', 'scheduleId', scheduleId)
            // verify required parameter 'typesCreateLiveRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdLivesPost', 'typesCreateLiveRequest', typesCreateLiveRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/lives`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateLiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveApi - functional programming interface
 * @export
 */
export const LiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたスケジュールのライブ配信一覧を取得します。
         * @summary ライブ配信一覧取得
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdLivesGet(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesLivesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdLivesGet(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1SchedulesScheduleIdLivesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信を削除します。
         * @summary ライブ配信削除
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdLivesLiveIdDelete(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdLivesLiveIdDelete(scheduleId, liveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1SchedulesScheduleIdLivesLiveIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたライブ配信の詳細情報を取得します。
         * @summary ライブ配信取得
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdLivesLiveIdGet(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesLiveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdLivesLiveIdGet(scheduleId, liveId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1SchedulesScheduleIdLivesLiveIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信の情報を更新します。
         * @summary ライブ配信更新
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {TypesUpdateLiveRequest} typesUpdateLiveRequest ライブ配信情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdLivesLiveIdPatch(scheduleId: string, liveId: string, typesUpdateLiveRequest: TypesUpdateLiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdLivesLiveIdPatch(scheduleId, liveId, typesUpdateLiveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1SchedulesScheduleIdLivesLiveIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいライブ配信を登録します。
         * @summary ライブ配信登録
         * @param {string} scheduleId スケジュールID
         * @param {TypesCreateLiveRequest} typesCreateLiveRequest ライブ配信情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdLivesPost(scheduleId: string, typesCreateLiveRequest: TypesCreateLiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesLiveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdLivesPost(scheduleId, typesCreateLiveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.v1SchedulesScheduleIdLivesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveApi - factory interface
 * @export
 */
export const LiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveApiFp(configuration)
    return {
        /**
         * 指定されたスケジュールのライブ配信一覧を取得します。
         * @summary ライブ配信一覧取得
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesGet(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesLivesResponse> {
            return localVarFp.v1SchedulesScheduleIdLivesGet(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信を削除します。
         * @summary ライブ配信削除
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesLiveIdDelete(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdLivesLiveIdDelete(scheduleId, liveId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたライブ配信の詳細情報を取得します。
         * @summary ライブ配信取得
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesLiveIdGet(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesLiveResponse> {
            return localVarFp.v1SchedulesScheduleIdLivesLiveIdGet(scheduleId, liveId, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信の情報を更新します。
         * @summary ライブ配信更新
         * @param {string} scheduleId スケジュールID
         * @param {string} liveId ライブ配信ID
         * @param {TypesUpdateLiveRequest} typesUpdateLiveRequest ライブ配信情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesLiveIdPatch(scheduleId: string, liveId: string, typesUpdateLiveRequest: TypesUpdateLiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdLivesLiveIdPatch(scheduleId, liveId, typesUpdateLiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいライブ配信を登録します。
         * @summary ライブ配信登録
         * @param {string} scheduleId スケジュールID
         * @param {TypesCreateLiveRequest} typesCreateLiveRequest ライブ配信情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdLivesPost(scheduleId: string, typesCreateLiveRequest: TypesCreateLiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesLiveResponse> {
            return localVarFp.v1SchedulesScheduleIdLivesPost(scheduleId, typesCreateLiveRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveApi - object-oriented interface
 * @export
 * @class LiveApi
 * @extends {BaseAPI}
 */
export class LiveApi extends BaseAPI {
    /**
     * 指定されたスケジュールのライブ配信一覧を取得します。
     * @summary ライブ配信一覧取得
     * @param {string} scheduleId スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1SchedulesScheduleIdLivesGet(scheduleId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1SchedulesScheduleIdLivesGet(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信を削除します。
     * @summary ライブ配信削除
     * @param {string} scheduleId スケジュールID
     * @param {string} liveId ライブ配信ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1SchedulesScheduleIdLivesLiveIdDelete(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1SchedulesScheduleIdLivesLiveIdDelete(scheduleId, liveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたライブ配信の詳細情報を取得します。
     * @summary ライブ配信取得
     * @param {string} scheduleId スケジュールID
     * @param {string} liveId ライブ配信ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1SchedulesScheduleIdLivesLiveIdGet(scheduleId: string, liveId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1SchedulesScheduleIdLivesLiveIdGet(scheduleId, liveId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信の情報を更新します。
     * @summary ライブ配信更新
     * @param {string} scheduleId スケジュールID
     * @param {string} liveId ライブ配信ID
     * @param {TypesUpdateLiveRequest} typesUpdateLiveRequest ライブ配信情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1SchedulesScheduleIdLivesLiveIdPatch(scheduleId: string, liveId: string, typesUpdateLiveRequest: TypesUpdateLiveRequest, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1SchedulesScheduleIdLivesLiveIdPatch(scheduleId, liveId, typesUpdateLiveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいライブ配信を登録します。
     * @summary ライブ配信登録
     * @param {string} scheduleId スケジュールID
     * @param {TypesCreateLiveRequest} typesCreateLiveRequest ライブ配信情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveApi
     */
    public v1SchedulesScheduleIdLivesPost(scheduleId: string, typesCreateLiveRequest: TypesCreateLiveRequest, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).v1SchedulesScheduleIdLivesPost(scheduleId, typesCreateLiveRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LiveCommentApi - axios parameter creator
 * @export
 */
export const LiveCommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ライブコメントの状態（無効/有効）を更新します。
         * @summary ライブコメント更新
         * @param {string} scheduleId スケジュールID
         * @param {string} commentId コメントID
         * @param {TypesUpdateLiveCommentRequest} typesUpdateLiveCommentRequest コメント情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdCommentsCommentIdPatch: async (scheduleId: string, commentId: string, typesUpdateLiveCommentRequest: TypesUpdateLiveCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdCommentsCommentIdPatch', 'scheduleId', scheduleId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdCommentsCommentIdPatch', 'commentId', commentId)
            // verify required parameter 'typesUpdateLiveCommentRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdCommentsCommentIdPatch', 'typesUpdateLiveCommentRequest', typesUpdateLiveCommentRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/comments/{commentId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateLiveCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたスケジュールのライブコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
         * @summary ライブコメント一覧取得
         * @param {string} scheduleId スケジュールID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [start] 検索開始日時（unixtime）
         * @param {number} [end] 検索終了日時（unixtime）
         * @param {string} [next] 次ページトークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdCommentsGet: async (scheduleId: string, limit?: number, start?: number, end?: number, next?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdCommentsGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/comments`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveCommentApi - functional programming interface
 * @export
 */
export const LiveCommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveCommentApiAxiosParamCreator(configuration)
    return {
        /**
         * ライブコメントの状態（無効/有効）を更新します。
         * @summary ライブコメント更新
         * @param {string} scheduleId スケジュールID
         * @param {string} commentId コメントID
         * @param {TypesUpdateLiveCommentRequest} typesUpdateLiveCommentRequest コメント情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdCommentsCommentIdPatch(scheduleId: string, commentId: string, typesUpdateLiveCommentRequest: TypesUpdateLiveCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdCommentsCommentIdPatch(scheduleId, commentId, typesUpdateLiveCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveCommentApi.v1SchedulesScheduleIdCommentsCommentIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたスケジュールのライブコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
         * @summary ライブコメント一覧取得
         * @param {string} scheduleId スケジュールID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [start] 検索開始日時（unixtime）
         * @param {number} [end] 検索終了日時（unixtime）
         * @param {string} [next] 次ページトークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdCommentsGet(scheduleId: string, limit?: number, start?: number, end?: number, next?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveCommentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdCommentsGet(scheduleId, limit, start, end, next, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveCommentApi.v1SchedulesScheduleIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveCommentApi - factory interface
 * @export
 */
export const LiveCommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveCommentApiFp(configuration)
    return {
        /**
         * ライブコメントの状態（無効/有効）を更新します。
         * @summary ライブコメント更新
         * @param {string} scheduleId スケジュールID
         * @param {string} commentId コメントID
         * @param {TypesUpdateLiveCommentRequest} typesUpdateLiveCommentRequest コメント情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdCommentsCommentIdPatch(scheduleId: string, commentId: string, typesUpdateLiveCommentRequest: TypesUpdateLiveCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdCommentsCommentIdPatch(scheduleId, commentId, typesUpdateLiveCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたスケジュールのライブコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
         * @summary ライブコメント一覧取得
         * @param {string} scheduleId スケジュールID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [start] 検索開始日時（unixtime）
         * @param {number} [end] 検索終了日時（unixtime）
         * @param {string} [next] 次ページトークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdCommentsGet(scheduleId: string, limit?: number, start?: number, end?: number, next?: string, options?: RawAxiosRequestConfig): AxiosPromise<LiveCommentsResponse> {
            return localVarFp.v1SchedulesScheduleIdCommentsGet(scheduleId, limit, start, end, next, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveCommentApi - object-oriented interface
 * @export
 * @class LiveCommentApi
 * @extends {BaseAPI}
 */
export class LiveCommentApi extends BaseAPI {
    /**
     * ライブコメントの状態（無効/有効）を更新します。
     * @summary ライブコメント更新
     * @param {string} scheduleId スケジュールID
     * @param {string} commentId コメントID
     * @param {TypesUpdateLiveCommentRequest} typesUpdateLiveCommentRequest コメント情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveCommentApi
     */
    public v1SchedulesScheduleIdCommentsCommentIdPatch(scheduleId: string, commentId: string, typesUpdateLiveCommentRequest: TypesUpdateLiveCommentRequest, options?: RawAxiosRequestConfig) {
        return LiveCommentApiFp(this.configuration).v1SchedulesScheduleIdCommentsCommentIdPatch(scheduleId, commentId, typesUpdateLiveCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたスケジュールのライブコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
     * @summary ライブコメント一覧取得
     * @param {string} scheduleId スケジュールID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [start] 検索開始日時（unixtime）
     * @param {number} [end] 検索終了日時（unixtime）
     * @param {string} [next] 次ページトークン
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveCommentApi
     */
    public v1SchedulesScheduleIdCommentsGet(scheduleId: string, limit?: number, start?: number, end?: number, next?: string, options?: RawAxiosRequestConfig) {
        return LiveCommentApiFp(this.configuration).v1SchedulesScheduleIdCommentsGet(scheduleId, limit, start, end, next, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 管理者あてのメッセージ一覧を取得します。ソート順指定が可能です。
         * @summary メッセージ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート(type,-type,read,-read,receivedAt,-receivedAt)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MessagesGet: async (limit?: number, offset?: number, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたメッセージの詳細情報を取得します。
         * @summary メッセージ取得
         * @param {string} messageId メッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MessagesMessageIdGet: async (messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('v1MessagesMessageIdGet', 'messageId', messageId)
            const localVarPath = `/v1/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * 管理者あてのメッセージ一覧を取得します。ソート順指定が可能です。
         * @summary メッセージ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート(type,-type,read,-read,receivedAt,-receivedAt)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MessagesGet(limit?: number, offset?: number, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MessagesGet(limit, offset, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.v1MessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたメッセージの詳細情報を取得します。
         * @summary メッセージ取得
         * @param {string} messageId メッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MessagesMessageIdGet(messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MessagesMessageIdGet(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageApi.v1MessagesMessageIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * 管理者あてのメッセージ一覧を取得します。ソート順指定が可能です。
         * @summary メッセージ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [orders] ソート(type,-type,read,-read,receivedAt,-receivedAt)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MessagesGet(limit?: number, offset?: number, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesMessagesResponse> {
            return localVarFp.v1MessagesGet(limit, offset, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたメッセージの詳細情報を取得します。
         * @summary メッセージ取得
         * @param {string} messageId メッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MessagesMessageIdGet(messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesMessageResponse> {
            return localVarFp.v1MessagesMessageIdGet(messageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * 管理者あてのメッセージ一覧を取得します。ソート順指定が可能です。
     * @summary メッセージ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [orders] ソート(type,-type,read,-read,receivedAt,-receivedAt)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public v1MessagesGet(limit?: number, offset?: number, orders?: string, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).v1MessagesGet(limit, offset, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたメッセージの詳細情報を取得します。
     * @summary メッセージ取得
     * @param {string} messageId メッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public v1MessagesMessageIdGet(messageId: string, options?: RawAxiosRequestConfig) {
        return MessageApiFp(this.configuration).v1MessagesMessageIdGet(messageId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 通知の一覧を取得します。期間や配信日時でのフィルタリング、ソート順指定が可能です。
         * @summary 通知一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {number} [since] 検索開始日時（unixtime）
         * @param {number} [until] 検索終了日時（unixtime）
         * @param {string} [orders] ソート(title,-title,publishedAt,-publishedAt)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsGet: async (limit?: number, offset?: number, since?: number, until?: number, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知を削除します。
         * @summary 通知削除
         * @param {string} notificationId 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsNotificationIdDelete: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('v1NotificationsNotificationIdDelete', 'notificationId', notificationId)
            const localVarPath = `/v1/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された通知の詳細情報を取得します。
         * @summary 通知取得
         * @param {string} notificationId 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsNotificationIdGet: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('v1NotificationsNotificationIdGet', 'notificationId', notificationId)
            const localVarPath = `/v1/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知の情報を更新します。
         * @summary 通知更新
         * @param {string} notificationId 通知ID
         * @param {TypesUpdateNotificationRequest} typesUpdateNotificationRequest 通知情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsNotificationIdPatch: async (notificationId: string, typesUpdateNotificationRequest: TypesUpdateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('v1NotificationsNotificationIdPatch', 'notificationId', notificationId)
            // verify required parameter 'typesUpdateNotificationRequest' is not null or undefined
            assertParamExists('v1NotificationsNotificationIdPatch', 'typesUpdateNotificationRequest', typesUpdateNotificationRequest)
            const localVarPath = `/v1/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい通知を登録します。配信対象、配信日時などを指定できます。
         * @summary 通知登録
         * @param {TypesCreateNotificationRequest} typesCreateNotificationRequest 通知情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsPost: async (typesCreateNotificationRequest: TypesCreateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateNotificationRequest' is not null or undefined
            assertParamExists('v1NotificationsPost', 'typesCreateNotificationRequest', typesCreateNotificationRequest)
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 通知の一覧を取得します。期間や配信日時でのフィルタリング、ソート順指定が可能です。
         * @summary 通知一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {number} [since] 検索開始日時（unixtime）
         * @param {number} [until] 検索終了日時（unixtime）
         * @param {string} [orders] ソート(title,-title,publishedAt,-publishedAt)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsGet(limit?: number, offset?: number, since?: number, until?: number, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesNotificationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsGet(limit, offset, since, until, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1NotificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 通知を削除します。
         * @summary 通知削除
         * @param {string} notificationId 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsNotificationIdDelete(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsNotificationIdDelete(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1NotificationsNotificationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された通知の詳細情報を取得します。
         * @summary 通知取得
         * @param {string} notificationId 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsNotificationIdGet(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesNotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsNotificationIdGet(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1NotificationsNotificationIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 通知の情報を更新します。
         * @summary 通知更新
         * @param {string} notificationId 通知ID
         * @param {TypesUpdateNotificationRequest} typesUpdateNotificationRequest 通知情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsNotificationIdPatch(notificationId: string, typesUpdateNotificationRequest: TypesUpdateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsNotificationIdPatch(notificationId, typesUpdateNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1NotificationsNotificationIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい通知を登録します。配信対象、配信日時などを指定できます。
         * @summary 通知登録
         * @param {TypesCreateNotificationRequest} typesCreateNotificationRequest 通知情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsPost(typesCreateNotificationRequest: TypesCreateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesNotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsPost(typesCreateNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.v1NotificationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 通知の一覧を取得します。期間や配信日時でのフィルタリング、ソート順指定が可能です。
         * @summary 通知一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {number} [since] 検索開始日時（unixtime）
         * @param {number} [until] 検索終了日時（unixtime）
         * @param {string} [orders] ソート(title,-title,publishedAt,-publishedAt)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsGet(limit?: number, offset?: number, since?: number, until?: number, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesNotificationsResponse> {
            return localVarFp.v1NotificationsGet(limit, offset, since, until, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 通知を削除します。
         * @summary 通知削除
         * @param {string} notificationId 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsNotificationIdDelete(notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotificationsNotificationIdDelete(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された通知の詳細情報を取得します。
         * @summary 通知取得
         * @param {string} notificationId 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsNotificationIdGet(notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesNotificationResponse> {
            return localVarFp.v1NotificationsNotificationIdGet(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 通知の情報を更新します。
         * @summary 通知更新
         * @param {string} notificationId 通知ID
         * @param {TypesUpdateNotificationRequest} typesUpdateNotificationRequest 通知情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsNotificationIdPatch(notificationId: string, typesUpdateNotificationRequest: TypesUpdateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1NotificationsNotificationIdPatch(notificationId, typesUpdateNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい通知を登録します。配信対象、配信日時などを指定できます。
         * @summary 通知登録
         * @param {TypesCreateNotificationRequest} typesCreateNotificationRequest 通知情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsPost(typesCreateNotificationRequest: TypesCreateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesNotificationResponse> {
            return localVarFp.v1NotificationsPost(typesCreateNotificationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 通知の一覧を取得します。期間や配信日時でのフィルタリング、ソート順指定が可能です。
     * @summary 通知一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {number} [since] 検索開始日時（unixtime）
     * @param {number} [until] 検索終了日時（unixtime）
     * @param {string} [orders] ソート(title,-title,publishedAt,-publishedAt)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1NotificationsGet(limit?: number, offset?: number, since?: number, until?: number, orders?: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1NotificationsGet(limit, offset, since, until, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 通知を削除します。
     * @summary 通知削除
     * @param {string} notificationId 通知ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1NotificationsNotificationIdDelete(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1NotificationsNotificationIdDelete(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された通知の詳細情報を取得します。
     * @summary 通知取得
     * @param {string} notificationId 通知ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1NotificationsNotificationIdGet(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1NotificationsNotificationIdGet(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 通知の情報を更新します。
     * @summary 通知更新
     * @param {string} notificationId 通知ID
     * @param {TypesUpdateNotificationRequest} typesUpdateNotificationRequest 通知情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1NotificationsNotificationIdPatch(notificationId: string, typesUpdateNotificationRequest: TypesUpdateNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1NotificationsNotificationIdPatch(notificationId, typesUpdateNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい通知を登録します。配信対象、配信日時などを指定できます。
     * @summary 通知登録
     * @param {TypesCreateNotificationRequest} typesCreateNotificationRequest 通知情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public v1NotificationsPost(typesCreateNotificationRequest: TypesCreateNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).v1NotificationsPost(typesCreateNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 注文履歴をCSV形式で出力します。
         * @summary 注文履歴のCSV出力
         * @param {TypesExportOrdersRequest} typesExportOrdersRequest 注文履歴のCSV出力
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersExportPost: async (typesExportOrdersRequest: TypesExportOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesExportOrdersRequest' is not null or undefined
            assertParamExists('v1OrdersExportPost', 'typesExportOrdersRequest', typesExportOrdersRequest)
            const localVarPath = `/v1/orders/-/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesExportOrdersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注文の一覧を取得します。コーディネータは自分の店舗の注文のみ取得できます。
         * @summary 注文一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {Array<number>} [statuses] 注文ステータスフィルタ
         * @param {Array<number>} [types] 注文タイプフィルタ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersGet: async (limit?: number, offset?: number, statuses?: Array<number>, types?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注文をキャンセルします。
         * @summary 注文キャンセル
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdCancelPost: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersOrderIdCancelPost', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}/cancel`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注文を確定します。
         * @summary 注文確定
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdCapturePost: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersOrderIdCapturePost', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}/capture`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注文対応を完了します。
         * @summary 注文対応完了
         * @param {string} orderId 注文ID
         * @param {TypesCompleteOrderRequest} typesCompleteOrderRequest 注文対応完了
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdCompletePost: async (orderId: string, typesCompleteOrderRequest: TypesCompleteOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersOrderIdCompletePost', 'orderId', orderId)
            // verify required parameter 'typesCompleteOrderRequest' is not null or undefined
            assertParamExists('v1OrdersOrderIdCompletePost', 'typesCompleteOrderRequest', typesCompleteOrderRequest)
            const localVarPath = `/v1/orders/{orderId}/complete`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCompleteOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注文の下書きを保存します。
         * @summary 注文下書き保存
         * @param {string} orderId 注文ID
         * @param {TypesDraftOrderRequest} typesDraftOrderRequest 注文下書き保存
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdDraftPost: async (orderId: string, typesDraftOrderRequest: TypesDraftOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersOrderIdDraftPost', 'orderId', orderId)
            // verify required parameter 'typesDraftOrderRequest' is not null or undefined
            assertParamExists('v1OrdersOrderIdDraftPost', 'typesDraftOrderRequest', typesDraftOrderRequest)
            const localVarPath = `/v1/orders/{orderId}/draft`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesDraftOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された注文の詳細情報を取得します。
         * @summary 注文取得
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdGet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersOrderIdGet', 'orderId', orderId)
            const localVarPath = `/v1/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注文の返金を依頼します。
         * @summary 注文の返金依頼
         * @param {string} orderId 注文ID
         * @param {TypesRefundOrderRequest} typesRefundOrderRequest 注文の返金依頼
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdRefundPost: async (orderId: string, typesRefundOrderRequest: TypesRefundOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersOrderIdRefundPost', 'orderId', orderId)
            // verify required parameter 'typesRefundOrderRequest' is not null or undefined
            assertParamExists('v1OrdersOrderIdRefundPost', 'typesRefundOrderRequest', typesRefundOrderRequest)
            const localVarPath = `/v1/orders/{orderId}/refund`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesRefundOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 注文履歴をCSV形式で出力します。
         * @summary 注文履歴のCSV出力
         * @param {TypesExportOrdersRequest} typesExportOrdersRequest 注文履歴のCSV出力
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersExportPost(typesExportOrdersRequest: TypesExportOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersExportPost(typesExportOrdersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersExportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注文の一覧を取得します。コーディネータは自分の店舗の注文のみ取得できます。
         * @summary 注文一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {Array<number>} [statuses] 注文ステータスフィルタ
         * @param {Array<number>} [types] 注文タイプフィルタ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersGet(limit?: number, offset?: number, statuses?: Array<number>, types?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersGet(limit, offset, statuses, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注文をキャンセルします。
         * @summary 注文キャンセル
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersOrderIdCancelPost(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersOrderIdCancelPost(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersOrderIdCancelPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注文を確定します。
         * @summary 注文確定
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersOrderIdCapturePost(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersOrderIdCapturePost(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersOrderIdCapturePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注文対応を完了します。
         * @summary 注文対応完了
         * @param {string} orderId 注文ID
         * @param {TypesCompleteOrderRequest} typesCompleteOrderRequest 注文対応完了
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersOrderIdCompletePost(orderId: string, typesCompleteOrderRequest: TypesCompleteOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersOrderIdCompletePost(orderId, typesCompleteOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersOrderIdCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注文の下書きを保存します。
         * @summary 注文下書き保存
         * @param {string} orderId 注文ID
         * @param {TypesDraftOrderRequest} typesDraftOrderRequest 注文下書き保存
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersOrderIdDraftPost(orderId: string, typesDraftOrderRequest: TypesDraftOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersOrderIdDraftPost(orderId, typesDraftOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersOrderIdDraftPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された注文の詳細情報を取得します。
         * @summary 注文取得
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersOrderIdGet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersOrderIdGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersOrderIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 注文の返金を依頼します。
         * @summary 注文の返金依頼
         * @param {string} orderId 注文ID
         * @param {TypesRefundOrderRequest} typesRefundOrderRequest 注文の返金依頼
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersOrderIdRefundPost(orderId: string, typesRefundOrderRequest: TypesRefundOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersOrderIdRefundPost(orderId, typesRefundOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.v1OrdersOrderIdRefundPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 注文履歴をCSV形式で出力します。
         * @summary 注文履歴のCSV出力
         * @param {TypesExportOrdersRequest} typesExportOrdersRequest 注文履歴のCSV出力
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersExportPost(typesExportOrdersRequest: TypesExportOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrdersExportPost(typesExportOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 注文の一覧を取得します。コーディネータは自分の店舗の注文のみ取得できます。
         * @summary 注文一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {Array<number>} [statuses] 注文ステータスフィルタ
         * @param {Array<number>} [types] 注文タイプフィルタ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersGet(limit?: number, offset?: number, statuses?: Array<number>, types?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<OrdersResponse> {
            return localVarFp.v1OrdersGet(limit, offset, statuses, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 注文をキャンセルします。
         * @summary 注文キャンセル
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdCancelPost(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrdersOrderIdCancelPost(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 注文を確定します。
         * @summary 注文確定
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdCapturePost(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrdersOrderIdCapturePost(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 注文対応を完了します。
         * @summary 注文対応完了
         * @param {string} orderId 注文ID
         * @param {TypesCompleteOrderRequest} typesCompleteOrderRequest 注文対応完了
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdCompletePost(orderId: string, typesCompleteOrderRequest: TypesCompleteOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrdersOrderIdCompletePost(orderId, typesCompleteOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 注文の下書きを保存します。
         * @summary 注文下書き保存
         * @param {string} orderId 注文ID
         * @param {TypesDraftOrderRequest} typesDraftOrderRequest 注文下書き保存
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdDraftPost(orderId: string, typesDraftOrderRequest: TypesDraftOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrdersOrderIdDraftPost(orderId, typesDraftOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された注文の詳細情報を取得します。
         * @summary 注文取得
         * @param {string} orderId 注文ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdGet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.v1OrdersOrderIdGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 注文の返金を依頼します。
         * @summary 注文の返金依頼
         * @param {string} orderId 注文ID
         * @param {TypesRefundOrderRequest} typesRefundOrderRequest 注文の返金依頼
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersOrderIdRefundPost(orderId: string, typesRefundOrderRequest: TypesRefundOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrdersOrderIdRefundPost(orderId, typesRefundOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 注文履歴をCSV形式で出力します。
     * @summary 注文履歴のCSV出力
     * @param {TypesExportOrdersRequest} typesExportOrdersRequest 注文履歴のCSV出力
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersExportPost(typesExportOrdersRequest: TypesExportOrdersRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersExportPost(typesExportOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注文の一覧を取得します。コーディネータは自分の店舗の注文のみ取得できます。
     * @summary 注文一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {Array<number>} [statuses] 注文ステータスフィルタ
     * @param {Array<number>} [types] 注文タイプフィルタ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersGet(limit?: number, offset?: number, statuses?: Array<number>, types?: Array<number>, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersGet(limit, offset, statuses, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注文をキャンセルします。
     * @summary 注文キャンセル
     * @param {string} orderId 注文ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersOrderIdCancelPost(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersOrderIdCancelPost(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注文を確定します。
     * @summary 注文確定
     * @param {string} orderId 注文ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersOrderIdCapturePost(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersOrderIdCapturePost(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注文対応を完了します。
     * @summary 注文対応完了
     * @param {string} orderId 注文ID
     * @param {TypesCompleteOrderRequest} typesCompleteOrderRequest 注文対応完了
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersOrderIdCompletePost(orderId: string, typesCompleteOrderRequest: TypesCompleteOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersOrderIdCompletePost(orderId, typesCompleteOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注文の下書きを保存します。
     * @summary 注文下書き保存
     * @param {string} orderId 注文ID
     * @param {TypesDraftOrderRequest} typesDraftOrderRequest 注文下書き保存
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersOrderIdDraftPost(orderId: string, typesDraftOrderRequest: TypesDraftOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersOrderIdDraftPost(orderId, typesDraftOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された注文の詳細情報を取得します。
     * @summary 注文取得
     * @param {string} orderId 注文ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersOrderIdGet(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersOrderIdGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 注文の返金を依頼します。
     * @summary 注文の返金依頼
     * @param {string} orderId 注文ID
     * @param {TypesRefundOrderRequest} typesRefundOrderRequest 注文の返金依頼
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public v1OrdersOrderIdRefundPost(orderId: string, typesRefundOrderRequest: TypesRefundOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).v1OrdersOrderIdRefundPost(orderId, typesRefundOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentSystemApi - axios parameter creator
 * @export
 */
export const PaymentSystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 決済手段毎のシステム状態一覧を取得します。
         * @summary 決済システム一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentSystemsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment-systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された決済手段のシステム状態を更新します。
         * @summary 決済システム更新
         * @param {number} methodType 決済手段タイプ
         * @param {TypesUpdatePaymentSystemRequest} typesUpdatePaymentSystemRequest 決済システム情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentSystemsMethodTypePatch: async (methodType: number, typesUpdatePaymentSystemRequest: TypesUpdatePaymentSystemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'methodType' is not null or undefined
            assertParamExists('v1PaymentSystemsMethodTypePatch', 'methodType', methodType)
            // verify required parameter 'typesUpdatePaymentSystemRequest' is not null or undefined
            assertParamExists('v1PaymentSystemsMethodTypePatch', 'typesUpdatePaymentSystemRequest', typesUpdatePaymentSystemRequest)
            const localVarPath = `/v1/payment-systems/{methodType}`
                .replace(`{${"methodType"}}`, encodeURIComponent(String(methodType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdatePaymentSystemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSystemApi - functional programming interface
 * @export
 */
export const PaymentSystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 決済手段毎のシステム状態一覧を取得します。
         * @summary 決済システム一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentSystemsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSystemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentSystemsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSystemApi.v1PaymentSystemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された決済手段のシステム状態を更新します。
         * @summary 決済システム更新
         * @param {number} methodType 決済手段タイプ
         * @param {TypesUpdatePaymentSystemRequest} typesUpdatePaymentSystemRequest 決済システム情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentSystemsMethodTypePatch(methodType: number, typesUpdatePaymentSystemRequest: TypesUpdatePaymentSystemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentSystemsMethodTypePatch(methodType, typesUpdatePaymentSystemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSystemApi.v1PaymentSystemsMethodTypePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentSystemApi - factory interface
 * @export
 */
export const PaymentSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSystemApiFp(configuration)
    return {
        /**
         * 決済手段毎のシステム状態一覧を取得します。
         * @summary 決済システム一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentSystemsGet(options?: RawAxiosRequestConfig): AxiosPromise<PaymentSystemsResponse> {
            return localVarFp.v1PaymentSystemsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された決済手段のシステム状態を更新します。
         * @summary 決済システム更新
         * @param {number} methodType 決済手段タイプ
         * @param {TypesUpdatePaymentSystemRequest} typesUpdatePaymentSystemRequest 決済システム情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentSystemsMethodTypePatch(methodType: number, typesUpdatePaymentSystemRequest: TypesUpdatePaymentSystemRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1PaymentSystemsMethodTypePatch(methodType, typesUpdatePaymentSystemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentSystemApi - object-oriented interface
 * @export
 * @class PaymentSystemApi
 * @extends {BaseAPI}
 */
export class PaymentSystemApi extends BaseAPI {
    /**
     * 決済手段毎のシステム状態一覧を取得します。
     * @summary 決済システム一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public v1PaymentSystemsGet(options?: RawAxiosRequestConfig) {
        return PaymentSystemApiFp(this.configuration).v1PaymentSystemsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された決済手段のシステム状態を更新します。
     * @summary 決済システム更新
     * @param {number} methodType 決済手段タイプ
     * @param {TypesUpdatePaymentSystemRequest} typesUpdatePaymentSystemRequest 決済システム情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public v1PaymentSystemsMethodTypePatch(methodType: number, typesUpdatePaymentSystemRequest: TypesUpdatePaymentSystemRequest, options?: RawAxiosRequestConfig) {
        return PaymentSystemApiFp(this.configuration).v1PaymentSystemsMethodTypePatch(methodType, typesUpdatePaymentSystemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostalCodeApi - axios parameter creator
 * @export
 */
export const PostalCodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定された郵便番号から住所情報を検索します。
         * @summary 郵便番号検索
         * @param {string} postalCode 郵便番号
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PostalCodesPostalCodeGet: async (postalCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postalCode' is not null or undefined
            assertParamExists('v1PostalCodesPostalCodeGet', 'postalCode', postalCode)
            const localVarPath = `/v1/postal-codes/{postalCode}`
                .replace(`{${"postalCode"}}`, encodeURIComponent(String(postalCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostalCodeApi - functional programming interface
 * @export
 */
export const PostalCodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostalCodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定された郵便番号から住所情報を検索します。
         * @summary 郵便番号検索
         * @param {string} postalCode 郵便番号
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PostalCodesPostalCodeGet(postalCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostalCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PostalCodesPostalCodeGet(postalCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostalCodeApi.v1PostalCodesPostalCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostalCodeApi - factory interface
 * @export
 */
export const PostalCodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostalCodeApiFp(configuration)
    return {
        /**
         * 指定された郵便番号から住所情報を検索します。
         * @summary 郵便番号検索
         * @param {string} postalCode 郵便番号
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PostalCodesPostalCodeGet(postalCode: string, options?: RawAxiosRequestConfig): AxiosPromise<PostalCodeResponse> {
            return localVarFp.v1PostalCodesPostalCodeGet(postalCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostalCodeApi - object-oriented interface
 * @export
 * @class PostalCodeApi
 * @extends {BaseAPI}
 */
export class PostalCodeApi extends BaseAPI {
    /**
     * 指定された郵便番号から住所情報を検索します。
     * @summary 郵便番号検索
     * @param {string} postalCode 郵便番号
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostalCodeApi
     */
    public v1PostalCodesPostalCodeGet(postalCode: string, options?: RawAxiosRequestConfig) {
        return PostalCodeApiFp(this.configuration).v1PostalCodesPostalCodeGet(postalCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProducerApi - axios parameter creator
 * @export
 */
export const ProducerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 生産者の一覧を取得します。コーディネーターは管理店舗の生産者のみ取得可能です。
         * @summary 生産者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] 生産者名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersGet: async (limit?: number, offset?: number, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/producers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい生産者を登録します。コーディネーターは自身が管理する店舗の生産者のみ登録可能です。
         * @summary 生産者登録
         * @param {TypesCreateProducerRequest} typesCreateProducerRequest 生産者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersPost: async (typesCreateProducerRequest: TypesCreateProducerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateProducerRequest' is not null or undefined
            assertParamExists('v1ProducersPost', 'typesCreateProducerRequest', typesCreateProducerRequest)
            const localVarPath = `/v1/producers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateProducerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 生産者を削除します。
         * @summary 生産者削除
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersProducerIdDelete: async (producerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'producerId' is not null or undefined
            assertParamExists('v1ProducersProducerIdDelete', 'producerId', producerId)
            const localVarPath = `/v1/producers/{producerId}`
                .replace(`{${"producerId"}}`, encodeURIComponent(String(producerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された生産者の詳細情報を取得します。
         * @summary 生産者取得
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersProducerIdGet: async (producerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'producerId' is not null or undefined
            assertParamExists('v1ProducersProducerIdGet', 'producerId', producerId)
            const localVarPath = `/v1/producers/{producerId}`
                .replace(`{${"producerId"}}`, encodeURIComponent(String(producerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 生産者の情報を更新します。
         * @summary 生産者更新
         * @param {string} producerId 生産者ID
         * @param {TypesUpdateProducerRequest} typesUpdateProducerRequest 生産者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersProducerIdPatch: async (producerId: string, typesUpdateProducerRequest: TypesUpdateProducerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'producerId' is not null or undefined
            assertParamExists('v1ProducersProducerIdPatch', 'producerId', producerId)
            // verify required parameter 'typesUpdateProducerRequest' is not null or undefined
            assertParamExists('v1ProducersProducerIdPatch', 'typesUpdateProducerRequest', typesUpdateProducerRequest)
            const localVarPath = `/v1/producers/{producerId}`
                .replace(`{${"producerId"}}`, encodeURIComponent(String(producerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateProducerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProducerApi - functional programming interface
 * @export
 */
export const ProducerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProducerApiAxiosParamCreator(configuration)
    return {
        /**
         * 生産者の一覧を取得します。コーディネーターは管理店舗の生産者のみ取得可能です。
         * @summary 生産者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] 生産者名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProducersGet(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProducersGet(limit, offset, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1ProducersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい生産者を登録します。コーディネーターは自身が管理する店舗の生産者のみ登録可能です。
         * @summary 生産者登録
         * @param {TypesCreateProducerRequest} typesCreateProducerRequest 生産者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProducersPost(typesCreateProducerRequest: TypesCreateProducerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProducersPost(typesCreateProducerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1ProducersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 生産者を削除します。
         * @summary 生産者削除
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProducersProducerIdDelete(producerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProducersProducerIdDelete(producerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1ProducersProducerIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された生産者の詳細情報を取得します。
         * @summary 生産者取得
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProducersProducerIdGet(producerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProducersProducerIdGet(producerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1ProducersProducerIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 生産者の情報を更新します。
         * @summary 生産者更新
         * @param {string} producerId 生産者ID
         * @param {TypesUpdateProducerRequest} typesUpdateProducerRequest 生産者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProducersProducerIdPatch(producerId: string, typesUpdateProducerRequest: TypesUpdateProducerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProducersProducerIdPatch(producerId, typesUpdateProducerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerApi.v1ProducersProducerIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProducerApi - factory interface
 * @export
 */
export const ProducerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProducerApiFp(configuration)
    return {
        /**
         * 生産者の一覧を取得します。コーディネーターは管理店舗の生産者のみ取得可能です。
         * @summary 生産者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [username] 生産者名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersGet(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProducersResponse> {
            return localVarFp.v1ProducersGet(limit, offset, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい生産者を登録します。コーディネーターは自身が管理する店舗の生産者のみ登録可能です。
         * @summary 生産者登録
         * @param {TypesCreateProducerRequest} typesCreateProducerRequest 生産者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersPost(typesCreateProducerRequest: TypesCreateProducerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProducerResponse> {
            return localVarFp.v1ProducersPost(typesCreateProducerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 生産者を削除します。
         * @summary 生産者削除
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersProducerIdDelete(producerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ProducersProducerIdDelete(producerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された生産者の詳細情報を取得します。
         * @summary 生産者取得
         * @param {string} producerId 生産者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersProducerIdGet(producerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProducerResponse> {
            return localVarFp.v1ProducersProducerIdGet(producerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 生産者の情報を更新します。
         * @summary 生産者更新
         * @param {string} producerId 生産者ID
         * @param {TypesUpdateProducerRequest} typesUpdateProducerRequest 生産者情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProducersProducerIdPatch(producerId: string, typesUpdateProducerRequest: TypesUpdateProducerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ProducersProducerIdPatch(producerId, typesUpdateProducerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProducerApi - object-oriented interface
 * @export
 * @class ProducerApi
 * @extends {BaseAPI}
 */
export class ProducerApi extends BaseAPI {
    /**
     * 生産者の一覧を取得します。コーディネーターは管理店舗の生産者のみ取得可能です。
     * @summary 生産者一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [username] 生産者名(あいまい検索)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1ProducersGet(limit?: number, offset?: number, username?: string, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1ProducersGet(limit, offset, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい生産者を登録します。コーディネーターは自身が管理する店舗の生産者のみ登録可能です。
     * @summary 生産者登録
     * @param {TypesCreateProducerRequest} typesCreateProducerRequest 生産者情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1ProducersPost(typesCreateProducerRequest: TypesCreateProducerRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1ProducersPost(typesCreateProducerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 生産者を削除します。
     * @summary 生産者削除
     * @param {string} producerId 生産者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1ProducersProducerIdDelete(producerId: string, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1ProducersProducerIdDelete(producerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された生産者の詳細情報を取得します。
     * @summary 生産者取得
     * @param {string} producerId 生産者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1ProducersProducerIdGet(producerId: string, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1ProducersProducerIdGet(producerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 生産者の情報を更新します。
     * @summary 生産者更新
     * @param {string} producerId 生産者ID
     * @param {TypesUpdateProducerRequest} typesUpdateProducerRequest 生産者情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerApi
     */
    public v1ProducersProducerIdPatch(producerId: string, typesUpdateProducerRequest: TypesUpdateProducerRequest, options?: RawAxiosRequestConfig) {
        return ProducerApiFp(this.configuration).v1ProducersProducerIdPatch(producerId, typesUpdateProducerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 商品の一覧を取得します。
         * @summary 商品一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品名(あいまい検索)
         * @param {string} [producerId] 生産者ID
         * @param {string} [orders] ソート
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsGet: async (limit?: number, offset?: number, name?: string, producerId?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (producerId !== undefined) {
                localVarQueryParameter['producerId'] = producerId;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい商品を登録します。
         * @summary 商品登録
         * @param {TypesCreateProductRequest} typesCreateProductRequest 商品情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsPost: async (typesCreateProductRequest: TypesCreateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateProductRequest' is not null or undefined
            assertParamExists('v1ProductsPost', 'typesCreateProductRequest', typesCreateProductRequest)
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された商品の詳細情報を取得します。
         * @summary 商品取得
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsProductIdGet: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('v1ProductsProductIdGet', 'productId', productId)
            const localVarPath = `/v1/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 商品の一覧を取得します。
         * @summary 商品一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品名(あいまい検索)
         * @param {string} [producerId] 生産者ID
         * @param {string} [orders] ソート
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsGet(limit?: number, offset?: number, name?: string, producerId?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsGet(limit, offset, name, producerId, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1ProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい商品を登録します。
         * @summary 商品登録
         * @param {TypesCreateProductRequest} typesCreateProductRequest 商品情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsPost(typesCreateProductRequest: TypesCreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsPost(typesCreateProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1ProductsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された商品の詳細情報を取得します。
         * @summary 商品取得
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsProductIdGet(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsProductIdGet(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.v1ProductsProductIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 商品の一覧を取得します。
         * @summary 商品一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品名(あいまい検索)
         * @param {string} [producerId] 生産者ID
         * @param {string} [orders] ソート
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsGet(limit?: number, offset?: number, name?: string, producerId?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.v1ProductsGet(limit, offset, name, producerId, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい商品を登録します。
         * @summary 商品登録
         * @param {TypesCreateProductRequest} typesCreateProductRequest 商品情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsPost(typesCreateProductRequest: TypesCreateProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.v1ProductsPost(typesCreateProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された商品の詳細情報を取得します。
         * @summary 商品取得
         * @param {string} productId 商品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsProductIdGet(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.v1ProductsProductIdGet(productId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 商品の一覧を取得します。
     * @summary 商品一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 商品名(あいまい検索)
     * @param {string} [producerId] 生産者ID
     * @param {string} [orders] ソート
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsGet(limit?: number, offset?: number, name?: string, producerId?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsGet(limit, offset, name, producerId, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい商品を登録します。
     * @summary 商品登録
     * @param {TypesCreateProductRequest} typesCreateProductRequest 商品情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsPost(typesCreateProductRequest: TypesCreateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsPost(typesCreateProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された商品の詳細情報を取得します。
     * @summary 商品取得
     * @param {string} productId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsProductIdGet(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsProductIdGet(productId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductTagApi - axios parameter creator
 * @export
 */
export const ProductTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 商品タグの一覧を取得します。名前でのフィルタリング、ソート順指定が可能です。
         * @summary 商品タグ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品タグ名(あいまい検索)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsGet: async (limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい商品タグを登録します。
         * @summary 商品タグ登録
         * @param {TypesCreateProductTagRequest} typesCreateProductTagRequest 商品タグ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsPost: async (typesCreateProductTagRequest: TypesCreateProductTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateProductTagRequest' is not null or undefined
            assertParamExists('v1ProductTagsPost', 'typesCreateProductTagRequest', typesCreateProductTagRequest)
            const localVarPath = `/v1/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateProductTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品タグを削除します。
         * @summary 商品タグ削除
         * @param {string} productTagId 商品タグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsProductTagIdDelete: async (productTagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTagId' is not null or undefined
            assertParamExists('v1ProductTagsProductTagIdDelete', 'productTagId', productTagId)
            const localVarPath = `/v1/product-tags/{productTagId}`
                .replace(`{${"productTagId"}}`, encodeURIComponent(String(productTagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品タグの情報を更新します。
         * @summary 商品タグ更新
         * @param {string} productTagId 商品タグID
         * @param {TypesUpdateProductTagRequest} typesUpdateProductTagRequest 商品タグ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsProductTagIdPatch: async (productTagId: string, typesUpdateProductTagRequest: TypesUpdateProductTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTagId' is not null or undefined
            assertParamExists('v1ProductTagsProductTagIdPatch', 'productTagId', productTagId)
            // verify required parameter 'typesUpdateProductTagRequest' is not null or undefined
            assertParamExists('v1ProductTagsProductTagIdPatch', 'typesUpdateProductTagRequest', typesUpdateProductTagRequest)
            const localVarPath = `/v1/product-tags/{productTagId}`
                .replace(`{${"productTagId"}}`, encodeURIComponent(String(productTagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateProductTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductTagApi - functional programming interface
 * @export
 */
export const ProductTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductTagApiAxiosParamCreator(configuration)
    return {
        /**
         * 商品タグの一覧を取得します。名前でのフィルタリング、ソート順指定が可能です。
         * @summary 商品タグ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品タグ名(あいまい検索)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductTagsGet(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesProductTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductTagsGet(limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1ProductTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい商品タグを登録します。
         * @summary 商品タグ登録
         * @param {TypesCreateProductTagRequest} typesCreateProductTagRequest 商品タグ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductTagsPost(typesCreateProductTagRequest: TypesCreateProductTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesProductTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductTagsPost(typesCreateProductTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1ProductTagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品タグを削除します。
         * @summary 商品タグ削除
         * @param {string} productTagId 商品タグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductTagsProductTagIdDelete(productTagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductTagsProductTagIdDelete(productTagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1ProductTagsProductTagIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品タグの情報を更新します。
         * @summary 商品タグ更新
         * @param {string} productTagId 商品タグID
         * @param {TypesUpdateProductTagRequest} typesUpdateProductTagRequest 商品タグ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductTagsProductTagIdPatch(productTagId: string, typesUpdateProductTagRequest: TypesUpdateProductTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductTagsProductTagIdPatch(productTagId, typesUpdateProductTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTagApi.v1ProductTagsProductTagIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductTagApi - factory interface
 * @export
 */
export const ProductTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductTagApiFp(configuration)
    return {
        /**
         * 商品タグの一覧を取得します。名前でのフィルタリング、ソート順指定が可能です。
         * @summary 商品タグ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 商品タグ名(あいまい検索)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsGet(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesProductTagsResponse> {
            return localVarFp.v1ProductTagsGet(limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい商品タグを登録します。
         * @summary 商品タグ登録
         * @param {TypesCreateProductTagRequest} typesCreateProductTagRequest 商品タグ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsPost(typesCreateProductTagRequest: TypesCreateProductTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesProductTagResponse> {
            return localVarFp.v1ProductTagsPost(typesCreateProductTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品タグを削除します。
         * @summary 商品タグ削除
         * @param {string} productTagId 商品タグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsProductTagIdDelete(productTagId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ProductTagsProductTagIdDelete(productTagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品タグの情報を更新します。
         * @summary 商品タグ更新
         * @param {string} productTagId 商品タグID
         * @param {TypesUpdateProductTagRequest} typesUpdateProductTagRequest 商品タグ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductTagsProductTagIdPatch(productTagId: string, typesUpdateProductTagRequest: TypesUpdateProductTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ProductTagsProductTagIdPatch(productTagId, typesUpdateProductTagRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductTagApi - object-oriented interface
 * @export
 * @class ProductTagApi
 * @extends {BaseAPI}
 */
export class ProductTagApi extends BaseAPI {
    /**
     * 商品タグの一覧を取得します。名前でのフィルタリング、ソート順指定が可能です。
     * @summary 商品タグ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 商品タグ名(あいまい検索)
     * @param {string} [orders] ソート(name,-name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1ProductTagsGet(limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1ProductTagsGet(limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい商品タグを登録します。
     * @summary 商品タグ登録
     * @param {TypesCreateProductTagRequest} typesCreateProductTagRequest 商品タグ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1ProductTagsPost(typesCreateProductTagRequest: TypesCreateProductTagRequest, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1ProductTagsPost(typesCreateProductTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品タグを削除します。
     * @summary 商品タグ削除
     * @param {string} productTagId 商品タグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1ProductTagsProductTagIdDelete(productTagId: string, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1ProductTagsProductTagIdDelete(productTagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品タグの情報を更新します。
     * @summary 商品タグ更新
     * @param {string} productTagId 商品タグID
     * @param {TypesUpdateProductTagRequest} typesUpdateProductTagRequest 商品タグ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public v1ProductTagsProductTagIdPatch(productTagId: string, typesUpdateProductTagRequest: TypesUpdateProductTagRequest, options?: RawAxiosRequestConfig) {
        return ProductTagApiFp(this.configuration).v1ProductTagsProductTagIdPatch(productTagId, typesUpdateProductTagRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductTypeApi - axios parameter creator
 * @export
 */
export const ProductTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 品目の一覧を取得します。商品種別ID指定時はその種別の品目のみ取得します。
         * @summary 品目一覧取得
         * @param {string} categoryId 商品種別ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesGet: async (categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesGet', 'categoryId', categoryId)
            const localVarPath = `/v1/categories/{categoryId}/product-types`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい品目を登録します。
         * @summary 品目登録
         * @param {string} categoryId 商品種別ID
         * @param {TypesCreateProductTypeRequest} typesCreateProductTypeRequest 品目情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesPost: async (categoryId: string, typesCreateProductTypeRequest: TypesCreateProductTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesPost', 'categoryId', categoryId)
            // verify required parameter 'typesCreateProductTypeRequest' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesPost', 'typesCreateProductTypeRequest', typesCreateProductTypeRequest)
            const localVarPath = `/v1/categories/{categoryId}/product-types`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateProductTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 品目を削除します。
         * @summary 品目削除
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesProductTypeIdDelete: async (categoryId: string, productTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesProductTypeIdDelete', 'categoryId', categoryId)
            // verify required parameter 'productTypeId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesProductTypeIdDelete', 'productTypeId', productTypeId)
            const localVarPath = `/v1/categories/{categoryId}/product-types/{productTypeId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"productTypeId"}}`, encodeURIComponent(String(productTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 品目の情報を更新します。
         * @summary 品目更新
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {TypesUpdateProductTypeRequest} typesUpdateProductTypeRequest 品目情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesProductTypeIdPatch: async (categoryId: string, productTypeId: string, typesUpdateProductTypeRequest: TypesUpdateProductTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesProductTypeIdPatch', 'categoryId', categoryId)
            // verify required parameter 'productTypeId' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesProductTypeIdPatch', 'productTypeId', productTypeId)
            // verify required parameter 'typesUpdateProductTypeRequest' is not null or undefined
            assertParamExists('v1CategoriesCategoryIdProductTypesProductTypeIdPatch', 'typesUpdateProductTypeRequest', typesUpdateProductTypeRequest)
            const localVarPath = `/v1/categories/{categoryId}/product-types/{productTypeId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"productTypeId"}}`, encodeURIComponent(String(productTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateProductTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductTypeApi - functional programming interface
 * @export
 */
export const ProductTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 品目の一覧を取得します。商品種別ID指定時はその種別の品目のみ取得します。
         * @summary 品目一覧取得
         * @param {string} categoryId 商品種別ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesCategoryIdProductTypesGet(categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesProductTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesCategoryIdProductTypesGet(categoryId, limit, offset, name, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1CategoriesCategoryIdProductTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい品目を登録します。
         * @summary 品目登録
         * @param {string} categoryId 商品種別ID
         * @param {TypesCreateProductTypeRequest} typesCreateProductTypeRequest 品目情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesCategoryIdProductTypesPost(categoryId: string, typesCreateProductTypeRequest: TypesCreateProductTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesProductTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesCategoryIdProductTypesPost(categoryId, typesCreateProductTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1CategoriesCategoryIdProductTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 品目を削除します。
         * @summary 品目削除
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesCategoryIdProductTypesProductTypeIdDelete(categoryId: string, productTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesCategoryIdProductTypesProductTypeIdDelete(categoryId, productTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1CategoriesCategoryIdProductTypesProductTypeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 品目の情報を更新します。
         * @summary 品目更新
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {TypesUpdateProductTypeRequest} typesUpdateProductTypeRequest 品目情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CategoriesCategoryIdProductTypesProductTypeIdPatch(categoryId: string, productTypeId: string, typesUpdateProductTypeRequest: TypesUpdateProductTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CategoriesCategoryIdProductTypesProductTypeIdPatch(categoryId, productTypeId, typesUpdateProductTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductTypeApi.v1CategoriesCategoryIdProductTypesProductTypeIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductTypeApi - factory interface
 * @export
 */
export const ProductTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductTypeApiFp(configuration)
    return {
        /**
         * 品目の一覧を取得します。商品種別ID指定時はその種別の品目のみ取得します。
         * @summary 品目一覧取得
         * @param {string} categoryId 商品種別ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 品目名(あいまい検索)
         * @param {string} [orders] ソート(name,-name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesGet(categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesProductTypesResponse> {
            return localVarFp.v1CategoriesCategoryIdProductTypesGet(categoryId, limit, offset, name, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい品目を登録します。
         * @summary 品目登録
         * @param {string} categoryId 商品種別ID
         * @param {TypesCreateProductTypeRequest} typesCreateProductTypeRequest 品目情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesPost(categoryId: string, typesCreateProductTypeRequest: TypesCreateProductTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesProductTypeResponse> {
            return localVarFp.v1CategoriesCategoryIdProductTypesPost(categoryId, typesCreateProductTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 品目を削除します。
         * @summary 品目削除
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesProductTypeIdDelete(categoryId: string, productTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CategoriesCategoryIdProductTypesProductTypeIdDelete(categoryId, productTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 品目の情報を更新します。
         * @summary 品目更新
         * @param {string} categoryId 商品種別ID
         * @param {string} productTypeId 品目ID
         * @param {TypesUpdateProductTypeRequest} typesUpdateProductTypeRequest 品目情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CategoriesCategoryIdProductTypesProductTypeIdPatch(categoryId: string, productTypeId: string, typesUpdateProductTypeRequest: TypesUpdateProductTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CategoriesCategoryIdProductTypesProductTypeIdPatch(categoryId, productTypeId, typesUpdateProductTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductTypeApi - object-oriented interface
 * @export
 * @class ProductTypeApi
 * @extends {BaseAPI}
 */
export class ProductTypeApi extends BaseAPI {
    /**
     * 品目の一覧を取得します。商品種別ID指定時はその種別の品目のみ取得します。
     * @summary 品目一覧取得
     * @param {string} categoryId 商品種別ID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 品目名(あいまい検索)
     * @param {string} [orders] ソート(name,-name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1CategoriesCategoryIdProductTypesGet(categoryId: string, limit?: number, offset?: number, name?: string, orders?: string, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1CategoriesCategoryIdProductTypesGet(categoryId, limit, offset, name, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい品目を登録します。
     * @summary 品目登録
     * @param {string} categoryId 商品種別ID
     * @param {TypesCreateProductTypeRequest} typesCreateProductTypeRequest 品目情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1CategoriesCategoryIdProductTypesPost(categoryId: string, typesCreateProductTypeRequest: TypesCreateProductTypeRequest, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1CategoriesCategoryIdProductTypesPost(categoryId, typesCreateProductTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 品目を削除します。
     * @summary 品目削除
     * @param {string} categoryId 商品種別ID
     * @param {string} productTypeId 品目ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1CategoriesCategoryIdProductTypesProductTypeIdDelete(categoryId: string, productTypeId: string, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1CategoriesCategoryIdProductTypesProductTypeIdDelete(categoryId, productTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 品目の情報を更新します。
     * @summary 品目更新
     * @param {string} categoryId 商品種別ID
     * @param {string} productTypeId 品目ID
     * @param {TypesUpdateProductTypeRequest} typesUpdateProductTypeRequest 品目情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTypeApi
     */
    public v1CategoriesCategoryIdProductTypesProductTypeIdPatch(categoryId: string, productTypeId: string, typesUpdateProductTypeRequest: TypesUpdateProductTypeRequest, options?: RawAxiosRequestConfig) {
        return ProductTypeApiFp(this.configuration).v1CategoriesCategoryIdProductTypesProductTypeIdPatch(categoryId, productTypeId, typesUpdateProductTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromotionApi - axios parameter creator
 * @export
 */
export const PromotionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * プロモーションの一覧を取得します。ページネーション、ショップ・タイトルでのフィルタリング、ソート機能に対応しています。
         * @summary プロモーション一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [shopId] ショップID
         * @param {string} [title] プロモーションタイトル
         * @param {boolean} [withAllTarget] 全ショップ対象のプロモーションも含める
         * @param {string} [orders] ソート順序
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsGet: async (limit?: number, offset?: number, shopId?: string, title?: string, withAllTarget?: boolean, orders?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/promotions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (shopId !== undefined) {
                localVarQueryParameter['shopId'] = shopId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (withAllTarget !== undefined) {
                localVarQueryParameter['withAllTarget'] = withAllTarget;
            }

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいプロモーションを登録します。
         * @summary プロモーション登録
         * @param {TypesCreatePromotionRequest} typesCreatePromotionRequest プロモーション情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPost: async (typesCreatePromotionRequest: TypesCreatePromotionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreatePromotionRequest' is not null or undefined
            assertParamExists('v1PromotionsPost', 'typesCreatePromotionRequest', typesCreatePromotionRequest)
            const localVarPath = `/v1/promotions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreatePromotionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * プロモーションを削除します。
         * @summary プロモーション削除
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPromotionIdDelete: async (promotionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('v1PromotionsPromotionIdDelete', 'promotionId', promotionId)
            const localVarPath = `/v1/promotions/{promotionId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたプロモーションの詳細情報を取得します。
         * @summary プロモーション取得
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPromotionIdGet: async (promotionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('v1PromotionsPromotionIdGet', 'promotionId', promotionId)
            const localVarPath = `/v1/promotions/{promotionId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * プロモーションの情報を更新します。
         * @summary プロモーション更新
         * @param {string} promotionId プロモーションID
         * @param {TypesUpdatePromotionRequest} typesUpdatePromotionRequest プロモーション情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPromotionIdPatch: async (promotionId: string, typesUpdatePromotionRequest: TypesUpdatePromotionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionId' is not null or undefined
            assertParamExists('v1PromotionsPromotionIdPatch', 'promotionId', promotionId)
            // verify required parameter 'typesUpdatePromotionRequest' is not null or undefined
            assertParamExists('v1PromotionsPromotionIdPatch', 'typesUpdatePromotionRequest', typesUpdatePromotionRequest)
            const localVarPath = `/v1/promotions/{promotionId}`
                .replace(`{${"promotionId"}}`, encodeURIComponent(String(promotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdatePromotionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromotionApi - functional programming interface
 * @export
 */
export const PromotionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromotionApiAxiosParamCreator(configuration)
    return {
        /**
         * プロモーションの一覧を取得します。ページネーション、ショップ・タイトルでのフィルタリング、ソート機能に対応しています。
         * @summary プロモーション一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [shopId] ショップID
         * @param {string} [title] プロモーションタイトル
         * @param {boolean} [withAllTarget] 全ショップ対象のプロモーションも含める
         * @param {string} [orders] ソート順序
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionsGet(limit?: number, offset?: number, shopId?: string, title?: string, withAllTarget?: boolean, orders?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesPromotionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionsGet(limit, offset, shopId, title, withAllTarget, orders, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1PromotionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいプロモーションを登録します。
         * @summary プロモーション登録
         * @param {TypesCreatePromotionRequest} typesCreatePromotionRequest プロモーション情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionsPost(typesCreatePromotionRequest: TypesCreatePromotionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionsPost(typesCreatePromotionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1PromotionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * プロモーションを削除します。
         * @summary プロモーション削除
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionsPromotionIdDelete(promotionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionsPromotionIdDelete(promotionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1PromotionsPromotionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたプロモーションの詳細情報を取得します。
         * @summary プロモーション取得
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionsPromotionIdGet(promotionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionsPromotionIdGet(promotionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1PromotionsPromotionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * プロモーションの情報を更新します。
         * @summary プロモーション更新
         * @param {string} promotionId プロモーションID
         * @param {TypesUpdatePromotionRequest} typesUpdatePromotionRequest プロモーション情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionsPromotionIdPatch(promotionId: string, typesUpdatePromotionRequest: TypesUpdatePromotionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionsPromotionIdPatch(promotionId, typesUpdatePromotionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionApi.v1PromotionsPromotionIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromotionApi - factory interface
 * @export
 */
export const PromotionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromotionApiFp(configuration)
    return {
        /**
         * プロモーションの一覧を取得します。ページネーション、ショップ・タイトルでのフィルタリング、ソート機能に対応しています。
         * @summary プロモーション一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [shopId] ショップID
         * @param {string} [title] プロモーションタイトル
         * @param {boolean} [withAllTarget] 全ショップ対象のプロモーションも含める
         * @param {string} [orders] ソート順序
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsGet(limit?: number, offset?: number, shopId?: string, title?: string, withAllTarget?: boolean, orders?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesPromotionsResponse> {
            return localVarFp.v1PromotionsGet(limit, offset, shopId, title, withAllTarget, orders, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいプロモーションを登録します。
         * @summary プロモーション登録
         * @param {TypesCreatePromotionRequest} typesCreatePromotionRequest プロモーション情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPost(typesCreatePromotionRequest: TypesCreatePromotionRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromotionResponse> {
            return localVarFp.v1PromotionsPost(typesCreatePromotionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * プロモーションを削除します。
         * @summary プロモーション削除
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPromotionIdDelete(promotionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1PromotionsPromotionIdDelete(promotionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたプロモーションの詳細情報を取得します。
         * @summary プロモーション取得
         * @param {string} promotionId プロモーションID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPromotionIdGet(promotionId: string, options?: RawAxiosRequestConfig): AxiosPromise<PromotionResponse> {
            return localVarFp.v1PromotionsPromotionIdGet(promotionId, options).then((request) => request(axios, basePath));
        },
        /**
         * プロモーションの情報を更新します。
         * @summary プロモーション更新
         * @param {string} promotionId プロモーションID
         * @param {TypesUpdatePromotionRequest} typesUpdatePromotionRequest プロモーション情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionsPromotionIdPatch(promotionId: string, typesUpdatePromotionRequest: TypesUpdatePromotionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1PromotionsPromotionIdPatch(promotionId, typesUpdatePromotionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromotionApi - object-oriented interface
 * @export
 * @class PromotionApi
 * @extends {BaseAPI}
 */
export class PromotionApi extends BaseAPI {
    /**
     * プロモーションの一覧を取得します。ページネーション、ショップ・タイトルでのフィルタリング、ソート機能に対応しています。
     * @summary プロモーション一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [shopId] ショップID
     * @param {string} [title] プロモーションタイトル
     * @param {boolean} [withAllTarget] 全ショップ対象のプロモーションも含める
     * @param {string} [orders] ソート順序
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1PromotionsGet(limit?: number, offset?: number, shopId?: string, title?: string, withAllTarget?: boolean, orders?: string, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1PromotionsGet(limit, offset, shopId, title, withAllTarget, orders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいプロモーションを登録します。
     * @summary プロモーション登録
     * @param {TypesCreatePromotionRequest} typesCreatePromotionRequest プロモーション情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1PromotionsPost(typesCreatePromotionRequest: TypesCreatePromotionRequest, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1PromotionsPost(typesCreatePromotionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * プロモーションを削除します。
     * @summary プロモーション削除
     * @param {string} promotionId プロモーションID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1PromotionsPromotionIdDelete(promotionId: string, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1PromotionsPromotionIdDelete(promotionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたプロモーションの詳細情報を取得します。
     * @summary プロモーション取得
     * @param {string} promotionId プロモーションID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1PromotionsPromotionIdGet(promotionId: string, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1PromotionsPromotionIdGet(promotionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * プロモーションの情報を更新します。
     * @summary プロモーション更新
     * @param {string} promotionId プロモーションID
     * @param {TypesUpdatePromotionRequest} typesUpdatePromotionRequest プロモーション情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionApi
     */
    public v1PromotionsPromotionIdPatch(promotionId: string, typesUpdatePromotionRequest: TypesUpdatePromotionRequest, options?: RawAxiosRequestConfig) {
        return PromotionApiFp(this.configuration).v1PromotionsPromotionIdPatch(promotionId, typesUpdatePromotionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RelatedProducerApi - axios parameter creator
 * @export
 */
export const RelatedProducerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたコーディネーターに関連する生産者の一覧を取得します。
         * @summary 関連生産者一覧取得
         * @param {string} coordinatorId コーディネーターID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdProducersGet: async (coordinatorId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdProducersGet', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/producers`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelatedProducerApi - functional programming interface
 * @export
 */
export const RelatedProducerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelatedProducerApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたコーディネーターに関連する生産者の一覧を取得します。
         * @summary 関連生産者一覧取得
         * @param {string} coordinatorId コーディネーターID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdProducersGet(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdProducersGet(coordinatorId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelatedProducerApi.v1CoordinatorsCoordinatorIdProducersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RelatedProducerApi - factory interface
 * @export
 */
export const RelatedProducerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelatedProducerApiFp(configuration)
    return {
        /**
         * 指定されたコーディネーターに関連する生産者の一覧を取得します。
         * @summary 関連生産者一覧取得
         * @param {string} coordinatorId コーディネーターID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdProducersGet(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProducersResponse> {
            return localVarFp.v1CoordinatorsCoordinatorIdProducersGet(coordinatorId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelatedProducerApi - object-oriented interface
 * @export
 * @class RelatedProducerApi
 * @extends {BaseAPI}
 */
export class RelatedProducerApi extends BaseAPI {
    /**
     * 指定されたコーディネーターに関連する生産者の一覧を取得します。
     * @summary 関連生産者一覧取得
     * @param {string} coordinatorId コーディネーターID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelatedProducerApi
     */
    public v1CoordinatorsCoordinatorIdProducersGet(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return RelatedProducerApiFp(this.configuration).v1CoordinatorsCoordinatorIdProducersGet(coordinatorId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * マルシェ開催スケジュールの一覧を取得します。ページネーションに対応しています。
         * @summary マルシェ開催スケジュール一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesGet: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいマルシェ開催スケジュールを登録します。
         * @summary マルシェ開催スケジュール登録
         * @param {TypesCreateScheduleRequest} typesCreateScheduleRequest スケジュール情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesPost: async (typesCreateScheduleRequest: TypesCreateScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateScheduleRequest' is not null or undefined
            assertParamExists('v1SchedulesPost', 'typesCreateScheduleRequest', typesCreateScheduleRequest)
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたマルシェ開催スケジュールの視聴者分析データを取得します。集計期間と集計間隔を指定できます。
         * @summary マルシェ分析情報取得
         * @param {string} scheduleId スケジュールID
         * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はスケジュール開始時間)
         * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はスケジュール終了時間)
         * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdAnalyticsGet: async (scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdAnalyticsGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}/analytics`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startAt !== undefined) {
                localVarQueryParameter['startAt'] = startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['endAt'] = endAt;
            }

            if (viewerLogInterval !== undefined) {
                localVarQueryParameter['viewerLogInterval'] = viewerLogInterval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * マルシェ開催スケジュールの承認状態を更新します。
         * @summary マルシェ開催スケジュール承認
         * @param {string} scheduleId スケジュールID
         * @param {TypesApproveScheduleRequest} typesApproveScheduleRequest 承認情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdApprovalPatch: async (scheduleId: string, typesApproveScheduleRequest: TypesApproveScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdApprovalPatch', 'scheduleId', scheduleId)
            // verify required parameter 'typesApproveScheduleRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdApprovalPatch', 'typesApproveScheduleRequest', typesApproveScheduleRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/approval`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesApproveScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * マルシェ開催スケジュールを削除します。
         * @summary マルシェ開催スケジュール削除
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdDelete: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdDelete', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたマルシェ開催スケジュールの詳細情報を取得します。
         * @summary マルシェ開催スケジュール取得
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdGet: async (scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * マルシェ開催スケジュールの情報を更新します。
         * @summary マルシェ開催スケジュール更新
         * @param {string} scheduleId スケジュールID
         * @param {TypesUpdateScheduleRequest} typesUpdateScheduleRequest スケジュール情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdPatch: async (scheduleId: string, typesUpdateScheduleRequest: TypesUpdateScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdPatch', 'scheduleId', scheduleId)
            // verify required parameter 'typesUpdateScheduleRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdPatch', 'typesUpdateScheduleRequest', typesUpdateScheduleRequest)
            const localVarPath = `/v1/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * マルシェ開催スケジュールの公開状態を更新します。
         * @summary マルシェ開催スケジュール公開
         * @param {string} scheduleId スケジュールID
         * @param {TypesPublishScheduleRequest} typesPublishScheduleRequest 公開設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdPublishPatch: async (scheduleId: string, typesPublishScheduleRequest: TypesPublishScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdPublishPatch', 'scheduleId', scheduleId)
            // verify required parameter 'typesPublishScheduleRequest' is not null or undefined
            assertParamExists('v1SchedulesScheduleIdPublishPatch', 'typesPublishScheduleRequest', typesPublishScheduleRequest)
            const localVarPath = `/v1/schedules/{scheduleId}/publish`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesPublishScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * マルシェ開催スケジュールの一覧を取得します。ページネーションに対応しています。
         * @summary マルシェ開催スケジュール一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesSchedulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいマルシェ開催スケジュールを登録します。
         * @summary マルシェ開催スケジュール登録
         * @param {TypesCreateScheduleRequest} typesCreateScheduleRequest スケジュール情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesPost(typesCreateScheduleRequest: TypesCreateScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesPost(typesCreateScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたマルシェ開催スケジュールの視聴者分析データを取得します。集計期間と集計間隔を指定できます。
         * @summary マルシェ分析情報取得
         * @param {string} scheduleId スケジュールID
         * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はスケジュール開始時間)
         * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はスケジュール終了時間)
         * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdAnalyticsGet(scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAnalyzeScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdAnalyticsGet(scheduleId, startAt, endAt, viewerLogInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesScheduleIdAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * マルシェ開催スケジュールの承認状態を更新します。
         * @summary マルシェ開催スケジュール承認
         * @param {string} scheduleId スケジュールID
         * @param {TypesApproveScheduleRequest} typesApproveScheduleRequest 承認情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdApprovalPatch(scheduleId: string, typesApproveScheduleRequest: TypesApproveScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdApprovalPatch(scheduleId, typesApproveScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesScheduleIdApprovalPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * マルシェ開催スケジュールを削除します。
         * @summary マルシェ開催スケジュール削除
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdDelete(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdDelete(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesScheduleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたマルシェ開催スケジュールの詳細情報を取得します。
         * @summary マルシェ開催スケジュール取得
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdGet(scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdGet(scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesScheduleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * マルシェ開催スケジュールの情報を更新します。
         * @summary マルシェ開催スケジュール更新
         * @param {string} scheduleId スケジュールID
         * @param {TypesUpdateScheduleRequest} typesUpdateScheduleRequest スケジュール情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdPatch(scheduleId: string, typesUpdateScheduleRequest: TypesUpdateScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdPatch(scheduleId, typesUpdateScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesScheduleIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * マルシェ開催スケジュールの公開状態を更新します。
         * @summary マルシェ開催スケジュール公開
         * @param {string} scheduleId スケジュールID
         * @param {TypesPublishScheduleRequest} typesPublishScheduleRequest 公開設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SchedulesScheduleIdPublishPatch(scheduleId: string, typesPublishScheduleRequest: TypesPublishScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SchedulesScheduleIdPublishPatch(scheduleId, typesPublishScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.v1SchedulesScheduleIdPublishPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * マルシェ開催スケジュールの一覧を取得します。ページネーションに対応しています。
         * @summary マルシェ開催スケジュール一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesSchedulesResponse> {
            return localVarFp.v1SchedulesGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいマルシェ開催スケジュールを登録します。
         * @summary マルシェ開催スケジュール登録
         * @param {TypesCreateScheduleRequest} typesCreateScheduleRequest スケジュール情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesPost(typesCreateScheduleRequest: TypesCreateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.v1SchedulesPost(typesCreateScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたマルシェ開催スケジュールの視聴者分析データを取得します。集計期間と集計間隔を指定できます。
         * @summary マルシェ分析情報取得
         * @param {string} scheduleId スケジュールID
         * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はスケジュール開始時間)
         * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はスケジュール終了時間)
         * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdAnalyticsGet(scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesAnalyzeScheduleResponse> {
            return localVarFp.v1SchedulesScheduleIdAnalyticsGet(scheduleId, startAt, endAt, viewerLogInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * マルシェ開催スケジュールの承認状態を更新します。
         * @summary マルシェ開催スケジュール承認
         * @param {string} scheduleId スケジュールID
         * @param {TypesApproveScheduleRequest} typesApproveScheduleRequest 承認情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdApprovalPatch(scheduleId: string, typesApproveScheduleRequest: TypesApproveScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdApprovalPatch(scheduleId, typesApproveScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * マルシェ開催スケジュールを削除します。
         * @summary マルシェ開催スケジュール削除
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdDelete(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdDelete(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたマルシェ開催スケジュールの詳細情報を取得します。
         * @summary マルシェ開催スケジュール取得
         * @param {string} scheduleId スケジュールID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdGet(scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.v1SchedulesScheduleIdGet(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * マルシェ開催スケジュールの情報を更新します。
         * @summary マルシェ開催スケジュール更新
         * @param {string} scheduleId スケジュールID
         * @param {TypesUpdateScheduleRequest} typesUpdateScheduleRequest スケジュール情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdPatch(scheduleId: string, typesUpdateScheduleRequest: TypesUpdateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdPatch(scheduleId, typesUpdateScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * マルシェ開催スケジュールの公開状態を更新します。
         * @summary マルシェ開催スケジュール公開
         * @param {string} scheduleId スケジュールID
         * @param {TypesPublishScheduleRequest} typesPublishScheduleRequest 公開設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SchedulesScheduleIdPublishPatch(scheduleId: string, typesPublishScheduleRequest: TypesPublishScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SchedulesScheduleIdPublishPatch(scheduleId, typesPublishScheduleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * マルシェ開催スケジュールの一覧を取得します。ページネーションに対応しています。
     * @summary マルシェ開催スケジュール一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいマルシェ開催スケジュールを登録します。
     * @summary マルシェ開催スケジュール登録
     * @param {TypesCreateScheduleRequest} typesCreateScheduleRequest スケジュール情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesPost(typesCreateScheduleRequest: TypesCreateScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesPost(typesCreateScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたマルシェ開催スケジュールの視聴者分析データを取得します。集計期間と集計間隔を指定できます。
     * @summary マルシェ分析情報取得
     * @param {string} scheduleId スケジュールID
     * @param {number} [startAt] 集計開始日時 (unixtime,未指定の場合はスケジュール開始時間)
     * @param {number} [endAt] 集計終了日時 (unixtime,未指定の場合はスケジュール終了時間)
     * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesScheduleIdAnalyticsGet(scheduleId: string, startAt?: number, endAt?: number, viewerLogInterval?: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesScheduleIdAnalyticsGet(scheduleId, startAt, endAt, viewerLogInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * マルシェ開催スケジュールの承認状態を更新します。
     * @summary マルシェ開催スケジュール承認
     * @param {string} scheduleId スケジュールID
     * @param {TypesApproveScheduleRequest} typesApproveScheduleRequest 承認情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesScheduleIdApprovalPatch(scheduleId: string, typesApproveScheduleRequest: TypesApproveScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesScheduleIdApprovalPatch(scheduleId, typesApproveScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * マルシェ開催スケジュールを削除します。
     * @summary マルシェ開催スケジュール削除
     * @param {string} scheduleId スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesScheduleIdDelete(scheduleId: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesScheduleIdDelete(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたマルシェ開催スケジュールの詳細情報を取得します。
     * @summary マルシェ開催スケジュール取得
     * @param {string} scheduleId スケジュールID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesScheduleIdGet(scheduleId: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesScheduleIdGet(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * マルシェ開催スケジュールの情報を更新します。
     * @summary マルシェ開催スケジュール更新
     * @param {string} scheduleId スケジュールID
     * @param {TypesUpdateScheduleRequest} typesUpdateScheduleRequest スケジュール情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesScheduleIdPatch(scheduleId: string, typesUpdateScheduleRequest: TypesUpdateScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesScheduleIdPatch(scheduleId, typesUpdateScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * マルシェ開催スケジュールの公開状態を更新します。
     * @summary マルシェ開催スケジュール公開
     * @param {string} scheduleId スケジュールID
     * @param {TypesPublishScheduleRequest} typesPublishScheduleRequest 公開設定情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public v1SchedulesScheduleIdPublishPatch(scheduleId: string, typesPublishScheduleRequest: TypesPublishScheduleRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).v1SchedulesScheduleIdPublishPatch(scheduleId, typesPublishScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShippingApi - axios parameter creator
 * @export
 */
export const ShippingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deprecated.指定されたコーディネーターのアクティブ配送設定を取得します。
         * @summary アクティブ配送設定取得
         * @param {string} coordinatorId コーディネーターID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsActivationGet: async (coordinatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsActivationGet', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings/-/activation`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたコーディネーターの配送設定一覧を取得します。ページネーションに対応しています。
         * @summary 配送設定一覧取得
         * @param {string} coordinatorId コーディネーターID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsGet: async (coordinatorId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsGet', 'coordinatorId', coordinatorId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated.コーディネータの配送設定を更新します。
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネータID
         * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsPatch: async (coordinatorId: string, typesUpsertShippingRequest: TypesUpsertShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsPatch', 'coordinatorId', coordinatorId)
            // verify required parameter 'typesUpsertShippingRequest' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsPatch', 'typesUpsertShippingRequest', typesUpsertShippingRequest)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpsertShippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい配送設定を登録します。
         * @summary 配送設定登録
         * @param {string} coordinatorId コーディネーターID
         * @param {TypesCreateShippingRequest} typesCreateShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsPost: async (coordinatorId: string, typesCreateShippingRequest: TypesCreateShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsPost', 'coordinatorId', coordinatorId)
            // verify required parameter 'typesCreateShippingRequest' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsPost', 'typesCreateShippingRequest', typesCreateShippingRequest)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateShippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定した配送設定をアクティブに設定します。
         * @summary アクティブ配送設定更新
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch: async (coordinatorId: string, shippingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch', 'coordinatorId', coordinatorId)
            // verify required parameter 'shippingId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch', 'shippingId', shippingId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings/{shippingId}/activation`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)))
                .replace(`{${"shippingId"}}`, encodeURIComponent(String(shippingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 配送設定を削除します。
         * @summary 配送設定削除
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdDelete: async (coordinatorId: string, shippingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdDelete', 'coordinatorId', coordinatorId)
            // verify required parameter 'shippingId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdDelete', 'shippingId', shippingId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings/{shippingId}`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)))
                .replace(`{${"shippingId"}}`, encodeURIComponent(String(shippingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された配送設定の詳細情報を取得します。
         * @summary 配送設定取得
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdGet: async (coordinatorId: string, shippingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdGet', 'coordinatorId', coordinatorId)
            // verify required parameter 'shippingId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdGet', 'shippingId', shippingId)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings/{shippingId}`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)))
                .replace(`{${"shippingId"}}`, encodeURIComponent(String(shippingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 配送設定の情報を更新します。
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {TypesUpdateShippingRequest} typesUpdateShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdPatch: async (coordinatorId: string, shippingId: string, typesUpdateShippingRequest: TypesUpdateShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'coordinatorId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdPatch', 'coordinatorId', coordinatorId)
            // verify required parameter 'shippingId' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdPatch', 'shippingId', shippingId)
            // verify required parameter 'typesUpdateShippingRequest' is not null or undefined
            assertParamExists('v1CoordinatorsCoordinatorIdShippingsShippingIdPatch', 'typesUpdateShippingRequest', typesUpdateShippingRequest)
            const localVarPath = `/v1/coordinators/{coordinatorId}/shippings/{shippingId}`
                .replace(`{${"coordinatorId"}}`, encodeURIComponent(String(coordinatorId)))
                .replace(`{${"shippingId"}}`, encodeURIComponent(String(shippingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateShippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * デフォルトの配送設定を取得します。
         * @summary デフォルト配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShippingsDefaultGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shippings/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * デフォルトの配送設定を更新します。
         * @summary デフォルト配送設定更新
         * @param {TypesUpdateDefaultShippingRequest} typesUpdateDefaultShippingRequest デフォルト配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShippingsDefaultPatch: async (typesUpdateDefaultShippingRequest: TypesUpdateDefaultShippingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesUpdateDefaultShippingRequest' is not null or undefined
            assertParamExists('v1ShippingsDefaultPatch', 'typesUpdateDefaultShippingRequest', typesUpdateDefaultShippingRequest)
            const localVarPath = `/v1/shippings/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateDefaultShippingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShippingApi - functional programming interface
 * @export
 */
export const ShippingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShippingApiAxiosParamCreator(configuration)
    return {
        /**
         * Deprecated.指定されたコーディネーターのアクティブ配送設定を取得します。
         * @summary アクティブ配送設定取得
         * @param {string} coordinatorId コーディネーターID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsActivationGet(coordinatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsActivationGet(coordinatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsActivationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたコーディネーターの配送設定一覧を取得します。ページネーションに対応しています。
         * @summary 配送設定一覧取得
         * @param {string} coordinatorId コーディネーターID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsGet(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShippingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsGet(coordinatorId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deprecated.コーディネータの配送設定を更新します。
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネータID
         * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsPatch(coordinatorId: string, typesUpsertShippingRequest: TypesUpsertShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsPatch(coordinatorId, typesUpsertShippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい配送設定を登録します。
         * @summary 配送設定登録
         * @param {string} coordinatorId コーディネーターID
         * @param {TypesCreateShippingRequest} typesCreateShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsPost(coordinatorId: string, typesCreateShippingRequest: TypesCreateShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsPost(coordinatorId, typesCreateShippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定した配送設定をアクティブに設定します。
         * @summary アクティブ配送設定更新
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch(coordinatorId, shippingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 配送設定を削除します。
         * @summary 配送設定削除
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsShippingIdDelete(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsShippingIdDelete(coordinatorId, shippingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsShippingIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された配送設定の詳細情報を取得します。
         * @summary 配送設定取得
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsShippingIdGet(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsShippingIdGet(coordinatorId, shippingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsShippingIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 配送設定の情報を更新します。
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {TypesUpdateShippingRequest} typesUpdateShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoordinatorsCoordinatorIdShippingsShippingIdPatch(coordinatorId: string, shippingId: string, typesUpdateShippingRequest: TypesUpdateShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoordinatorsCoordinatorIdShippingsShippingIdPatch(coordinatorId, shippingId, typesUpdateShippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1CoordinatorsCoordinatorIdShippingsShippingIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * デフォルトの配送設定を取得します。
         * @summary デフォルト配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ShippingsDefaultGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShippingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ShippingsDefaultGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1ShippingsDefaultGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * デフォルトの配送設定を更新します。
         * @summary デフォルト配送設定更新
         * @param {TypesUpdateDefaultShippingRequest} typesUpdateDefaultShippingRequest デフォルト配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ShippingsDefaultPatch(typesUpdateDefaultShippingRequest: TypesUpdateDefaultShippingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ShippingsDefaultPatch(typesUpdateDefaultShippingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShippingApi.v1ShippingsDefaultPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShippingApi - factory interface
 * @export
 */
export const ShippingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShippingApiFp(configuration)
    return {
        /**
         * Deprecated.指定されたコーディネーターのアクティブ配送設定を取得します。
         * @summary アクティブ配送設定取得
         * @param {string} coordinatorId コーディネーターID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsActivationGet(coordinatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesShippingResponse> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsActivationGet(coordinatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたコーディネーターの配送設定一覧を取得します。ページネーションに対応しています。
         * @summary 配送設定一覧取得
         * @param {string} coordinatorId コーディネーターID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsGet(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesShippingsResponse> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsGet(coordinatorId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecated.コーディネータの配送設定を更新します。
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネータID
         * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsPatch(coordinatorId: string, typesUpsertShippingRequest: TypesUpsertShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsPatch(coordinatorId, typesUpsertShippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい配送設定を登録します。
         * @summary 配送設定登録
         * @param {string} coordinatorId コーディネーターID
         * @param {TypesCreateShippingRequest} typesCreateShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsPost(coordinatorId: string, typesCreateShippingRequest: TypesCreateShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesShippingResponse> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsPost(coordinatorId, typesCreateShippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定した配送設定をアクティブに設定します。
         * @summary アクティブ配送設定更新
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch(coordinatorId, shippingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 配送設定を削除します。
         * @summary 配送設定削除
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdDelete(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsShippingIdDelete(coordinatorId, shippingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された配送設定の詳細情報を取得します。
         * @summary 配送設定取得
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdGet(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesShippingResponse> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsShippingIdGet(coordinatorId, shippingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 配送設定の情報を更新します。
         * @summary 配送設定更新
         * @param {string} coordinatorId コーディネーターID
         * @param {string} shippingId 配送設定ID
         * @param {TypesUpdateShippingRequest} typesUpdateShippingRequest 配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoordinatorsCoordinatorIdShippingsShippingIdPatch(coordinatorId: string, shippingId: string, typesUpdateShippingRequest: TypesUpdateShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1CoordinatorsCoordinatorIdShippingsShippingIdPatch(coordinatorId, shippingId, typesUpdateShippingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * デフォルトの配送設定を取得します。
         * @summary デフォルト配送設定取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShippingsDefaultGet(options?: RawAxiosRequestConfig): AxiosPromise<TypesShippingResponse> {
            return localVarFp.v1ShippingsDefaultGet(options).then((request) => request(axios, basePath));
        },
        /**
         * デフォルトの配送設定を更新します。
         * @summary デフォルト配送設定更新
         * @param {TypesUpdateDefaultShippingRequest} typesUpdateDefaultShippingRequest デフォルト配送設定情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShippingsDefaultPatch(typesUpdateDefaultShippingRequest: TypesUpdateDefaultShippingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ShippingsDefaultPatch(typesUpdateDefaultShippingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShippingApi - object-oriented interface
 * @export
 * @class ShippingApi
 * @extends {BaseAPI}
 */
export class ShippingApi extends BaseAPI {
    /**
     * Deprecated.指定されたコーディネーターのアクティブ配送設定を取得します。
     * @summary アクティブ配送設定取得
     * @param {string} coordinatorId コーディネーターID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsActivationGet(coordinatorId: string, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsActivationGet(coordinatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたコーディネーターの配送設定一覧を取得します。ページネーションに対応しています。
     * @summary 配送設定一覧取得
     * @param {string} coordinatorId コーディネーターID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsGet(coordinatorId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsGet(coordinatorId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecated.コーディネータの配送設定を更新します。
     * @summary 配送設定更新
     * @param {string} coordinatorId コーディネータID
     * @param {TypesUpsertShippingRequest} typesUpsertShippingRequest 配送設定情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsPatch(coordinatorId: string, typesUpsertShippingRequest: TypesUpsertShippingRequest, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsPatch(coordinatorId, typesUpsertShippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい配送設定を登録します。
     * @summary 配送設定登録
     * @param {string} coordinatorId コーディネーターID
     * @param {TypesCreateShippingRequest} typesCreateShippingRequest 配送設定情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsPost(coordinatorId: string, typesCreateShippingRequest: TypesCreateShippingRequest, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsPost(coordinatorId, typesCreateShippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した配送設定をアクティブに設定します。
     * @summary アクティブ配送設定更新
     * @param {string} coordinatorId コーディネーターID
     * @param {string} shippingId 配送設定ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsShippingIdActivationPatch(coordinatorId, shippingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 配送設定を削除します。
     * @summary 配送設定削除
     * @param {string} coordinatorId コーディネーターID
     * @param {string} shippingId 配送設定ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsShippingIdDelete(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsShippingIdDelete(coordinatorId, shippingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された配送設定の詳細情報を取得します。
     * @summary 配送設定取得
     * @param {string} coordinatorId コーディネーターID
     * @param {string} shippingId 配送設定ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsShippingIdGet(coordinatorId: string, shippingId: string, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsShippingIdGet(coordinatorId, shippingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 配送設定の情報を更新します。
     * @summary 配送設定更新
     * @param {string} coordinatorId コーディネーターID
     * @param {string} shippingId 配送設定ID
     * @param {TypesUpdateShippingRequest} typesUpdateShippingRequest 配送設定情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1CoordinatorsCoordinatorIdShippingsShippingIdPatch(coordinatorId: string, shippingId: string, typesUpdateShippingRequest: TypesUpdateShippingRequest, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1CoordinatorsCoordinatorIdShippingsShippingIdPatch(coordinatorId, shippingId, typesUpdateShippingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * デフォルトの配送設定を取得します。
     * @summary デフォルト配送設定取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1ShippingsDefaultGet(options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1ShippingsDefaultGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * デフォルトの配送設定を更新します。
     * @summary デフォルト配送設定更新
     * @param {TypesUpdateDefaultShippingRequest} typesUpdateDefaultShippingRequest デフォルト配送設定情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public v1ShippingsDefaultPatch(typesUpdateDefaultShippingRequest: TypesUpdateDefaultShippingRequest, options?: RawAxiosRequestConfig) {
        return ShippingApiFp(this.configuration).v1ShippingsDefaultPatch(typesUpdateDefaultShippingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShopApi - axios parameter creator
 * @export
 */
export const ShopApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたショップの詳細情報を取得します。コーディネーター、生産者、商品種別情報も含まれます。
         * @summary ショップ取得
         * @param {string} shopId ショップID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShopsShopIdGet: async (shopId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('v1ShopsShopIdGet', 'shopId', shopId)
            const localVarPath = `/v1/shops/{shopId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ショップの情報を更新します。ショップ名、商品種別、営業日を変更できます。
         * @summary ショップ更新
         * @param {string} shopId ショップID
         * @param {TypesUpdateShopRequest} typesUpdateShopRequest ショップ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShopsShopIdPatch: async (shopId: string, typesUpdateShopRequest: TypesUpdateShopRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopId' is not null or undefined
            assertParamExists('v1ShopsShopIdPatch', 'shopId', shopId)
            // verify required parameter 'typesUpdateShopRequest' is not null or undefined
            assertParamExists('v1ShopsShopIdPatch', 'typesUpdateShopRequest', typesUpdateShopRequest)
            const localVarPath = `/v1/shops/{shopId}`
                .replace(`{${"shopId"}}`, encodeURIComponent(String(shopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateShopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopApi - functional programming interface
 * @export
 */
export const ShopApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたショップの詳細情報を取得します。コーディネーター、生産者、商品種別情報も含まれます。
         * @summary ショップ取得
         * @param {string} shopId ショップID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ShopsShopIdGet(shopId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesShopResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ShopsShopIdGet(shopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.v1ShopsShopIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ショップの情報を更新します。ショップ名、商品種別、営業日を変更できます。
         * @summary ショップ更新
         * @param {string} shopId ショップID
         * @param {TypesUpdateShopRequest} typesUpdateShopRequest ショップ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ShopsShopIdPatch(shopId: string, typesUpdateShopRequest: TypesUpdateShopRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ShopsShopIdPatch(shopId, typesUpdateShopRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopApi.v1ShopsShopIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShopApi - factory interface
 * @export
 */
export const ShopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopApiFp(configuration)
    return {
        /**
         * 指定されたショップの詳細情報を取得します。コーディネーター、生産者、商品種別情報も含まれます。
         * @summary ショップ取得
         * @param {string} shopId ショップID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShopsShopIdGet(shopId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesShopResponse> {
            return localVarFp.v1ShopsShopIdGet(shopId, options).then((request) => request(axios, basePath));
        },
        /**
         * ショップの情報を更新します。ショップ名、商品種別、営業日を変更できます。
         * @summary ショップ更新
         * @param {string} shopId ショップID
         * @param {TypesUpdateShopRequest} typesUpdateShopRequest ショップ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ShopsShopIdPatch(shopId: string, typesUpdateShopRequest: TypesUpdateShopRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ShopsShopIdPatch(shopId, typesUpdateShopRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopApi - object-oriented interface
 * @export
 * @class ShopApi
 * @extends {BaseAPI}
 */
export class ShopApi extends BaseAPI {
    /**
     * 指定されたショップの詳細情報を取得します。コーディネーター、生産者、商品種別情報も含まれます。
     * @summary ショップ取得
     * @param {string} shopId ショップID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public v1ShopsShopIdGet(shopId: string, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).v1ShopsShopIdGet(shopId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ショップの情報を更新します。ショップ名、商品種別、営業日を変更できます。
     * @summary ショップ更新
     * @param {string} shopId ショップID
     * @param {TypesUpdateShopRequest} typesUpdateShopRequest ショップ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public v1ShopsShopIdPatch(shopId: string, typesUpdateShopRequest: TypesUpdateShopRequest, options?: RawAxiosRequestConfig) {
        return ShopApiFp(this.configuration).v1ShopsShopIdPatch(shopId, typesUpdateShopRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpotApi - axios parameter creator
 * @export
 */
export const SpotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * スポットの一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
         * @summary スポット一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] スポット名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsGet: async (limit?: number, offset?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/spots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいスポットを登録します。
         * @summary スポット登録
         * @param {CreateSpotRequest} createSpotRequest スポット情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsPost: async (createSpotRequest: CreateSpotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSpotRequest' is not null or undefined
            assertParamExists('v1SpotsPost', 'createSpotRequest', createSpotRequest)
            const localVarPath = `/v1/spots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSpotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スポットの承認状態を更新します。
         * @summary スポット承認
         * @param {string} spotId スポットID
         * @param {TypesApproveSpotRequest} typesApproveSpotRequest 承認情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdApprovalPatch: async (spotId: string, typesApproveSpotRequest: TypesApproveSpotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spotId' is not null or undefined
            assertParamExists('v1SpotsSpotIdApprovalPatch', 'spotId', spotId)
            // verify required parameter 'typesApproveSpotRequest' is not null or undefined
            assertParamExists('v1SpotsSpotIdApprovalPatch', 'typesApproveSpotRequest', typesApproveSpotRequest)
            const localVarPath = `/v1/spots/{spotId}/approval`
                .replace(`{${"spotId"}}`, encodeURIComponent(String(spotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesApproveSpotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スポットを削除します。
         * @summary スポット削除
         * @param {string} spotId スポットID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdDelete: async (spotId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spotId' is not null or undefined
            assertParamExists('v1SpotsSpotIdDelete', 'spotId', spotId)
            const localVarPath = `/v1/spots/{spotId}`
                .replace(`{${"spotId"}}`, encodeURIComponent(String(spotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたスポットの詳細情報を取得します。
         * @summary スポット取得
         * @param {string} spotId スポットID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdGet: async (spotId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spotId' is not null or undefined
            assertParamExists('v1SpotsSpotIdGet', 'spotId', spotId)
            const localVarPath = `/v1/spots/{spotId}`
                .replace(`{${"spotId"}}`, encodeURIComponent(String(spotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スポットの情報を更新します。
         * @summary スポット更新
         * @param {string} spotId スポットID
         * @param {UpdateSpotRequest} updateSpotRequest スポット情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdPatch: async (spotId: string, updateSpotRequest: UpdateSpotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spotId' is not null or undefined
            assertParamExists('v1SpotsSpotIdPatch', 'spotId', spotId)
            // verify required parameter 'updateSpotRequest' is not null or undefined
            assertParamExists('v1SpotsSpotIdPatch', 'updateSpotRequest', updateSpotRequest)
            const localVarPath = `/v1/spots/{spotId}`
                .replace(`{${"spotId"}}`, encodeURIComponent(String(spotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSpotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpotApi - functional programming interface
 * @export
 */
export const SpotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpotApiAxiosParamCreator(configuration)
    return {
        /**
         * スポットの一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
         * @summary スポット一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] スポット名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotsGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotsGet(limit, offset, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotApi.v1SpotsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいスポットを登録します。
         * @summary スポット登録
         * @param {CreateSpotRequest} createSpotRequest スポット情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotsPost(createSpotRequest: CreateSpotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotsPost(createSpotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotApi.v1SpotsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スポットの承認状態を更新します。
         * @summary スポット承認
         * @param {string} spotId スポットID
         * @param {TypesApproveSpotRequest} typesApproveSpotRequest 承認情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotsSpotIdApprovalPatch(spotId: string, typesApproveSpotRequest: TypesApproveSpotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotsSpotIdApprovalPatch(spotId, typesApproveSpotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotApi.v1SpotsSpotIdApprovalPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スポットを削除します。
         * @summary スポット削除
         * @param {string} spotId スポットID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotsSpotIdDelete(spotId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotsSpotIdDelete(spotId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotApi.v1SpotsSpotIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたスポットの詳細情報を取得します。
         * @summary スポット取得
         * @param {string} spotId スポットID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotsSpotIdGet(spotId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotsSpotIdGet(spotId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotApi.v1SpotsSpotIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スポットの情報を更新します。
         * @summary スポット更新
         * @param {string} spotId スポットID
         * @param {UpdateSpotRequest} updateSpotRequest スポット情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotsSpotIdPatch(spotId: string, updateSpotRequest: UpdateSpotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotsSpotIdPatch(spotId, updateSpotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotApi.v1SpotsSpotIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpotApi - factory interface
 * @export
 */
export const SpotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpotApiFp(configuration)
    return {
        /**
         * スポットの一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
         * @summary スポット一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] スポット名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<SpotsResponse> {
            return localVarFp.v1SpotsGet(limit, offset, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいスポットを登録します。
         * @summary スポット登録
         * @param {CreateSpotRequest} createSpotRequest スポット情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsPost(createSpotRequest: CreateSpotRequest, options?: RawAxiosRequestConfig): AxiosPromise<SpotResponse> {
            return localVarFp.v1SpotsPost(createSpotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スポットの承認状態を更新します。
         * @summary スポット承認
         * @param {string} spotId スポットID
         * @param {TypesApproveSpotRequest} typesApproveSpotRequest 承認情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdApprovalPatch(spotId: string, typesApproveSpotRequest: TypesApproveSpotRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SpotsSpotIdApprovalPatch(spotId, typesApproveSpotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スポットを削除します。
         * @summary スポット削除
         * @param {string} spotId スポットID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdDelete(spotId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SpotsSpotIdDelete(spotId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたスポットの詳細情報を取得します。
         * @summary スポット取得
         * @param {string} spotId スポットID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdGet(spotId: string, options?: RawAxiosRequestConfig): AxiosPromise<SpotResponse> {
            return localVarFp.v1SpotsSpotIdGet(spotId, options).then((request) => request(axios, basePath));
        },
        /**
         * スポットの情報を更新します。
         * @summary スポット更新
         * @param {string} spotId スポットID
         * @param {UpdateSpotRequest} updateSpotRequest スポット情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotsSpotIdPatch(spotId: string, updateSpotRequest: UpdateSpotRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SpotsSpotIdPatch(spotId, updateSpotRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpotApi - object-oriented interface
 * @export
 * @class SpotApi
 * @extends {BaseAPI}
 */
export class SpotApi extends BaseAPI {
    /**
     * スポットの一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
     * @summary スポット一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] スポット名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public v1SpotsGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig) {
        return SpotApiFp(this.configuration).v1SpotsGet(limit, offset, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいスポットを登録します。
     * @summary スポット登録
     * @param {CreateSpotRequest} createSpotRequest スポット情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public v1SpotsPost(createSpotRequest: CreateSpotRequest, options?: RawAxiosRequestConfig) {
        return SpotApiFp(this.configuration).v1SpotsPost(createSpotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スポットの承認状態を更新します。
     * @summary スポット承認
     * @param {string} spotId スポットID
     * @param {TypesApproveSpotRequest} typesApproveSpotRequest 承認情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public v1SpotsSpotIdApprovalPatch(spotId: string, typesApproveSpotRequest: TypesApproveSpotRequest, options?: RawAxiosRequestConfig) {
        return SpotApiFp(this.configuration).v1SpotsSpotIdApprovalPatch(spotId, typesApproveSpotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スポットを削除します。
     * @summary スポット削除
     * @param {string} spotId スポットID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public v1SpotsSpotIdDelete(spotId: string, options?: RawAxiosRequestConfig) {
        return SpotApiFp(this.configuration).v1SpotsSpotIdDelete(spotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたスポットの詳細情報を取得します。
     * @summary スポット取得
     * @param {string} spotId スポットID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public v1SpotsSpotIdGet(spotId: string, options?: RawAxiosRequestConfig) {
        return SpotApiFp(this.configuration).v1SpotsSpotIdGet(spotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スポットの情報を更新します。
     * @summary スポット更新
     * @param {string} spotId スポットID
     * @param {UpdateSpotRequest} updateSpotRequest スポット情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotApi
     */
    public v1SpotsSpotIdPatch(spotId: string, updateSpotRequest: UpdateSpotRequest, options?: RawAxiosRequestConfig) {
        return SpotApiFp(this.configuration).v1SpotsSpotIdPatch(spotId, updateSpotRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpotTypeApi - axios parameter creator
 * @export
 */
export const SpotTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * スポットタイプの一覧を取得します。名前でのフィルタリングが可能です。
         * @summary スポットタイプ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] スポットタイプ名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesGet: async (limit?: number, offset?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/spot-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいスポットタイプを登録します。
         * @summary スポットタイプ登録
         * @param {TypesCreateSpotTypeRequest} typesCreateSpotTypeRequest スポットタイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesPost: async (typesCreateSpotTypeRequest: TypesCreateSpotTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateSpotTypeRequest' is not null or undefined
            assertParamExists('v1SpotTypesPost', 'typesCreateSpotTypeRequest', typesCreateSpotTypeRequest)
            const localVarPath = `/v1/spot-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateSpotTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スポットタイプを削除します。
         * @summary スポットタイプ削除
         * @param {string} spotTypeId スポットタイプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesSpotTypeIdDelete: async (spotTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spotTypeId' is not null or undefined
            assertParamExists('v1SpotTypesSpotTypeIdDelete', 'spotTypeId', spotTypeId)
            const localVarPath = `/v1/spot-types/{spotTypeId}`
                .replace(`{${"spotTypeId"}}`, encodeURIComponent(String(spotTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スポットタイプの情報を更新します。
         * @summary スポットタイプ更新
         * @param {string} spotTypeId スポットタイプID
         * @param {TypesUpdateSpotTypeRequest} typesUpdateSpotTypeRequest スポットタイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesSpotTypeIdPatch: async (spotTypeId: string, typesUpdateSpotTypeRequest: TypesUpdateSpotTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spotTypeId' is not null or undefined
            assertParamExists('v1SpotTypesSpotTypeIdPatch', 'spotTypeId', spotTypeId)
            // verify required parameter 'typesUpdateSpotTypeRequest' is not null or undefined
            assertParamExists('v1SpotTypesSpotTypeIdPatch', 'typesUpdateSpotTypeRequest', typesUpdateSpotTypeRequest)
            const localVarPath = `/v1/spot-types/{spotTypeId}`
                .replace(`{${"spotTypeId"}}`, encodeURIComponent(String(spotTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateSpotTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpotTypeApi - functional programming interface
 * @export
 */
export const SpotTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpotTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * スポットタイプの一覧を取得します。名前でのフィルタリングが可能です。
         * @summary スポットタイプ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] スポットタイプ名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotTypesGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpotTypesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotTypesGet(limit, offset, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTypeApi.v1SpotTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいスポットタイプを登録します。
         * @summary スポットタイプ登録
         * @param {TypesCreateSpotTypeRequest} typesCreateSpotTypeRequest スポットタイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotTypesPost(typesCreateSpotTypeRequest: TypesCreateSpotTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesSpotTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotTypesPost(typesCreateSpotTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTypeApi.v1SpotTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スポットタイプを削除します。
         * @summary スポットタイプ削除
         * @param {string} spotTypeId スポットタイプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotTypesSpotTypeIdDelete(spotTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotTypesSpotTypeIdDelete(spotTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTypeApi.v1SpotTypesSpotTypeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スポットタイプの情報を更新します。
         * @summary スポットタイプ更新
         * @param {string} spotTypeId スポットタイプID
         * @param {TypesUpdateSpotTypeRequest} typesUpdateSpotTypeRequest スポットタイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SpotTypesSpotTypeIdPatch(spotTypeId: string, typesUpdateSpotTypeRequest: TypesUpdateSpotTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SpotTypesSpotTypeIdPatch(spotTypeId, typesUpdateSpotTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpotTypeApi.v1SpotTypesSpotTypeIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpotTypeApi - factory interface
 * @export
 */
export const SpotTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpotTypeApiFp(configuration)
    return {
        /**
         * スポットタイプの一覧を取得します。名前でのフィルタリングが可能です。
         * @summary スポットタイプ一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] スポットタイプ名(あいまい検索)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<SpotTypesResponse> {
            return localVarFp.v1SpotTypesGet(limit, offset, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいスポットタイプを登録します。
         * @summary スポットタイプ登録
         * @param {TypesCreateSpotTypeRequest} typesCreateSpotTypeRequest スポットタイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesPost(typesCreateSpotTypeRequest: TypesCreateSpotTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesSpotTypeResponse> {
            return localVarFp.v1SpotTypesPost(typesCreateSpotTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スポットタイプを削除します。
         * @summary スポットタイプ削除
         * @param {string} spotTypeId スポットタイプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesSpotTypeIdDelete(spotTypeId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SpotTypesSpotTypeIdDelete(spotTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * スポットタイプの情報を更新します。
         * @summary スポットタイプ更新
         * @param {string} spotTypeId スポットタイプID
         * @param {TypesUpdateSpotTypeRequest} typesUpdateSpotTypeRequest スポットタイプ情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SpotTypesSpotTypeIdPatch(spotTypeId: string, typesUpdateSpotTypeRequest: TypesUpdateSpotTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1SpotTypesSpotTypeIdPatch(spotTypeId, typesUpdateSpotTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpotTypeApi - object-oriented interface
 * @export
 * @class SpotTypeApi
 * @extends {BaseAPI}
 */
export class SpotTypeApi extends BaseAPI {
    /**
     * スポットタイプの一覧を取得します。名前でのフィルタリングが可能です。
     * @summary スポットタイプ一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] スポットタイプ名(あいまい検索)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTypeApi
     */
    public v1SpotTypesGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig) {
        return SpotTypeApiFp(this.configuration).v1SpotTypesGet(limit, offset, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいスポットタイプを登録します。
     * @summary スポットタイプ登録
     * @param {TypesCreateSpotTypeRequest} typesCreateSpotTypeRequest スポットタイプ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTypeApi
     */
    public v1SpotTypesPost(typesCreateSpotTypeRequest: TypesCreateSpotTypeRequest, options?: RawAxiosRequestConfig) {
        return SpotTypeApiFp(this.configuration).v1SpotTypesPost(typesCreateSpotTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スポットタイプを削除します。
     * @summary スポットタイプ削除
     * @param {string} spotTypeId スポットタイプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTypeApi
     */
    public v1SpotTypesSpotTypeIdDelete(spotTypeId: string, options?: RawAxiosRequestConfig) {
        return SpotTypeApiFp(this.configuration).v1SpotTypesSpotTypeIdDelete(spotTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スポットタイプの情報を更新します。
     * @summary スポットタイプ更新
     * @param {string} spotTypeId スポットタイプID
     * @param {TypesUpdateSpotTypeRequest} typesUpdateSpotTypeRequest スポットタイプ情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotTypeApi
     */
    public v1SpotTypesSpotTypeIdPatch(spotTypeId: string, typesUpdateSpotTypeRequest: TypesUpdateSpotTypeRequest, options?: RawAxiosRequestConfig) {
        return SpotTypeApiFp(this.configuration).v1SpotTypesSpotTypeIdPatch(spotTypeId, typesUpdateSpotTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThreadApi - axios parameter creator
 * @export
 */
export const ThreadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定されたお問い合わせのスレッド一覧を取得します。
         * @summary お問い合わせスレッド一覧取得
         * @param {string} contactId お問い合わせID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsGet: async (contactId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsGet', 'contactId', contactId)
            const localVarPath = `/v1/contacts/{contactId}/threads`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいスレッドを登録します。
         * @summary スレッド登録
         * @param {string} contactId お問い合わせID
         * @param {TypesCreateThreadRequest} typesCreateThreadRequest スレッド情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsPost: async (contactId: string, typesCreateThreadRequest: TypesCreateThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsPost', 'contactId', contactId)
            // verify required parameter 'typesCreateThreadRequest' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsPost', 'typesCreateThreadRequest', typesCreateThreadRequest)
            const localVarPath = `/v1/contacts/{contactId}/threads`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スレッドを削除します。
         * @summary スレッド削除
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsThreadIdDelete: async (contactId: string, threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdDelete', 'contactId', contactId)
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdDelete', 'threadId', threadId)
            const localVarPath = `/v1/contacts/{contactId}/threads/{threadId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)))
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたスレッドの詳細情報を取得します。
         * @summary スレッド取得
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsThreadIdGet: async (contactId: string, threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdGet', 'contactId', contactId)
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdGet', 'threadId', threadId)
            const localVarPath = `/v1/contacts/{contactId}/threads/{threadId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)))
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スレッドの情報を更新します。
         * @summary スレッド更新
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {TypesUpdateThreadRequest} typesUpdateThreadRequest スレッド情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsThreadIdPatch: async (contactId: string, threadId: string, typesUpdateThreadRequest: TypesUpdateThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdPatch', 'contactId', contactId)
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdPatch', 'threadId', threadId)
            // verify required parameter 'typesUpdateThreadRequest' is not null or undefined
            assertParamExists('v1ContactsContactIdThreadsThreadIdPatch', 'typesUpdateThreadRequest', typesUpdateThreadRequest)
            const localVarPath = `/v1/contacts/{contactId}/threads/{threadId}`
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)))
                .replace(`{${"threadId"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThreadApi - functional programming interface
 * @export
 */
export const ThreadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThreadApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定されたお問い合わせのスレッド一覧を取得します。
         * @summary お問い合わせスレッド一覧取得
         * @param {string} contactId お問い合わせID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdThreadsGet(contactId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdThreadsGet(contactId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1ContactsContactIdThreadsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいスレッドを登録します。
         * @summary スレッド登録
         * @param {string} contactId お問い合わせID
         * @param {TypesCreateThreadRequest} typesCreateThreadRequest スレッド情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdThreadsPost(contactId: string, typesCreateThreadRequest: TypesCreateThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdThreadsPost(contactId, typesCreateThreadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1ContactsContactIdThreadsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スレッドを削除します。
         * @summary スレッド削除
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdThreadsThreadIdDelete(contactId: string, threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdThreadsThreadIdDelete(contactId, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1ContactsContactIdThreadsThreadIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたスレッドの詳細情報を取得します。
         * @summary スレッド取得
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdThreadsThreadIdGet(contactId: string, threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdThreadsThreadIdGet(contactId, threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1ContactsContactIdThreadsThreadIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スレッドの情報を更新します。
         * @summary スレッド更新
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {TypesUpdateThreadRequest} typesUpdateThreadRequest スレッド情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ContactsContactIdThreadsThreadIdPatch(contactId: string, threadId: string, typesUpdateThreadRequest: TypesUpdateThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ContactsContactIdThreadsThreadIdPatch(contactId, threadId, typesUpdateThreadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThreadApi.v1ContactsContactIdThreadsThreadIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThreadApi - factory interface
 * @export
 */
export const ThreadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThreadApiFp(configuration)
    return {
        /**
         * 指定されたお問い合わせのスレッド一覧を取得します。
         * @summary お問い合わせスレッド一覧取得
         * @param {string} contactId お問い合わせID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsGet(contactId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesThreadsResponse> {
            return localVarFp.v1ContactsContactIdThreadsGet(contactId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいスレッドを登録します。
         * @summary スレッド登録
         * @param {string} contactId お問い合わせID
         * @param {TypesCreateThreadRequest} typesCreateThreadRequest スレッド情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsPost(contactId: string, typesCreateThreadRequest: TypesCreateThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<TypesThreadResponse> {
            return localVarFp.v1ContactsContactIdThreadsPost(contactId, typesCreateThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スレッドを削除します。
         * @summary スレッド削除
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsThreadIdDelete(contactId: string, threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ContactsContactIdThreadsThreadIdDelete(contactId, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたスレッドの詳細情報を取得します。
         * @summary スレッド取得
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsThreadIdGet(contactId: string, threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesThreadResponse> {
            return localVarFp.v1ContactsContactIdThreadsThreadIdGet(contactId, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * スレッドの情報を更新します。
         * @summary スレッド更新
         * @param {string} contactId お問い合わせID
         * @param {string} threadId スレッドID
         * @param {TypesUpdateThreadRequest} typesUpdateThreadRequest スレッド情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ContactsContactIdThreadsThreadIdPatch(contactId: string, threadId: string, typesUpdateThreadRequest: TypesUpdateThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1ContactsContactIdThreadsThreadIdPatch(contactId, threadId, typesUpdateThreadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThreadApi - object-oriented interface
 * @export
 * @class ThreadApi
 * @extends {BaseAPI}
 */
export class ThreadApi extends BaseAPI {
    /**
     * 指定されたお問い合わせのスレッド一覧を取得します。
     * @summary お問い合わせスレッド一覧取得
     * @param {string} contactId お問い合わせID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1ContactsContactIdThreadsGet(contactId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1ContactsContactIdThreadsGet(contactId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいスレッドを登録します。
     * @summary スレッド登録
     * @param {string} contactId お問い合わせID
     * @param {TypesCreateThreadRequest} typesCreateThreadRequest スレッド情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1ContactsContactIdThreadsPost(contactId: string, typesCreateThreadRequest: TypesCreateThreadRequest, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1ContactsContactIdThreadsPost(contactId, typesCreateThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スレッドを削除します。
     * @summary スレッド削除
     * @param {string} contactId お問い合わせID
     * @param {string} threadId スレッドID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1ContactsContactIdThreadsThreadIdDelete(contactId: string, threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1ContactsContactIdThreadsThreadIdDelete(contactId, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたスレッドの詳細情報を取得します。
     * @summary スレッド取得
     * @param {string} contactId お問い合わせID
     * @param {string} threadId スレッドID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1ContactsContactIdThreadsThreadIdGet(contactId: string, threadId: string, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1ContactsContactIdThreadsThreadIdGet(contactId, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スレッドの情報を更新します。
     * @summary スレッド更新
     * @param {string} contactId お問い合わせID
     * @param {string} threadId スレッドID
     * @param {TypesUpdateThreadRequest} typesUpdateThreadRequest スレッド情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThreadApi
     */
    public v1ContactsContactIdThreadsThreadIdPatch(contactId: string, threadId: string, typesUpdateThreadRequest: TypesUpdateThreadRequest, options?: RawAxiosRequestConfig) {
        return ThreadApiFp(this.configuration).v1ContactsContactIdThreadsThreadIdPatch(contactId, threadId, typesUpdateThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopApi - axios parameter creator
 * @export
 */
export const TopApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定期間の注文統計情報（注文数、売上、決済手段別集計、推移）を取得します。
         * @summary 注文集計取得
         * @param {number} [startAt] 集計開始日時（unixtime,未指定の場合は１週間前の時刻）
         * @param {number} [endAt] 集計終了日時（unixtime,未指定の場合は現在時刻）
         * @param {string} [periodType] 集計期間（未指定の場合は日次）
         * @param {string} [shopId] 店舗ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TopOrdersGet: async (startAt?: number, endAt?: number, periodType?: string, shopId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/top/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startAt !== undefined) {
                localVarQueryParameter['startAt'] = startAt;
            }

            if (endAt !== undefined) {
                localVarQueryParameter['endAt'] = endAt;
            }

            if (periodType !== undefined) {
                localVarQueryParameter['periodType'] = periodType;
            }

            if (shopId !== undefined) {
                localVarQueryParameter['shopId'] = shopId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopApi - functional programming interface
 * @export
 */
export const TopApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定期間の注文統計情報（注文数、売上、決済手段別集計、推移）を取得します。
         * @summary 注文集計取得
         * @param {number} [startAt] 集計開始日時（unixtime,未指定の場合は１週間前の時刻）
         * @param {number} [endAt] 集計終了日時（unixtime,未指定の場合は現在時刻）
         * @param {string} [periodType] 集計期間（未指定の場合は日次）
         * @param {string} [shopId] 店舗ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1TopOrdersGet(startAt?: number, endAt?: number, periodType?: string, shopId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesTopOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1TopOrdersGet(startAt, endAt, periodType, shopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopApi.v1TopOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopApi - factory interface
 * @export
 */
export const TopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopApiFp(configuration)
    return {
        /**
         * 指定期間の注文統計情報（注文数、売上、決済手段別集計、推移）を取得します。
         * @summary 注文集計取得
         * @param {number} [startAt] 集計開始日時（unixtime,未指定の場合は１週間前の時刻）
         * @param {number} [endAt] 集計終了日時（unixtime,未指定の場合は現在時刻）
         * @param {string} [periodType] 集計期間（未指定の場合は日次）
         * @param {string} [shopId] 店舗ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1TopOrdersGet(startAt?: number, endAt?: number, periodType?: string, shopId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesTopOrdersResponse> {
            return localVarFp.v1TopOrdersGet(startAt, endAt, periodType, shopId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopApi - object-oriented interface
 * @export
 * @class TopApi
 * @extends {BaseAPI}
 */
export class TopApi extends BaseAPI {
    /**
     * 指定期間の注文統計情報（注文数、売上、決済手段別集計、推移）を取得します。
     * @summary 注文集計取得
     * @param {number} [startAt] 集計開始日時（unixtime,未指定の場合は１週間前の時刻）
     * @param {number} [endAt] 集計終了日時（unixtime,未指定の場合は現在時刻）
     * @param {string} [periodType] 集計期間（未指定の場合は日次）
     * @param {string} [shopId] 店舗ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopApi
     */
    public v1TopOrdersGet(startAt?: number, endAt?: number, periodType?: string, shopId?: string, options?: RawAxiosRequestConfig) {
        return TopApiFp(this.configuration).v1TopOrdersGet(startAt, endAt, periodType, shopId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * コーディネーターの特典動画アップロードURLを生成します。
         * @summary コーディネーター特典動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsBonusVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadCoordinatorsBonusVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/coordinators/bonus-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * コーディネーターのヘッダー画像アップロードURLを生成します。
         * @summary コーディネーターヘッダーアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsHeaderPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadCoordinatorsHeaderPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/coordinators/header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * コーディネーターのプロモーション動画アップロードURLを生成します。
         * @summary コーディネータープロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsPromotionVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadCoordinatorsPromotionVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/coordinators/promotion-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * コーディネーターのサムネイル画像アップロードURLを生成します。
         * @summary コーディネーターサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsThumbnailPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadCoordinatorsThumbnailPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/coordinators/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験の画像アップロードURLを生成します。
         * @summary 体験画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadExperiencesImagePost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadExperiencesImagePost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/experiences/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験のプロモーション動画アップロードURLを生成します。
         * @summary 体験プロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadExperiencesPromotionVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadExperiencesPromotionVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/experiences/promotion-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 体験の動画アップロードURLを生成します。
         * @summary 体験動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadExperiencesVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadExperiencesVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/experiences/video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 生産者の特典動画アップロードURLを生成します。
         * @summary 生産者特典動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersBonusVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProducersBonusVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/producers/bonus-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 生産者のヘッダー画像アップロードURLを生成します。
         * @summary 生産者ヘッダーアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersHeaderPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProducersHeaderPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/producers/header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 生産者のプロモーション動画アップロードURLを生成します。
         * @summary 生産者プロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersPromotionVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProducersPromotionVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/producers/promotion-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 生産者のサムネイル画像アップロードURLを生成します。
         * @summary 生産者サムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersThumbnailPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProducersThumbnailPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/producers/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品種別のアイコンアップロードURLを生成します。
         * @summary 商品種別アイコンアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProductTypesIconPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProductTypesIconPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/product-types/icon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品の画像アップロードURLを生成します。
         * @summary 商品画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProductsImagePost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProductsImagePost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/products/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 商品の動画アップロードURLを生成します。
         * @summary 商品動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProductsVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadProductsVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/products/video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ライブ配信動画のアップロードURLを生成します。
         * @summary ライブ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesBroadcastsLivePost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadSchedulesBroadcastsLivePost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/schedules/-/broadcasts/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スケジュールの画像アップロードURLを生成します。
         * @summary スケジュール画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesImagePost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadSchedulesImagePost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/schedules/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スケジュールのオープニング動画アップロードURLを生成します。
         * @summary スケジュールオープニング動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesOpeningVideoPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadSchedulesOpeningVideoPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/schedules/opening-video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたスケジュールのアーカイブ動画アップロードURLを生成します。
         * @summary アーカイブ動画アップロードURL生成
         * @param {string} scheduleId スケジュールID
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesScheduleIdBroadcastsArchivePost: async (scheduleId: string, getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('v1UploadSchedulesScheduleIdBroadcastsArchivePost', 'scheduleId', scheduleId)
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadSchedulesScheduleIdBroadcastsArchivePost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/schedules/{scheduleId}/broadcasts/archive`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スケジュールのサムネイルアップロードURLを生成します。
         * @summary スケジュールサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesThumbnailPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadSchedulesThumbnailPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/schedules/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スポットのサムネイルアップロードURLを生成します。
         * @summary スポットサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSpotsThumbnailPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadSpotsThumbnailPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/spots/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたキーのアップロード状態を取得します。
         * @summary アップロード状態取得
         * @param {string} key アップロードキー
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadStateGet: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('v1UploadStateGet', 'key', key)
            const localVarPath = `/v1/upload/state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 動画ファイルのアップロードURLを生成します。
         * @summary 動画ファイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadVideosFilePost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadVideosFilePost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/videos/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 動画のサムネイルアップロードURLを生成します。
         * @summary 動画サムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadVideosThumbnailPost: async (getUploadURLRequest: GetUploadURLRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getUploadURLRequest' is not null or undefined
            assertParamExists('v1UploadVideosThumbnailPost', 'getUploadURLRequest', getUploadURLRequest)
            const localVarPath = `/v1/upload/videos/thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getUploadURLRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * コーディネーターの特典動画アップロードURLを生成します。
         * @summary コーディネーター特典動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadCoordinatorsBonusVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadCoordinatorsBonusVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadCoordinatorsBonusVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * コーディネーターのヘッダー画像アップロードURLを生成します。
         * @summary コーディネーターヘッダーアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadCoordinatorsHeaderPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadCoordinatorsHeaderPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadCoordinatorsHeaderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * コーディネーターのプロモーション動画アップロードURLを生成します。
         * @summary コーディネータープロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadCoordinatorsPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadCoordinatorsPromotionVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadCoordinatorsPromotionVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * コーディネーターのサムネイル画像アップロードURLを生成します。
         * @summary コーディネーターサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadCoordinatorsThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadCoordinatorsThumbnailPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadCoordinatorsThumbnailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験の画像アップロードURLを生成します。
         * @summary 体験画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadExperiencesImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadExperiencesImagePost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadExperiencesImagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験のプロモーション動画アップロードURLを生成します。
         * @summary 体験プロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadExperiencesPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadExperiencesPromotionVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadExperiencesPromotionVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 体験の動画アップロードURLを生成します。
         * @summary 体験動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadExperiencesVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadExperiencesVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadExperiencesVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 生産者の特典動画アップロードURLを生成します。
         * @summary 生産者特典動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProducersBonusVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProducersBonusVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProducersBonusVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 生産者のヘッダー画像アップロードURLを生成します。
         * @summary 生産者ヘッダーアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProducersHeaderPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProducersHeaderPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProducersHeaderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 生産者のプロモーション動画アップロードURLを生成します。
         * @summary 生産者プロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProducersPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProducersPromotionVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProducersPromotionVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 生産者のサムネイル画像アップロードURLを生成します。
         * @summary 生産者サムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProducersThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProducersThumbnailPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProducersThumbnailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品種別のアイコンアップロードURLを生成します。
         * @summary 商品種別アイコンアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProductTypesIconPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProductTypesIconPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProductTypesIconPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品の画像アップロードURLを生成します。
         * @summary 商品画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProductsImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProductsImagePost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProductsImagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 商品の動画アップロードURLを生成します。
         * @summary 商品動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadProductsVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadProductsVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadProductsVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ライブ配信動画のアップロードURLを生成します。
         * @summary ライブ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadSchedulesBroadcastsLivePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadSchedulesBroadcastsLivePost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadSchedulesBroadcastsLivePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スケジュールの画像アップロードURLを生成します。
         * @summary スケジュール画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadSchedulesImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadSchedulesImagePost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadSchedulesImagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スケジュールのオープニング動画アップロードURLを生成します。
         * @summary スケジュールオープニング動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadSchedulesOpeningVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadSchedulesOpeningVideoPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadSchedulesOpeningVideoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたスケジュールのアーカイブ動画アップロードURLを生成します。
         * @summary アーカイブ動画アップロードURL生成
         * @param {string} scheduleId スケジュールID
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadSchedulesScheduleIdBroadcastsArchivePost(scheduleId: string, getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadSchedulesScheduleIdBroadcastsArchivePost(scheduleId, getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadSchedulesScheduleIdBroadcastsArchivePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スケジュールのサムネイルアップロードURLを生成します。
         * @summary スケジュールサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadSchedulesThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadSchedulesThumbnailPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadSchedulesThumbnailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * スポットのサムネイルアップロードURLを生成します。
         * @summary スポットサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadSpotsThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadSpotsThumbnailPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadSpotsThumbnailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたキーのアップロード状態を取得します。
         * @summary アップロード状態取得
         * @param {string} key アップロードキー
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadStateGet(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadStateGet(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadStateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 動画ファイルのアップロードURLを生成します。
         * @summary 動画ファイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadVideosFilePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadVideosFilePost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadVideosFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 動画のサムネイルアップロードURLを生成します。
         * @summary 動画サムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UploadVideosThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UploadVideosThumbnailPost(getUploadURLRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.v1UploadVideosThumbnailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * コーディネーターの特典動画アップロードURLを生成します。
         * @summary コーディネーター特典動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsBonusVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadCoordinatorsBonusVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * コーディネーターのヘッダー画像アップロードURLを生成します。
         * @summary コーディネーターヘッダーアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsHeaderPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadCoordinatorsHeaderPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * コーディネーターのプロモーション動画アップロードURLを生成します。
         * @summary コーディネータープロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadCoordinatorsPromotionVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * コーディネーターのサムネイル画像アップロードURLを生成します。
         * @summary コーディネーターサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadCoordinatorsThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadCoordinatorsThumbnailPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験の画像アップロードURLを生成します。
         * @summary 体験画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadExperiencesImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadExperiencesImagePost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験のプロモーション動画アップロードURLを生成します。
         * @summary 体験プロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadExperiencesPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadExperiencesPromotionVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 体験の動画アップロードURLを生成します。
         * @summary 体験動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadExperiencesVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadExperiencesVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 生産者の特典動画アップロードURLを生成します。
         * @summary 生産者特典動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersBonusVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProducersBonusVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 生産者のヘッダー画像アップロードURLを生成します。
         * @summary 生産者ヘッダーアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersHeaderPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProducersHeaderPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 生産者のプロモーション動画アップロードURLを生成します。
         * @summary 生産者プロモ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProducersPromotionVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 生産者のサムネイル画像アップロードURLを生成します。
         * @summary 生産者サムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProducersThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProducersThumbnailPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品種別のアイコンアップロードURLを生成します。
         * @summary 商品種別アイコンアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProductTypesIconPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProductTypesIconPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品の画像アップロードURLを生成します。
         * @summary 商品画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProductsImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProductsImagePost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 商品の動画アップロードURLを生成します。
         * @summary 商品動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadProductsVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadProductsVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ライブ配信動画のアップロードURLを生成します。
         * @summary ライブ動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesBroadcastsLivePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadSchedulesBroadcastsLivePost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スケジュールの画像アップロードURLを生成します。
         * @summary スケジュール画像アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadSchedulesImagePost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スケジュールのオープニング動画アップロードURLを生成します。
         * @summary スケジュールオープニング動画アップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesOpeningVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadSchedulesOpeningVideoPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたスケジュールのアーカイブ動画アップロードURLを生成します。
         * @summary アーカイブ動画アップロードURL生成
         * @param {string} scheduleId スケジュールID
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesScheduleIdBroadcastsArchivePost(scheduleId: string, getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadSchedulesScheduleIdBroadcastsArchivePost(scheduleId, getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スケジュールのサムネイルアップロードURLを生成します。
         * @summary スケジュールサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSchedulesThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadSchedulesThumbnailPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * スポットのサムネイルアップロードURLを生成します。
         * @summary スポットサムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadSpotsThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadSpotsThumbnailPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたキーのアップロード状態を取得します。
         * @summary アップロード状態取得
         * @param {string} key アップロードキー
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadStateGet(key: string, options?: RawAxiosRequestConfig): AxiosPromise<UploadStateResponse> {
            return localVarFp.v1UploadStateGet(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 動画ファイルのアップロードURLを生成します。
         * @summary 動画ファイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadVideosFilePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadVideosFilePost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 動画のサムネイルアップロードURLを生成します。
         * @summary 動画サムネイルアップロードURL生成
         * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UploadVideosThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadURLResponse> {
            return localVarFp.v1UploadVideosThumbnailPost(getUploadURLRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * コーディネーターの特典動画アップロードURLを生成します。
     * @summary コーディネーター特典動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadCoordinatorsBonusVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadCoordinatorsBonusVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * コーディネーターのヘッダー画像アップロードURLを生成します。
     * @summary コーディネーターヘッダーアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadCoordinatorsHeaderPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadCoordinatorsHeaderPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * コーディネーターのプロモーション動画アップロードURLを生成します。
     * @summary コーディネータープロモ動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadCoordinatorsPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadCoordinatorsPromotionVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * コーディネーターのサムネイル画像アップロードURLを生成します。
     * @summary コーディネーターサムネイルアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadCoordinatorsThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadCoordinatorsThumbnailPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験の画像アップロードURLを生成します。
     * @summary 体験画像アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadExperiencesImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadExperiencesImagePost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験のプロモーション動画アップロードURLを生成します。
     * @summary 体験プロモ動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadExperiencesPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadExperiencesPromotionVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 体験の動画アップロードURLを生成します。
     * @summary 体験動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadExperiencesVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadExperiencesVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 生産者の特典動画アップロードURLを生成します。
     * @summary 生産者特典動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProducersBonusVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProducersBonusVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 生産者のヘッダー画像アップロードURLを生成します。
     * @summary 生産者ヘッダーアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProducersHeaderPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProducersHeaderPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 生産者のプロモーション動画アップロードURLを生成します。
     * @summary 生産者プロモ動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProducersPromotionVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProducersPromotionVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 生産者のサムネイル画像アップロードURLを生成します。
     * @summary 生産者サムネイルアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProducersThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProducersThumbnailPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品種別のアイコンアップロードURLを生成します。
     * @summary 商品種別アイコンアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProductTypesIconPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProductTypesIconPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品の画像アップロードURLを生成します。
     * @summary 商品画像アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProductsImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProductsImagePost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 商品の動画アップロードURLを生成します。
     * @summary 商品動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadProductsVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadProductsVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ライブ配信動画のアップロードURLを生成します。
     * @summary ライブ動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadSchedulesBroadcastsLivePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadSchedulesBroadcastsLivePost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スケジュールの画像アップロードURLを生成します。
     * @summary スケジュール画像アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadSchedulesImagePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadSchedulesImagePost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スケジュールのオープニング動画アップロードURLを生成します。
     * @summary スケジュールオープニング動画アップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadSchedulesOpeningVideoPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadSchedulesOpeningVideoPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたスケジュールのアーカイブ動画アップロードURLを生成します。
     * @summary アーカイブ動画アップロードURL生成
     * @param {string} scheduleId スケジュールID
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadSchedulesScheduleIdBroadcastsArchivePost(scheduleId: string, getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadSchedulesScheduleIdBroadcastsArchivePost(scheduleId, getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スケジュールのサムネイルアップロードURLを生成します。
     * @summary スケジュールサムネイルアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadSchedulesThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadSchedulesThumbnailPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * スポットのサムネイルアップロードURLを生成します。
     * @summary スポットサムネイルアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadSpotsThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadSpotsThumbnailPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたキーのアップロード状態を取得します。
     * @summary アップロード状態取得
     * @param {string} key アップロードキー
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadStateGet(key: string, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadStateGet(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 動画ファイルのアップロードURLを生成します。
     * @summary 動画ファイルアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadVideosFilePost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadVideosFilePost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 動画のサムネイルアップロードURLを生成します。
     * @summary 動画サムネイルアップロードURL生成
     * @param {GetUploadURLRequest} getUploadURLRequest アップロードファイル情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public v1UploadVideosThumbnailPost(getUploadURLRequest: GetUploadURLRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).v1UploadVideosThumbnailPost(getUploadURLRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 購入者の一覧を取得します。管理者は全購入者、コーディネーターは注文実績のある購入者のみ取得可能です。
         * @summary 購入者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersGet: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 購入者を削除します。管理者のみ実行可能です。
         * @summary 購入者削除
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserIdDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1UsersUserIdDelete', 'userId', userId)
            const localVarPath = `/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された購入者の詳細情報を取得します。
         * @summary 購入者取得
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1UsersUserIdGet', 'userId', userId)
            const localVarPath = `/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された購入者の注文履歴と注文統計情報を取得します。
         * @summary 購入者注文履歴取得
         * @param {string} userId 購入者ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserIdOrdersGet: async (userId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('v1UsersUserIdOrdersGet', 'userId', userId)
            const localVarPath = `/v1/users/{userId}/orders`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 購入者の一覧を取得します。管理者は全購入者、コーディネーターは注文実績のある購入者のみ取得可能です。
         * @summary 購入者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersGet(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1UsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 購入者を削除します。管理者のみ実行可能です。
         * @summary 購入者削除
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1UsersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された購入者の詳細情報を取得します。
         * @summary 購入者取得
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1UsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された購入者の注文履歴と注文統計情報を取得します。
         * @summary 購入者注文履歴取得
         * @param {string} userId 購入者ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersUserIdOrdersGet(userId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesUserOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdOrdersGet(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.v1UsersUserIdOrdersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 購入者の一覧を取得します。管理者は全購入者、コーディネーターは注文実績のある購入者のみ取得可能です。
         * @summary 購入者一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesUsersResponse> {
            return localVarFp.v1UsersGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 購入者を削除します。管理者のみ実行可能です。
         * @summary 購入者削除
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1UsersUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された購入者の詳細情報を取得します。
         * @summary 購入者取得
         * @param {string} userId 購入者ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesUserResponse> {
            return localVarFp.v1UsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された購入者の注文履歴と注文統計情報を取得します。
         * @summary 購入者注文履歴取得
         * @param {string} userId 購入者ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersUserIdOrdersGet(userId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TypesUserOrdersResponse> {
            return localVarFp.v1UsersUserIdOrdersGet(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 購入者の一覧を取得します。管理者は全購入者、コーディネーターは注文実績のある購入者のみ取得可能です。
     * @summary 購入者一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersGet(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1UsersGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 購入者を削除します。管理者のみ実行可能です。
     * @summary 購入者削除
     * @param {string} userId 購入者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1UsersUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された購入者の詳細情報を取得します。
     * @summary 購入者取得
     * @param {string} userId 購入者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1UsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された購入者の注文履歴と注文統計情報を取得します。
     * @summary 購入者注文履歴取得
     * @param {string} userId 購入者ID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersUserIdOrdersGet(userId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).v1UsersUserIdOrdersGet(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VideoApi - axios parameter creator
 * @export
 */
export const VideoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 動画の一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
         * @summary 動画一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 動画名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosGet: async (limit?: number, offset?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい動画を登録します。
         * @summary 動画登録
         * @param {TypesCreateVideoRequest} typesCreateVideoRequest 動画情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosPost: async (typesCreateVideoRequest: TypesCreateVideoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typesCreateVideoRequest' is not null or undefined
            assertParamExists('v1VideosPost', 'typesCreateVideoRequest', typesCreateVideoRequest)
            const localVarPath = `/v1/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesCreateVideoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された動画の視聴者分析データを取得します。集計期間と集計間隔を指定できます。
         * @summary 動画分析情報取得
         * @param {string} videoId 動画ID
         * @param {number} [start] 集計開始日時 (unixtime,未指定の場合は動画公開時間)
         * @param {number} [end] 集計終了日時 (unixtime,未指定の場合は現在時刻)
         * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdAnalyticsGet: async (videoId: string, start?: number, end?: number, viewerLogInterval?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1VideosVideoIdAnalyticsGet', 'videoId', videoId)
            const localVarPath = `/v1/videos/{videoId}/analytics`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (viewerLogInterval !== undefined) {
                localVarQueryParameter['viewerLogInterval'] = viewerLogInterval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 動画を削除します。
         * @summary 動画削除
         * @param {string} videoId 動画ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdDelete: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1VideosVideoIdDelete', 'videoId', videoId)
            const localVarPath = `/v1/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された動画の詳細情報を取得します。
         * @summary 動画取得
         * @param {string} videoId 動画ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdGet: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1VideosVideoIdGet', 'videoId', videoId)
            const localVarPath = `/v1/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 動画の情報を更新します。
         * @summary 動画更新
         * @param {string} videoId 動画ID
         * @param {TypesUpdateVideoRequest} typesUpdateVideoRequest 動画情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdPatch: async (videoId: string, typesUpdateVideoRequest: TypesUpdateVideoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1VideosVideoIdPatch', 'videoId', videoId)
            // verify required parameter 'typesUpdateVideoRequest' is not null or undefined
            assertParamExists('v1VideosVideoIdPatch', 'typesUpdateVideoRequest', typesUpdateVideoRequest)
            const localVarPath = `/v1/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateVideoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoApi - functional programming interface
 * @export
 */
export const VideoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideoApiAxiosParamCreator(configuration)
    return {
        /**
         * 動画の一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
         * @summary 動画一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 動画名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideosResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosGet(limit, offset, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1VideosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい動画を登録します。
         * @summary 動画登録
         * @param {TypesCreateVideoRequest} typesCreateVideoRequest 動画情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosPost(typesCreateVideoRequest: TypesCreateVideoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosPost(typesCreateVideoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1VideosPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された動画の視聴者分析データを取得します。集計期間と集計間隔を指定できます。
         * @summary 動画分析情報取得
         * @param {string} videoId 動画ID
         * @param {number} [start] 集計開始日時 (unixtime,未指定の場合は動画公開時間)
         * @param {number} [end] 集計終了日時 (unixtime,未指定の場合は現在時刻)
         * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosVideoIdAnalyticsGet(videoId: string, start?: number, end?: number, viewerLogInterval?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypesAnalyzeVideoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosVideoIdAnalyticsGet(videoId, start, end, viewerLogInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1VideosVideoIdAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 動画を削除します。
         * @summary 動画削除
         * @param {string} videoId 動画ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosVideoIdDelete(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosVideoIdDelete(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1VideosVideoIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された動画の詳細情報を取得します。
         * @summary 動画取得
         * @param {string} videoId 動画ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosVideoIdGet(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosVideoIdGet(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1VideosVideoIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 動画の情報を更新します。
         * @summary 動画更新
         * @param {string} videoId 動画ID
         * @param {TypesUpdateVideoRequest} typesUpdateVideoRequest 動画情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosVideoIdPatch(videoId: string, typesUpdateVideoRequest: TypesUpdateVideoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosVideoIdPatch(videoId, typesUpdateVideoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoApi.v1VideosVideoIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VideoApi - factory interface
 * @export
 */
export const VideoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideoApiFp(configuration)
    return {
        /**
         * 動画の一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
         * @summary 動画一覧取得
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [offset] 取得開始位置(min:0)
         * @param {string} [name] 動画名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<VideosResponse> {
            return localVarFp.v1VideosGet(limit, offset, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい動画を登録します。
         * @summary 動画登録
         * @param {TypesCreateVideoRequest} typesCreateVideoRequest 動画情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosPost(typesCreateVideoRequest: TypesCreateVideoRequest, options?: RawAxiosRequestConfig): AxiosPromise<VideoResponse> {
            return localVarFp.v1VideosPost(typesCreateVideoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された動画の視聴者分析データを取得します。集計期間と集計間隔を指定できます。
         * @summary 動画分析情報取得
         * @param {string} videoId 動画ID
         * @param {number} [start] 集計開始日時 (unixtime,未指定の場合は動画公開時間)
         * @param {number} [end] 集計終了日時 (unixtime,未指定の場合は現在時刻)
         * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdAnalyticsGet(videoId: string, start?: number, end?: number, viewerLogInterval?: string, options?: RawAxiosRequestConfig): AxiosPromise<TypesAnalyzeVideoResponse> {
            return localVarFp.v1VideosVideoIdAnalyticsGet(videoId, start, end, viewerLogInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * 動画を削除します。
         * @summary 動画削除
         * @param {string} videoId 動画ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdDelete(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1VideosVideoIdDelete(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された動画の詳細情報を取得します。
         * @summary 動画取得
         * @param {string} videoId 動画ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdGet(videoId: string, options?: RawAxiosRequestConfig): AxiosPromise<VideoResponse> {
            return localVarFp.v1VideosVideoIdGet(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 動画の情報を更新します。
         * @summary 動画更新
         * @param {string} videoId 動画ID
         * @param {TypesUpdateVideoRequest} typesUpdateVideoRequest 動画情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdPatch(videoId: string, typesUpdateVideoRequest: TypesUpdateVideoRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1VideosVideoIdPatch(videoId, typesUpdateVideoRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoApi - object-oriented interface
 * @export
 * @class VideoApi
 * @extends {BaseAPI}
 */
export class VideoApi extends BaseAPI {
    /**
     * 動画の一覧を取得します。ページネーションと名前でのフィルタリングに対応しています。
     * @summary 動画一覧取得
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [offset] 取得開始位置(min:0)
     * @param {string} [name] 動画名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1VideosGet(limit?: number, offset?: number, name?: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1VideosGet(limit, offset, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい動画を登録します。
     * @summary 動画登録
     * @param {TypesCreateVideoRequest} typesCreateVideoRequest 動画情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1VideosPost(typesCreateVideoRequest: TypesCreateVideoRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1VideosPost(typesCreateVideoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された動画の視聴者分析データを取得します。集計期間と集計間隔を指定できます。
     * @summary 動画分析情報取得
     * @param {string} videoId 動画ID
     * @param {number} [start] 集計開始日時 (unixtime,未指定の場合は動画公開時間)
     * @param {number} [end] 集計終了日時 (unixtime,未指定の場合は現在時刻)
     * @param {string} [viewerLogInterval] 集計間隔 (未指定の場合は1分間隔)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1VideosVideoIdAnalyticsGet(videoId: string, start?: number, end?: number, viewerLogInterval?: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1VideosVideoIdAnalyticsGet(videoId, start, end, viewerLogInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 動画を削除します。
     * @summary 動画削除
     * @param {string} videoId 動画ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1VideosVideoIdDelete(videoId: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1VideosVideoIdDelete(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された動画の詳細情報を取得します。
     * @summary 動画取得
     * @param {string} videoId 動画ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1VideosVideoIdGet(videoId: string, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1VideosVideoIdGet(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 動画の情報を更新します。
     * @summary 動画更新
     * @param {string} videoId 動画ID
     * @param {TypesUpdateVideoRequest} typesUpdateVideoRequest 動画情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public v1VideosVideoIdPatch(videoId: string, typesUpdateVideoRequest: TypesUpdateVideoRequest, options?: RawAxiosRequestConfig) {
        return VideoApiFp(this.configuration).v1VideosVideoIdPatch(videoId, typesUpdateVideoRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VideoCommentApi - axios parameter creator
 * @export
 */
export const VideoCommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 動画コメントの状態（無効/有効）を更新します。
         * @summary 動画コメント更新
         * @param {string} videoId 動画ID
         * @param {string} commentId コメントID
         * @param {TypesUpdateVideoCommentRequest} typesUpdateVideoCommentRequest コメント情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdCommentsCommentIdPatch: async (videoId: string, commentId: string, typesUpdateVideoCommentRequest: TypesUpdateVideoCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1VideosVideoIdCommentsCommentIdPatch', 'videoId', videoId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('v1VideosVideoIdCommentsCommentIdPatch', 'commentId', commentId)
            // verify required parameter 'typesUpdateVideoCommentRequest' is not null or undefined
            assertParamExists('v1VideosVideoIdCommentsCommentIdPatch', 'typesUpdateVideoCommentRequest', typesUpdateVideoCommentRequest)
            const localVarPath = `/v1/videos/{videoId}/comments/{commentId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typesUpdateVideoCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された動画のコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
         * @summary 動画コメント一覧取得
         * @param {string} videoId 動画ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [start] 検索開始日時（unixtime）
         * @param {number} [end] 検索終了日時（unixtime）
         * @param {string} [next] 次ページトークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdCommentsGet: async (videoId: string, limit?: number, start?: number, end?: number, next?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('v1VideosVideoIdCommentsGet', 'videoId', videoId)
            const localVarPath = `/v1/videos/{videoId}/comments`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerauth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoCommentApi - functional programming interface
 * @export
 */
export const VideoCommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideoCommentApiAxiosParamCreator(configuration)
    return {
        /**
         * 動画コメントの状態（無効/有効）を更新します。
         * @summary 動画コメント更新
         * @param {string} videoId 動画ID
         * @param {string} commentId コメントID
         * @param {TypesUpdateVideoCommentRequest} typesUpdateVideoCommentRequest コメント情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosVideoIdCommentsCommentIdPatch(videoId: string, commentId: string, typesUpdateVideoCommentRequest: TypesUpdateVideoCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosVideoIdCommentsCommentIdPatch(videoId, commentId, typesUpdateVideoCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoCommentApi.v1VideosVideoIdCommentsCommentIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された動画のコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
         * @summary 動画コメント一覧取得
         * @param {string} videoId 動画ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [start] 検索開始日時（unixtime）
         * @param {number} [end] 検索終了日時（unixtime）
         * @param {string} [next] 次ページトークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1VideosVideoIdCommentsGet(videoId: string, limit?: number, start?: number, end?: number, next?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoCommentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1VideosVideoIdCommentsGet(videoId, limit, start, end, next, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideoCommentApi.v1VideosVideoIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VideoCommentApi - factory interface
 * @export
 */
export const VideoCommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideoCommentApiFp(configuration)
    return {
        /**
         * 動画コメントの状態（無効/有効）を更新します。
         * @summary 動画コメント更新
         * @param {string} videoId 動画ID
         * @param {string} commentId コメントID
         * @param {TypesUpdateVideoCommentRequest} typesUpdateVideoCommentRequest コメント情報
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdCommentsCommentIdPatch(videoId: string, commentId: string, typesUpdateVideoCommentRequest: TypesUpdateVideoCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1VideosVideoIdCommentsCommentIdPatch(videoId, commentId, typesUpdateVideoCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された動画のコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
         * @summary 動画コメント一覧取得
         * @param {string} videoId 動画ID
         * @param {number} [limit] 取得上限数(max:200)
         * @param {number} [start] 検索開始日時（unixtime）
         * @param {number} [end] 検索終了日時（unixtime）
         * @param {string} [next] 次ページトークン
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1VideosVideoIdCommentsGet(videoId: string, limit?: number, start?: number, end?: number, next?: string, options?: RawAxiosRequestConfig): AxiosPromise<VideoCommentsResponse> {
            return localVarFp.v1VideosVideoIdCommentsGet(videoId, limit, start, end, next, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoCommentApi - object-oriented interface
 * @export
 * @class VideoCommentApi
 * @extends {BaseAPI}
 */
export class VideoCommentApi extends BaseAPI {
    /**
     * 動画コメントの状態（無効/有効）を更新します。
     * @summary 動画コメント更新
     * @param {string} videoId 動画ID
     * @param {string} commentId コメントID
     * @param {TypesUpdateVideoCommentRequest} typesUpdateVideoCommentRequest コメント情報
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoCommentApi
     */
    public v1VideosVideoIdCommentsCommentIdPatch(videoId: string, commentId: string, typesUpdateVideoCommentRequest: TypesUpdateVideoCommentRequest, options?: RawAxiosRequestConfig) {
        return VideoCommentApiFp(this.configuration).v1VideosVideoIdCommentsCommentIdPatch(videoId, commentId, typesUpdateVideoCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された動画のコメント一覧を取得します。ページネーションと期間フィルタリングに対応しています。
     * @summary 動画コメント一覧取得
     * @param {string} videoId 動画ID
     * @param {number} [limit] 取得上限数(max:200)
     * @param {number} [start] 検索開始日時（unixtime）
     * @param {number} [end] 検索終了日時（unixtime）
     * @param {string} [next] 次ページトークン
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoCommentApi
     */
    public v1VideosVideoIdCommentsGet(videoId: string, limit?: number, start?: number, end?: number, next?: string, options?: RawAxiosRequestConfig) {
        return VideoCommentApiFp(this.configuration).v1VideosVideoIdCommentsGet(videoId, limit, start, end, next, options).then((request) => request(this.axios, this.basePath));
    }
}



